<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drag Race Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html-to-image/1.11.11/html-to-image.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@200;300;400;500;600;700;800&family=Poppins:wght@300;400;500;600;700&family=Rubik:wght@400;500;700;900&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Manrope', sans-serif; background-color: #f3f4f6; }
        * { font-style: normal; }
        em, i { font-style: normal; }
        h1, h2, h3, h4, h5, h6, .font-heading { font-family: 'Poppins', sans-serif !important; }
        #stageContent .font-bold:not(.font-heading):not(.sc-title):not(h1):not(h2):not(h3):not(h4):not(h5):not(h6),
        #stageContent .font-black:not(.font-heading):not(.sc-title):not(h1):not(h2):not(h3):not(h4):not(h5):not(h6),
        #stageContent .font-extrabold:not(.font-heading):not(.sc-title):not(h1):not(h2):not(h3):not(h4):not(h5):not(h6) { font-family: 'Manrope', sans-serif !important; }
        #stageContent h1,
        #stageContent h2,
        #stageContent h3,
        #stageContent h4,
        #stageContent h5,
        #stageContent h6 { text-align: center !important; width: 100%; }

        .custom-table { width: 100%; border-collapse: separate; border-spacing: 0 6px; font-family: 'Manrope', sans-serif; }
        .custom-table thead th { padding: 12px 8px; font-size: 11px; text-transform: uppercase; color: #6b7280; border-bottom: 2px solid #e5e7eb; letter-spacing: 0.05em; }
        
        .custom-table tbody tr { background: transparent; box-shadow: none; }
        
        .custom-table tbody tr:nth-child(n+4) { background: transparent; box-shadow: none; }

        .custom-table td { padding: 8px 4px; vertical-align: middle; text-align: center; font-size: 13px; border: none; }
        
        .custom-table td:first-child { border-top-left-radius: 8px; border-bottom-left-radius: 8px; }
        .custom-table td:last-child { border-top-right-radius: 8px; border-bottom-right-radius: 8px; }

        .custom-table .bracket-title { 
            color: #ffffff;
            font-weight: 800; 
            font-size: 16px; 
            text-align: center; 
            padding: 12px 8px; 
            text-transform: uppercase;
            letter-spacing: 0.05em;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            border-radius: 0 !important;
        }

        .custom-table .bp-head td { 
            background-color: #f3f4f6; 
            font-weight: 700; 
            color: #374151; 
            font-size: 11px; 
            text-transform: uppercase; 
            padding: 10px;
            letter-spacing: 0.05em;
            border-radius: 0 !important;
        }

        .custom-table .bp-sub td { 
            background-color: transparent; 
            font-weight: 700; 
            color: #9ca3af; 
            font-size: 10px; 
            text-transform: uppercase; 
            padding: 4px 4px;
            letter-spacing: 0.05em;
        }


        .custom-table td.text-left { text-align: left; padding-left: 16px; font-weight: 700; color: #1f2937; }
        .custom-table .bp-earned, .custom-table .bp-gift {
            font-weight: 600;
            color: #d1d5db; 
            padding: 4px 0; 
        }

        .custom-table .bp-earned.pos, .custom-table .bp-gift.pos { 
            font-weight: 800; 
            border-radius: 0; 
            box-shadow: none;
        }

        .custom-table .pos-3 { background-color: #4169e1 !important; color: white !important; }
        .custom-table .pos-2 { background-color: #00bfff !important; color: black !important; }
        .custom-table .pos-1 { background-color: #add8e6 !important; color: black !important; }
        .custom-table .pos-gift { background-color: #add8e6 !important; color: black !important; }

        .custom-table .bp-total { 
            font-weight: 800; 
            color: #111827; 
            font-size: 14px;
        }

        .badge { display: flex; align-items: center; justify-content: center; width: 30px; height: 30px; margin: 0 auto; border-radius: 50%; font-weight: 700; font-size: 9px; color: #1f2937; }
        .st-win { background-color: #2563eb; color: white; }
        .st-dbl { background-color: #1e40af; color: white; }
        .st-high { background-color: #add8e6; color: #1e3a8a; }
        .st-high-team { background-color: #7fffd4; color: #111827; }
        .st-safe { background-color: #f3f4f6; color: #9ca3af; }
        .st-low { background-color: #fbcfe8; color: #831843; }
        .st-btm { background-color: #ff6347; color: white;}
        .st-shantay { background-color: #db2777; color: white; }
        .st-elim { background-color: #ef4444; color: white; }
        .st-elim-finale { background-color: #a0522d; color: white; width: auto; padding: 0 0px; border-radius: 8px;}
        .st-winner { background: linear-gradient(135deg, #fbbf24, #d97706); color: white; width: auto; padding: 0 8px; border-radius: 8px; }
        .st-winner-of-season {background-color: #ffff00; color: black; width: auto; padding: 0 0px; border-radius: 8px; }
        .st-runnerup { background-color: #c0c0c0; color: black; width: auto; padding: 0 0px; border-radius: 8px; }
        .st-top2 { background-color: #00befe; color: black; }
        .st-beaver { background-color: #a855f7; color: white; }

        .track-record-table-wrapper { display: inline-block; margin: 0 auto; min-width: 0; }
        .track-record-table { border-collapse: collapse; font-size: 12px; table-layout: fixed; font-family: 'Rubik', sans-serif; }
        .track-record-table thead th { border: 1px solid #d1d5db; padding: 8px 6px; text-align: center; font-weight: 700; color: #374151; background-color: #f3f4f6; box-sizing: border-box; }
        .track-record-table thead th.tr-sub { font-weight: 400; font-size: 11px; color: #6b7280; }
        .track-record-table tbody td { border: 1px solid #e5e7eb; padding: 6px 8px; vertical-align: middle; text-align: center; box-sizing: border-box; }
        .track-record-table tbody td.tr-rank { color: #6b7280; font-weight: 400; width: 44px; min-width: 44px; }
        .track-record-table tbody td.tr-contestant { text-align: center; font-weight: 700; color: #111827; width: 130px; min-width: 130px; overflow: hidden; text-overflow: ellipsis; }
        .track-record-table tbody td.tr-photo { padding: 0; width: 52px; min-width: 52px; height: 52px; font-size: 0; line-height: 0; vertical-align: middle; overflow: hidden; }
        .track-record-table tbody td.tr-photo img { width: 52px; height: 52px; min-width: 52px; min-height: 52px; object-fit: cover; line-height: 0; object-position: center; display: block; margin: 0; padding: 0; border: none; background: transparent; }
        .track-record-table tbody td.tr-ep { width: 72px; min-width: 72px; }
        .track-record-table tbody td.tr-ppe { font-weight: 700; color: #111827; background-color: #f9fafb; width: 56px; min-width: 56px; }
        .track-record-table tbody tr { height: 52px; max-height: 52px;}

        .track-record-table .tr-win { background-color: #4169e1; color: white; font-weight: 700; }
        .track-record-table .tr-dbl { background-color: #1e40af; color: white; font-weight: 700; }
        .track-record-table .tr-top2 { background-color: #00befe; color: #111827; }
        .track-record-table .tr-high { background-color: #add8e6; color: #111827; }
        .track-record-table .tr-high-team { background-color: #7fffd4; color: #111827; }
        .track-record-table .tr-safe { background-color: #ffffff; color: #111827; }
        .track-record-table .tr-low { background-color: #fbcfe8; color: #111827; }
        .track-record-table .tr-btm { background-color: #ff6347; color: #111827; }
        .track-record-table .tr-elim { background-color: #ff0000; color: #111827; font-weight:700; }
        .track-record-table .tr-elim-finale { background-color: #a0522d; color: white;  font-weight: 700;}
        .track-record-table .tr-runnerup { background-color: #c0c0c0; color: #111827; font-weight: 700; }
        .track-record-table .tr-lost3 { background-color: #ffd100; color: #111827; font-weight: 700; }
        .track-record-table .tr-lost2 { background-color: #ffae00; color: #111827; font-weight: 700; }
        .track-record-table .tr-lost1 { background-color: #ff7c00; color: #111827; font-weight: 700; }
        .track-record-table .tr-winner-of-season { background:  #ffff00; color: #111827; font-weight: 700; }
        .track-record-table .tr-misscon { background-color: #00ffff; color: #111827; font-weight: 700; }
        .track-record-table .tr-shantay { background-color: #ff69b4; color: #111827; }
        .track-record-table .tr-beaver { background-color: #FED09F; color: #111827;  }
        .track-record-table .tr-empty { background-color: #e5e7eb; }

        .scenario-card { transition: all 0.3s ease; animation: fadeIn 0.5s ease-out; }
        .perf-slay { border-left: 4px solid #2563eb; background: #eff6ff; }
        .perf-good { border-left: 4px solid #06b6d4; background: #ecfeff; }
        .perf-safe { border-left: 4px solid #9ca3af; background: #f9fafb; }
        .perf-bad { border-left: 4px solid #db2777; background: #fdf2f8; }
        .perf-flop { border-left: 4px solid #dc2626; background: #fef2f2; }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes bounceSubtle {
            0%, 100% { transform: translateY(-5%); animation-timing-function: cubic-bezier(0.8,0,1,1); }
            50% { transform: translateY(0); animation-timing-function: cubic-bezier(0,0,0.2,1); }
        }
        .animate-bounce-subtle { animation: bounceSubtle 2s infinite; }
        #stageContent .sc-title { font-size: 24px; font-weight: 900; font-family: 'Poppins', sans-serif !important; }
        #stageContent .sc-section { font-size: 20px; font-weight: 800; font-family: 'Poppins', sans-serif !important; }
        #stageContent .sc-label { font-size: 14px; font-weight: 900; font-family: 'Poppins', sans-serif !important; }
        #stageContent .sc-kicker { font-size: 10px; font-weight: 900; }
        #stageContent .sc-body { font-size: 14px; }
        #stageContent .sc-caption { font-size: 12px; }
        @media (min-width: 640px) {
            #stageContent .sc-title { font-size: 32px; }
            #stageContent .sc-section { font-size: 24px; }
            #stageContent .sc-label { font-size: 18px; }
            #stageContent .sc-kicker { font-size: 11px; }
            #stageContent .sc-body { font-size: 16px; }
            #stageContent .sc-caption { font-size: 13px; }
        }
        
        .queen-img-sm { width: 32px; height: 32px; border-radius: 50%; object-fit: cover; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .queen-img-md { width: 56px; height: 56px; border-radius: 50%; object-fit: cover; border: 3px solid white; box-shadow: 0 6px 10px rgba(0,0,0,0.12); }
        .queen-img-lg { width: 96px; height: 96px; min-width: 96px; min-height: 96px; border-radius: 50%; object-fit: cover; border: 4px solid white; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1); flex-shrink: 0; }
        .queen-img-results-wrap { width: 110px; height: 110px; aspect-ratio: 1 / 1; border-radius: 9999px; overflow: hidden; clip-path: circle(50%); border: 4px solid white; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1); }
        .queen-img-results { width: 100%; height: 100%; object-fit: cover; display: block; border-radius: 50%; clip-path: circle(50%); }
        @media (min-width: 640px) {
            .queen-img-md { width: 64px; height: 64px; }
            .queen-img-lg { width: 120px; height: 120px; }
        }
    </style>
</head>
<body class="min-h-screen bg-[#f6f6f8]">
    <header id="headerSection" class="relative overflow-hidden bg-white border-b border-gray-300">
        <div class="absolute inset-0 pointer-events-none" style="background: radial-gradient(ellipse at top, rgba(255, 47, 146, 0.15), rgba(255, 211, 105, 0.05) 40%, transparent 70%);"></div>

        <div class="relative max-w-5xl mx-auto px-4">
            <div id="headerMainRow" class="py-6 text-center">
                <h1 class="text-3xl sm:text-4xl font-black text-transparent bg-clip-text" style="background-image: linear-gradient(120deg, #FF2F92, #FFD369);">DRAG RACE SIMULATOR</h1>
                <span class="inline-block mt-1 text-gray-400 text-[10px] font-black tracking-[0.2em] uppercase">BETA TEST</span>
            </div>

            <div id="headerScenarioRow" class="hidden py-3 flex items-center justify-between gap-3">
                <button type="button" onclick="exitScenarioToSetup()" class="h-8 px-4 rounded-xl border border-gray-200 bg-white text-[11px] font-bold text-gray-700 hover:bg-gray-50 transition inline-flex items-center gap-2">
                    <span class="text-gray-500">‹</span>
                    <span>Back</span>
                </button>

                <div class="text-center min-w-0">
                    <div id="episodeLabel" class="font-heading text-lg sm:text-xl font-bold text-gray-900 truncate">Episode 1</div>
                    <div id="scenarioChallengeLabel" class="mt-0.5 text-[9px] font-black text-[#ec4899] uppercase truncate">DESIGN CHALLENGE</div>
                </div>

                <div id="castLeftLabel" class="h-8 px-3 rounded-full bg-pink-50 text-[#ec4899] text-[11px] font-black inline-flex items-center">8 Queens</div>
            </div>
        </div>
    </header>

    <main class="max-w-5xl mx-auto px-4 py-6">

        <div id="setupPanel" class="space-y-6 mb-8">
            <section id="castSelectionPanel" class="bg-white rounded-2xl shadow-xl p-6 border border-gray-200/60">
            <div class="flex flex-col md:flex-row md:items-center md:justify-between gap-4 mb-4">
                <div class="flex items-center gap-3">
                    <div class="flex items-center gap-2">
                        <span class="text-pink-600">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M22 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>
                        </span>
                        <h2 class="text-xl font-black text-gray-900">Cast Selection</h2>
                        <span id="selectedCount" class="inline-flex items-center rounded-full bg-pink-100 text-pink-700 px-3 py-1 text-xs font-bold">0 queens</span>
                    </div>
                </div>
                <div class="flex flex-wrap items-center gap-2">
                    <button onclick="showQueenStats()" class="h-10 px-4 rounded-xl border border-blue-300 bg-white text-blue-600 text-sm font-bold hover:bg-blue-50">Stats</button>
                    <button onclick="deselectAll()" class="h-10 px-4 rounded-xl border border-gray-200 bg-white text-gray-600 text-sm font-bold hover:bg-gray-50">Clear</button>
                </div>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-[1fr_auto_auto] gap-3 items-center mb-4">
                <div class="relative">
                    <input id="queenSearchInput" type="text" oninput="renderQueensGrid()"
                        class="h-10 w-full rounded-xl border border-gray-200 bg-gray-50 px-3 text-sm font-bold text-gray-800 placeholder:text-gray-400 focus:bg-white focus:border-pink-300 focus:ring-2 focus:ring-pink-100"
                        placeholder="Search queens by name or season...">
                    <div id="queenSearchResults" class="hidden absolute left-0 right-0 top-full mt-2 max-h-80 overflow-y-auto rounded-2xl border border-gray-200 bg-white shadow-xl z-20"></div>
                </div>

                <button onclick="addRandomQueen()" class="h-10 w-full md:w-auto px-5 rounded-xl border border-amber-300 bg-white text-sm font-bold hover:bg-amber-50 flex items-center justify-center gap-2">
                    <span class="text-amber-500">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 3h5v5"/><path d="M4 20L21 3"/><path d="M21 16v5h-5"/><path d="M15 15l6 6"/><path d="M4 4l5 5"/></svg>
                    </span> Random
                </button>

                <details class="relative w-full md:w-auto">
                    <summary class="h-10 w-full md:w-auto px-5 rounded-xl border border-gray-200 bg-white text-sm font-bold hover:bg-gray-50 flex items-center justify-center gap-2 cursor-pointer">
                        Presets <span class="text-gray-400">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m6 9 6 6 6-6"/></svg>
                        </span>
                    </summary>
                    <div class="absolute right-0 mt-2 w-full md:w-44 max-h-64 overflow-y-auto rounded-xl border border-gray-200 bg-white shadow-lg p-1 z-10">
                        <button type="button" onclick="applyCastPreset('us18')" class="w-full text-left px-3 py-2 rounded-lg text-sm font-bold text-gray-700 hover:bg-gray-50">US S18</button>
                        <button type="button" onclick="applyCastPreset('us17')" class="w-full text-left px-3 py-2 rounded-lg text-sm font-bold text-gray-700 hover:bg-gray-50">US S17</button>
                        <button type="button" onclick="applyCastPreset('us16')" class="w-full text-left px-3 py-2 rounded-lg text-sm font-bold text-gray-700 hover:bg-gray-50">US S16</button>
                        <button type="button" onclick="applyCastPreset('us15')" class="w-full text-left px-3 py-2 rounded-lg text-sm font-bold text-gray-700 hover:bg-gray-50">US S15</button>
                        <button type="button" onclick="applyCastPreset('us14')" class="w-full text-left px-3 py-2 rounded-lg text-sm font-bold text-gray-700 hover:bg-gray-50">US S14</button>
                        <button type="button" onclick="applyCastPreset('us13')" class="w-full text-left px-3 py-2 rounded-lg text-sm font-bold text-gray-700 hover:bg-gray-50">US S13</button>
                        <button type="button" onclick="applyCastPreset('us9')" class="w-full text-left px-3 py-2 rounded-lg text-sm font-bold text-gray-700 hover:bg-gray-50">US S9</button>
                        <button type="button" onclick="applyCastPreset('us7')" class="w-full text-left px-3 py-2 rounded-lg text-sm font-bold text-gray-700 hover:bg-gray-50">US S7</button>
                        <button type="button" onclick="applyCastPreset('us6')" class="w-full text-left px-3 py-2 rounded-lg text-sm font-bold text-gray-700 hover:bg-gray-50">US S6</button>
                        <button type="button" onclick="applyCastPreset('us5')" class="w-full text-left px-3 py-2 rounded-lg text-sm font-bold text-gray-700 hover:bg-gray-50">US S5</button>
                        <button type="button" onclick="applyCastPreset('us4')" class="w-full text-left px-3 py-2 rounded-lg text-sm font-bold text-gray-700 hover:bg-gray-50">US S4</button>
                        <button type="button" onclick="applyCastPreset('cdr6')" class="w-full text-left px-3 py-2 rounded-lg text-sm font-bold text-gray-700 hover:bg-gray-50">CDR S6</button>
                        <button type="button" onclick="applyCastPreset('cdr1')" class="w-full text-left px-3 py-2 rounded-lg text-sm font-bold text-gray-700 hover:bg-gray-50">CDR S1</button>
                        <button type="button" onclick="applyCastPreset('uk7')" class="w-full text-left px-3 py-2 rounded-lg text-sm font-bold text-gray-700 hover:bg-gray-50">UK 7</button>
                        <button type="button" onclick="applyCastPreset('uk6')" class="w-full text-left px-3 py-2 rounded-lg text-sm font-bold text-gray-700 hover:bg-gray-50">UK 6</button>
                        <button type="button" onclick="applyCastPreset('uk5')" class="w-full text-left px-3 py-2 rounded-lg text-sm font-bold text-gray-700 hover:bg-gray-50">UK 5</button>
                        <button type="button" onclick="applyCastPreset('UKvsTW3')" class="w-full text-left px-3 py-2 rounded-lg text-sm font-bold text-gray-700 hover:bg-gray-50">UK vs TW 3</button>
                    </div>
                </details>
            </div>

            <div class="rounded-2xl border border-pink-200/60 bg-pink-50/40 p-4 mb-4">
                <div class="text-[10px] font-black text-pink-600 uppercase mb-3" id="yourCastLabel">Your Cast (<span id="yourCastCount">0</span>)</div>
                <div id="selectedQueensGrid" class="flex flex-wrap gap-2"></div>
            </div>

                <button type="button" onclick="toggleBrowseQueens()" class="w-full flex items-center justify-between rounded-xl border border-gray-200 bg-white px-4 py-3 text-sm font-bold text-gray-900 hover:bg-gray-50">
                <span>Browse All Queens <span class="ml-1 text-xs font-bold text-gray-400">(<span id="totalQueensCount">0</span> total)</span></span>
                <span id="browseQueensChevron" class="text-gray-400">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m6 9 6 6 6-6"/></svg>
                </span>
            </button>
            <div id="browseQueensPanel" class="mt-3">
                <div class="hidden grid grid-cols-3 md:grid-cols-5 gap-2 max-h-[300px] overflow-y-auto pr-2 mb-6" id="queensGrid"></div>
            </div>

            </section>

            <section id="seasonSettingsPanel" class="bg-white rounded-2xl shadow-xl p-6 border border-gray-200/60">
                <div class="flex items-center gap-2 mb-4">
                    <span class="text-amber-500">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="21" x2="14" y1="4" y2="4"/><line x1="10" x2="3" y1="4" y2="4"/><line x1="21" x2="12" y1="12" y2="12"/><line x1="8" x2="3" y1="12" y2="12"/><line x1="21" x2="16" y1="20" y2="20"/><line x1="12" x2="3" y1="20" y2="20"/><line x1="14" x2="14" y1="2" y2="6"/><line x1="8" x2="8" y1="10" y2="14"/><line x1="16" x2="16" y1="18" y2="22"/></svg>
                    </span>
                    <h3 class="text-xl font-black text-gray-900">Season Settings</h3>
                </div>

                <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <div>
                        <label class="text-[10px] font-black text-gray-500 uppercase block mb-2">Season format</label>
                        <select id="seasonModeSelect" onchange="toggleSeasonMode()" class="h-10 w-full rounded-xl border border-gray-200 bg-gray-50 px-3 text-sm font-bold text-gray-900 focus:bg-white focus:border-pink-300 focus:ring-2 focus:ring-pink-100">
                            <option value="regular" selected>Regular Season</option>
                            <option value="allstars">All Stars (Lipsticks)</option>
                            <option value="beaver">Beaver (Canada)</option>
                            <option value="tournament">Tournament of All Stars</option>
                        </select>
                    </div>

                    <div id="regularOptions">
                        <label class="text-[10px] font-black text-gray-500 uppercase block mb-2">Finale format</label>
                        <select id="finaleTypeSelect" class="h-10 w-full rounded-xl border border-gray-200 bg-gray-50 px-3 text-sm font-bold text-gray-900 focus:bg-white focus:border-pink-300 focus:ring-2 focus:ring-pink-100">
                            <option value="3" selected>Top 3</option>
                            <option value="4">Top 4</option>
                            <option value="4crown">Top 4 (Lip Sync For The Crown)</option>
                        </select>
                    </div>

                    <div id="premiereOptions">
                        <label class="text-[10px] font-black text-gray-500 uppercase block mb-2">Premiere</label>
                        <select id="premiereTypeSelect" onchange="setPremiereType(this.value)" class="h-10 w-full rounded-xl border border-gray-200 bg-gray-50 px-3 text-sm font-bold text-gray-900 focus:bg-white focus:border-pink-300 focus:ring-2 focus:ring-pink-100">
                            <option value="normal" selected>Normal Premiere</option>
                            <option value="double">Double Premiere (No Elim)</option>
                            <option value="double_elim">Double Premiere (Elim)</option>
                        </select>
                    </div>

                    <div>
                        <label class="text-[10px] font-black text-gray-500 uppercase block mb-2">Return Format</label>
                        <select id="returnFormatSelect" onchange="setReturnFormat(this.value)" class="h-10 w-full rounded-xl border border-gray-200 bg-gray-50 px-3 text-sm font-bold text-gray-900 focus:bg-white focus:border-pink-300 focus:ring-2 focus:ring-pink-100">
                            <option value="none" selected>None</option>
                            <option value="choose">Choose who returns</option>
                        </select>
                    </div>

                    <div id="luckyQueenTwistContainer">
                        <label class="text-[10px] font-black text-gray-500 uppercase block mb-2">Twists</label>
                         <label class="flex items-center gap-2 cursor-pointer p-2 rounded-xl border border-gray-200 hover:bg-gray-50 bg-white">
                            <input type="checkbox" id="luckyQueenTwist" class="h-5 w-5 rounded border-gray-300 text-pink-600 focus:ring-pink-500" onchange="toggleLuckyQueenSelect()">
                            <span class="text-xs font-bold text-gray-900">Lucky Queen (El Roscón de Reinas)</span>
                        </label>
                    </div>
                </div>
            </section>

            <div>
                <button onclick="onStartSeasonClick()" id="generateBtn" disabled
                    class="w-full h-14 rounded-2xl bg-[#ec4899] text-white font-black text-lg shadow-lg hover:bg-[#db2777] transition disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center gap-3">
                    <span>START SEASON</span>
                </button>
                <p id="startSeasonHint" class="mt-2 text-center text-xs font-medium text-gray-400">Select at least 4 queens to start</p>
            </div>
        </div>

        <div id="openerPickerPanel" class="hidden mb-10" style="display: none;">
            <div class="flex items-center justify-center gap-4 sm:gap-8 pb-6 pt-2">
                <div class="flex items-center gap-2">
                    <div class="flex h-7 w-7 items-center justify-center rounded-full bg-[#ec4899] text-xs font-black text-white">1</div>
                    <span class="hidden sm:inline text-xs font-bold text-gray-900">Season Opener</span>
                </div>
                <div id="openerStepSep1" class="h-px w-10 sm:w-14 bg-gray-200"></div>
                <div id="openerStepDouble" class="flex items-center gap-2">
                    <div class="flex h-7 w-7 items-center justify-center rounded-full bg-gray-200 text-xs font-black text-gray-600">2</div>
                    <span class="hidden sm:inline text-xs font-bold text-gray-500">Double Premiere</span>
                </div>
                <div class="h-px w-10 sm:w-14 bg-gray-200"></div>
                <div id="openerStepTwists" class="hidden flex items-center gap-2">
                    <div id="openerStepTwistsNum" class="flex h-7 w-7 items-center justify-center rounded-full bg-gray-200 text-xs font-black text-gray-600">3</div>
                    <span class="hidden sm:inline text-xs font-bold text-gray-500">Twists</span>
                </div>
                <div id="openerStepSepTwists" class="hidden h-px w-10 sm:w-14 bg-gray-200"></div>
                <div class="flex items-center gap-2">
                    <div id="openerStepPersonalityNum" class="flex h-7 w-7 items-center justify-center rounded-full bg-gray-200 text-xs font-black text-gray-600">3</div>
                    <span class="hidden sm:inline text-xs font-bold text-gray-500">Personality</span>
                </div>
                <div class="h-px w-10 sm:w-14 bg-gray-200"></div>
                <div class="flex items-center gap-2">
                    <div id="openerStepRelationshipsNum" class="flex h-7 w-7 items-center justify-center rounded-full bg-gray-200 text-xs font-black text-gray-600">4</div>
                    <span class="hidden sm:inline text-xs font-bold text-gray-500">Relationships</span>
                </div>
            </div>

            <section class="bg-white rounded-2xl shadow-xl p-8 sm:p-10 border border-gray-200/60">
                <div class="flex flex-col items-center gap-2">
                    <h2 class="text-center text-2xl sm:text-3xl font-bold text-gray-900">Choose Season Opener (Ep 1)</h2>
                    <p class="text-center text-sm text-gray-500">Select the challenge for the first episode.</p>
                </div>

                <div class="mt-7 flex flex-wrap items-center justify-center gap-3">
                    <label class="cursor-pointer">
                        <input type="radio" name="seasonOpener" value="Talent Show" class="peer sr-only">
                        <span class="relative flex items-center rounded-xl border px-6 py-3 text-sm font-bold transition pl-11 border-gray-200 bg-white text-gray-900 hover:bg-gray-50 peer-checked:border-[#ec4899] peer-checked:bg-pink-50 peer-checked:text-[#ec4899]
                            before:absolute before:left-4 before:top-1/2 before:-translate-y-1/2 before:h-4 before:w-4 before:rounded-full before:border-2 before:border-gray-300
                            peer-checked:before:border-[#ec4899] peer-checked:before:bg-[#ec4899] peer-checked:before:shadow-[inset_0_0_0_3px_white]">Talent Show</span>
                    </label>
                    <label class="cursor-pointer">
                        <input type="radio" name="seasonOpener" value="Design" class="peer sr-only">
                        <span class="relative flex items-center rounded-xl border px-6 py-3 text-sm font-bold transition pl-11 border-gray-200 bg-white text-gray-900 hover:bg-gray-50 peer-checked:border-[#ec4899] peer-checked:bg-pink-50 peer-checked:text-[#ec4899]
                            before:absolute before:left-4 before:top-1/2 before:-translate-y-1/2 before:h-4 before:w-4 before:rounded-full before:border-2 before:border-gray-300
                            peer-checked:before:border-[#ec4899] peer-checked:before:bg-[#ec4899] peer-checked:before:shadow-[inset_0_0_0_3px_white]">Design</span>
                    </label>
                    <label class="cursor-pointer">
                        <input type="radio" name="seasonOpener" value="Girl Groups" class="peer sr-only">
                        <span class="relative flex items-center rounded-xl border px-6 py-3 text-sm font-bold transition pl-11 border-gray-200 bg-white text-gray-900 hover:bg-gray-50 peer-checked:border-[#ec4899] peer-checked:bg-pink-50 peer-checked:text-[#ec4899]
                            before:absolute before:left-4 before:top-1/2 before:-translate-y-1/2 before:h-4 before:w-4 before:rounded-full before:border-2 before:border-gray-300
                            peer-checked:before:border-[#ec4899] peer-checked:before:bg-[#ec4899] peer-checked:before:shadow-[inset_0_0_0_3px_white]">Girl Groups</span>
                    </label>
                    <label class="cursor-pointer">
                        <input type="radio" name="seasonOpener" value="Runway" class="peer sr-only">
                        <span class="relative flex items-center rounded-xl border px-6 py-3 text-sm font-bold transition pl-11 border-gray-200 bg-white text-gray-900 hover:bg-gray-50 peer-checked:border-[#ec4899] peer-checked:bg-pink-50 peer-checked:text-[#ec4899]
                            before:absolute before:left-4 before:top-1/2 before:-translate-y-1/2 before:h-4 before:w-4 before:rounded-full before:border-2 before:border-gray-300
                            peer-checked:before:border-[#ec4899] peer-checked:before:bg-[#ec4899] peer-checked:before:shadow-[inset_0_0_0_3px_white]">Runway</span>
                    </label>
                    <label class="cursor-pointer">
                        <input type="radio" name="seasonOpener" value="Rumix" class="peer sr-only">
                        <span class="relative flex items-center rounded-xl border px-6 py-3 text-sm font-bold transition pl-11 border-gray-200 bg-white text-gray-900 hover:bg-gray-50 peer-checked:border-[#ec4899] peer-checked:bg-pink-50 peer-checked:text-[#ec4899]
                            before:absolute before:left-4 before:top-1/2 before:-translate-y-1/2 before:h-4 before:w-4 before:rounded-full before:border-2 before:border-gray-300
                            peer-checked:before:border-[#ec4899] peer-checked:before:bg-[#ec4899] peer-checked:before:shadow-[inset_0_0_0_3px_white]">Rumix</span>
                    </label>
                    <label class="cursor-pointer">
                        <input type="radio" name="seasonOpener" value="Random" class="peer sr-only" checked>
                        <span class="relative flex items-center rounded-xl border px-6 py-3 text-sm font-bold transition pl-11 border-gray-200 bg-white text-gray-900 hover:bg-gray-50 peer-checked:border-[#ec4899] peer-checked:bg-pink-50 peer-checked:text-[#ec4899]
                            before:absolute before:left-4 before:top-1/2 before:-translate-y-1/2 before:h-4 before:w-4 before:rounded-full before:border-2 before:border-gray-300
                            peer-checked:before:border-[#ec4899] peer-checked:before:bg-[#ec4899] peer-checked:before:shadow-[inset_0_0_0_3px_white]">Random</span>
                    </label>
                </div>

                <p class="mt-6 text-center text-xs text-gray-400">If not Talent Show, Talent Show will be placed before the finale.</p>
            </section>

            <div class="mt-6 grid grid-cols-2 gap-4">
                <button onclick="goBackFromOpenerPicker()" class="h-12 rounded-2xl border border-gray-200 bg-white text-gray-700 font-bold hover:bg-gray-50 transition flex items-center justify-center gap-2">
                    <span class="text-gray-500">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m15 18-6-6 6-6"/></svg>
                    </span>
                    <span>Back</span>
                </button>
                <button onclick="confirmOpenerAndContinue()" class="h-12 rounded-2xl bg-[#ec4899] text-white font-black shadow-lg hover:bg-[#db2777] transition flex items-center justify-center gap-3">
                    <span>CONTINUE</span>
                    <span class="text-white/90">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m9 18 6-6-6-6"/></svg>
                    </span>
                </button>
            </div>
        </div>

        <div id="doublePremierePanel" class="hidden mb-10">
            <div class="flex items-center justify-center gap-4 sm:gap-8 pb-6 pt-2">
                <div class="flex items-center gap-2">
                    <div class="flex h-7 w-7 items-center justify-center rounded-full bg-pink-100 text-xs font-black text-[#ec4899]">1</div>
                    <span class="hidden sm:inline text-xs font-bold text-gray-500">Season Opener</span>
                </div>
                <div class="h-px w-10 sm:w-14 bg-pink-200"></div>
                <div class="flex items-center gap-2">
                    <div class="flex h-7 w-7 items-center justify-center rounded-full bg-[#ec4899] text-xs font-black text-white">2</div>
                    <span class="hidden sm:inline text-xs font-bold text-gray-900">Double Premiere</span>
                </div>
                <div class="h-px w-10 sm:w-14 bg-gray-200"></div>
                
                <div id="doublePremiereStepTwists" class="hidden flex items-center gap-2">
                    <div id="doublePremiereStepTwistsNum" class="flex h-7 w-7 items-center justify-center rounded-full bg-gray-200 text-xs font-black text-gray-600">3</div>
                    <span class="hidden sm:inline text-xs font-bold text-gray-500">Twists</span>
                </div>
                <div id="doublePremiereStepSepTwists" class="hidden h-px w-10 sm:w-14 bg-gray-200"></div>

                <div class="flex items-center gap-2">
                    <div id="doublePremiereStepPersonalityNum" class="flex h-7 w-7 items-center justify-center rounded-full bg-gray-200 text-xs font-black text-gray-600">3</div>
                    <span class="hidden sm:inline text-xs font-bold text-gray-500">Personality</span>
                </div>
                <div class="h-px w-10 sm:w-14 bg-gray-200"></div>
                <div class="flex items-center gap-2">
                    <div id="doublePremiereStepRelationshipsNum" class="flex h-7 w-7 items-center justify-center rounded-full bg-gray-200 text-xs font-black text-gray-600">4</div>
                    <span class="hidden sm:inline text-xs font-bold text-gray-500">Relationships</span>
                </div>
            </div>

            <section class="bg-white rounded-2xl shadow-xl p-6 sm:p-10 border border-gray-200/60">
                <div class="flex flex-col items-center gap-2">
                    <h2 class="text-center text-2xl sm:text-3xl font-bold text-gray-900">Double Premiere</h2>
                    <p class="text-center text-sm text-gray-500 max-w-xl">Select queens who will compete in the first premiere episode. The rest will appear in Episode 2.</p>
                </div>

                <p id="doublePremiereCount" class="mt-4 text-[10px] font-bold text-gray-400 text-center"></p>

                <div class="mt-5 flex items-center justify-center gap-3">
                    <button type="button" onclick="randomDoublePremiereSelection()" class="h-10 rounded-xl border border-pink-200 bg-pink-50 px-4 text-xs font-bold text-[#ec4899] hover:bg-pink-100 transition inline-flex items-center gap-2">
                        <span class="text-[#ec4899]">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><path d="M16 8h.01"/><path d="M8 8h.01"/><path d="M8 16h.01"/><path d="M16 16h.01"/><path d="M12 12h.01"/></svg>
                        </span>
                        <span>Random All</span>
                    </button>
                </div>

                <div class="mt-6">
                    <div id="doublePremiereGrid" class="grid grid-cols-3 md:grid-cols-5 gap-2 p-3"></div>
                </div>
            </section>

            <div class="mt-6 grid grid-cols-2 gap-4">
                <button onclick="backFromDoublePremiere()" class="h-12 rounded-2xl border border-gray-200 bg-white text-gray-700 font-bold hover:bg-gray-50 transition flex items-center justify-center gap-2">
                    <span class="text-gray-500">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m15 18-6-6 6-6"/></svg>
                    </span>
                    <span>Back</span>
                </button>
                <button onclick="confirmDoublePremiereAndContinue()" class="h-12 rounded-2xl bg-[#ec4899] text-white font-black shadow-lg hover:bg-[#db2777] transition flex items-center justify-center gap-3">
                    <span>CONTINUE</span>
                    <span class="text-white/90">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m9 18 6-6-6-6"/></svg>
                    </span>
                </button>
            </div>
        </div>



        <div id="tournamentBracketPanel" class="hidden mb-10">

            <div class="flex items-center justify-center gap-4 sm:gap-8 pb-6 pt-2">
                <div class="flex items-center gap-2">
                    <div class="flex h-7 w-7 items-center justify-center rounded-full bg-[#ec4899] text-xs font-black text-white">1</div>
                    <span class="hidden sm:inline text-xs font-bold text-gray-900">Brackets</span>
                </div>
                <div id="tournamentBracketStepSep" class="h-px w-10 sm:w-14 bg-gray-200"></div>
                <div id="tournamentBracketStepPersonality" class="flex items-center gap-2">
                    <div class="flex h-7 w-7 items-center justify-center rounded-full bg-gray-200 text-xs font-black text-gray-600">2</div>
                    <span class="hidden sm:inline text-xs font-bold text-gray-500">Personality</span>
                </div>
                <div class="h-px w-10 sm:w-14 bg-gray-200"></div>
                <div id="tournamentBracketStepRelationships" class="flex items-center gap-2">
                    <div class="flex h-7 w-7 items-center justify-center rounded-full bg-gray-200 text-xs font-black text-gray-600">3</div>
                    <span class="hidden sm:inline text-xs font-bold text-gray-500">Relationships</span>
                </div>
            </div>

            <section class="bg-white rounded-2xl shadow-xl p-6 sm:p-10 border border-gray-200/60">
                <div class="flex flex-col items-center gap-2">
                    <h2 class="text-center text-2xl sm:text-3xl font-bold text-gray-900">Tournament Brackets</h2>
                    <p class="text-center text-sm text-gray-500 max-w-xl">Distribute 18 queens into Bracket 1/2/3 (6 each).</p>
                </div>

                <div class="mt-6 flex items-center justify-center gap-3">
                    <button onclick="clearTournamentBrackets()" class="h-10 rounded-xl border border-gray-200 bg-white px-4 text-xs font-bold text-gray-700 hover:bg-gray-50 transition inline-flex items-center gap-2">
                        <span class="text-gray-500">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
                        </span>
                        <span>Clear</span>
                    </button>
                     <button onclick="randomizeTournamentBrackets()" class="h-10 rounded-xl border border-pink-200 bg-pink-50 px-4 text-xs font-bold text-[#ec4899] hover:bg-pink-100 transition inline-flex items-center gap-2">
                        <span class="text-[#ec4899]">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><path d="M16 8h.01"/><path d="M8 8h.01"/><path d="M8 16h.01"/><path d="M16 16h.01"/><path d="M12 12h.01"/></svg>
                        </span>
                        <span>Random Brackets</span>
                    </button>
                </div>

                <div class="mt-6 grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div class="border border-gray-200 rounded-2xl p-4 bg-white shadow-sm">
                        <div class="flex items-center justify-between mb-3 border-b border-gray-100 pb-2">
                            <span class="text-xs font-black text-gray-400 uppercase tracking-wider">Queens</span>
                            <span id="tournamentBracketCounts" class="text-[10px] font-bold text-gray-400 bg-gray-100 px-2 py-0.5 rounded-full"></span>
                        </div>
                        <div id="tournamentBracketQueenList" class="max-h-[320px] overflow-y-auto space-y-2 pr-2"></div>
                    </div>
                    <div class="border border-gray-200 rounded-2xl p-4 bg-gray-50/50">
                        <div class="grid grid-cols-3 gap-2 text-center text-[10px] font-black text-gray-400 uppercase mb-3 tracking-wider">
                            <div>Bracket 1</div>
                            <div>Bracket 2</div>
                            <div>Bracket 3</div>
                        </div>
                        <div class="grid grid-cols-3 gap-2">
                            <div id="tournamentGroupA" class="space-y-2"></div>
                            <div id="tournamentGroupB" class="space-y-2"></div>
                            <div id="tournamentGroupC" class="space-y-2"></div>
                        </div>
                        
                        <div class="grid grid-cols-3 gap-2 mt-4 border-t border-gray-100 pt-3">
                            <div class="flex flex-col items-center gap-1">
                                <label class="text-[10px] font-bold text-gray-400 uppercase">Color</label>
                                <input type="color" id="bracketColorA" value="#6b7280" onchange="updateBracketColor('A', this.value)" class="h-8 w-full p-1 border border-gray-200 rounded cursor-pointer bg-white">
                            </div>
                            <div class="flex flex-col items-center gap-1">
                                <label class="text-[10px] font-bold text-gray-400 uppercase">Color</label>
                                <input type="color" id="bracketColorB" value="#6b7280" onchange="updateBracketColor('B', this.value)" class="h-8 w-full p-1 border border-gray-200 rounded cursor-pointer bg-white">
                            </div>
                            <div class="flex flex-col items-center gap-1">
                                <label class="text-[10px] font-bold text-gray-400 uppercase">Color</label>
                                <input type="color" id="bracketColorC" value="#6b7280" onchange="updateBracketColor('C', this.value)" class="h-8 w-full p-1 border border-gray-200 rounded cursor-pointer bg-white">
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <div class="mt-6 grid grid-cols-2 gap-4">
                <button onclick="goBackToCast()" class="h-12 rounded-2xl border border-gray-200 bg-white text-gray-700 font-bold hover:bg-gray-50 transition flex items-center justify-center gap-2">
                    <span class="text-gray-500">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m15 18-6-6 6-6"/></svg>
                    </span>
                    <span>Back</span>
                </button>
                <button onclick="confirmTournamentBracketsAndContinue()" id="tournamentBracketsContinueBtn"
                    class="h-12 rounded-2xl bg-[#ec4899] text-white font-black shadow-lg hover:bg-[#db2777] transition flex items-center justify-center gap-3 disabled:opacity-50 disabled:cursor-not-allowed">
                    <span>CONTINUE</span>
                    <span class="text-white/90">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m9 18 6-6-6-6"/></svg>
                    </span>
                </button>
            </div>
        </div>

        <div id="relationshipsPanel" class="hidden mb-10">
            <div class="flex items-center justify-center gap-4 sm:gap-8 pb-6 pt-2">
                <div id="relationshipsStepBrackets" class="hidden flex items-center gap-2">
                    <div id="relationshipsStepBracketsNum" class="flex h-7 w-7 items-center justify-center rounded-full bg-pink-100 text-xs font-black text-[#ec4899]">1</div>
                    <span class="hidden sm:inline text-xs font-bold text-gray-500">Brackets</span>
                </div>
                <div id="relationshipsStepSep2" class="hidden h-px w-10 sm:w-14 bg-pink-200"></div>

                <div id="relationshipsStepOpener" class="flex items-center gap-2">
                    <div class="flex h-7 w-7 items-center justify-center rounded-full bg-pink-100 text-xs font-black text-[#ec4899]">1</div>
                    <span class="hidden sm:inline text-xs font-bold text-gray-500">Season Opener</span>
                </div>
                <div id="relationshipsStepSep1" class="h-px w-10 sm:w-14 bg-pink-200"></div>
                <div id="relationshipsStepDouble" class="flex items-center gap-2">
                    <div class="flex h-7 w-7 items-center justify-center rounded-full bg-pink-100 text-xs font-black text-[#ec4899]">2</div>
                    <span class="hidden sm:inline text-xs font-bold text-gray-500">Double Premiere</span>
                </div>
                <div id="relationshipsStepSep3" class="h-px w-10 sm:w-14 bg-pink-200"></div>
                
                <div id="relationshipsStepTwists" class="hidden flex items-center gap-2">
                    <div id="relationshipsStepTwistsNum" class="flex h-7 w-7 items-center justify-center rounded-full bg-pink-100 text-xs font-black text-[#ec4899]">3</div>
                    <span class="hidden sm:inline text-xs font-bold text-gray-500">Twists</span>
                </div>
                <div id="relationshipsStepSepTwists" class="hidden h-px w-10 sm:w-14 bg-pink-200"></div>

                <div class="flex items-center gap-2">
                    <div id="relationshipsStepPersonalityNum" class="flex h-7 w-7 items-center justify-center rounded-full bg-pink-100 text-xs font-black text-[#ec4899]">2</div>
                    <span class="hidden sm:inline text-xs font-bold text-gray-500">Personality</span>
                </div>
                <div id="relationshipsStepSep4" class="h-px w-10 sm:w-14 bg-pink-200"></div>
                <div class="flex items-center gap-2">
                    <div id="relationshipsStepRelationshipsNum" class="flex h-7 w-7 items-center justify-center rounded-full bg-[#ec4899] text-xs font-black text-white">3</div>
                    <span class="hidden sm:inline text-xs font-bold text-gray-900">Relationships</span>
                </div>
            </div>

            <section class="bg-white rounded-2xl shadow-xl p-6 sm:p-10 border border-gray-200/60">
                <div class="flex flex-col items-center gap-2">
                    <h2 class="text-center text-2xl sm:text-3xl font-bold text-gray-900">Relationships</h2>
                    <p class="text-center text-sm text-gray-500 max-w-xl">Choose a queen below, then set her relationship with each other. These relationships may also play a role in the personalities of queens.</p>
                </div>

                <div class="mt-6 flex items-center justify-center gap-3">
                    <button type="button" onclick="setAllRelationships('neutral')" class="h-10 rounded-xl border border-gray-200 bg-white px-4 text-xs font-bold text-gray-700 hover:bg-gray-50 transition inline-flex items-center gap-2">
                        <span class="text-gray-500">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
                        </span>
                        <span>All Neutral</span>
                    </button>
                    <button type="button" onclick="randomAllRelationships()" class="h-10 rounded-xl border border-pink-200 bg-pink-50 px-4 text-xs font-bold text-[#ec4899] hover:bg-pink-100 transition inline-flex items-center gap-2">
                        <span class="text-[#ec4899]">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><path d="M16 8h.01"/><path d="M8 8h.01"/><path d="M8 16h.01"/><path d="M16 16h.01"/><path d="M12 12h.01"/></svg>
                        </span>
                        <span>Random All</span>
                    </button>
                </div>

                <div class="mt-6">
                    <div class="text-[10px] font-black text-gray-400 uppercase text-center">Current Queen</div>
                    <div class="mt-3 flex items-center justify-center gap-3">
                        <button type="button" onclick="prevRelationshipsQueen()" class="h-10 w-10 rounded-xl border border-gray-200 bg-white text-gray-700 font-black hover:bg-gray-50 transition inline-flex items-center justify-center">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m15 18-6-6 6-6"/></svg>
                        </button>

                        <div class="relative">
                            <div class="h-11 rounded-2xl border border-gray-200 bg-white shadow-sm px-4 flex items-center gap-3">
                                <img id="relationshipsQueenSelectPhoto" src="" alt="" class="w-7 h-7 rounded-full object-cover border border-white shadow">
                                <select id="relationshipsQueenSelect" onchange="switchRelationshipsQueen(selectedQueens[parseInt(this.value,10)])" class="appearance-none bg-transparent text-sm font-black text-gray-900 focus:outline-none pr-8 w-44 sm:w-56">
                                </select>
                                <span class="pointer-events-none absolute right-4 top-1/2 -translate-y-1/2 text-gray-400 text-xs">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m6 9 6 6 6-6"/></svg>
                                </span>
                            </div>
                        </div>

                        <button type="button" onclick="nextRelationshipsQueen()" class="h-10 w-10 rounded-xl border border-gray-200 bg-white text-gray-700 font-black hover:bg-gray-50 transition inline-flex items-center justify-center">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m9 18 6-6-6-6"/></svg>
                        </button>
                    </div>
                </div>

                <div id="relationshipsCurrentQueenCard" class="mt-6 flex flex-col items-center p-5 bg-pink-50/60 rounded-2xl border border-pink-100">

                    <img id="relationshipsQueenPhoto" src="" alt="" class="w-20 h-20 rounded-full object-cover border-4 border-white shadow-lg mb-2">
                    <span id="relationshipsQueenName" class="text-sm font-black text-gray-800"></span>
                    <span class="text-[10px] text-gray-500 mt-0.5">— with everyone below —</span>
                </div>

                <div class="mt-6 rounded-2xl border border-gray-200/70 bg-gray-50/40 overflow-hidden">
                    <div id="relationshipsGrid" class="max-h-[320px] overflow-y-auto"></div>
                </div>
            </section>

            <div class="mt-6 grid grid-cols-2 gap-4">
                <button onclick="backFromRelationshipsPanel()" class="h-12 rounded-2xl border border-gray-200 bg-white text-gray-700 font-bold hover:bg-gray-50 transition flex items-center justify-center gap-2">
                    <span class="text-gray-500">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m15 18-6-6 6-6"/></svg>
                    </span>
                    <span>Back</span>
                </button>
                <button onclick="generateSeasonWithRelationships()" id="genWithRelBtn" class="h-12 rounded-2xl bg-[#ec4899] text-white font-black shadow-lg hover:bg-[#db2777] transition flex items-center justify-center gap-3">
                    <span>CONTINUE</span>
                    <span class="text-white/90">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m9 18 6-6-6-6"/></svg>
                    </span>
                </button>
            </div>
        </div>


        <div id="luckyQueenPanel" class="hidden mb-10">
            <div class="flex items-center justify-center gap-4 sm:gap-8 pb-6 pt-2">
                <div class="flex items-center gap-2">
                    <div class="flex h-7 w-7 items-center justify-center rounded-full bg-pink-100 text-xs font-black text-[#ec4899]">1</div>
                    <span class="hidden sm:inline text-xs font-bold text-gray-500">Season Opener</span>
                </div>
                <div class="h-px w-10 sm:w-14 bg-pink-200"></div>

                <div id="luckyQueenStepDouble" class="hidden flex items-center gap-2">
                    <div class="flex h-7 w-7 items-center justify-center rounded-full bg-pink-100 text-xs font-black text-[#ec4899]">2</div>
                    <span class="hidden sm:inline text-xs font-bold text-gray-500">Double Premiere</span>
                </div>
                <div id="luckyQueenStepSepDouble" class="hidden h-px w-10 sm:w-14 bg-pink-200"></div>

                <div class="flex items-center gap-2">
                    <div id="luckyQueenStepNum" class="flex h-7 w-7 items-center justify-center rounded-full bg-[#ec4899] text-xs font-black text-white">3</div>
                    <span class="hidden sm:inline text-xs font-bold text-gray-900">Twists</span>
                </div>
                <div class="h-px w-10 sm:w-14 bg-gray-200"></div>
                <div class="flex items-center gap-2">
                    <div id="luckyQueenStepPersonalityNum" class="flex h-7 w-7 items-center justify-center rounded-full bg-gray-200 text-xs font-black text-gray-600">3</div>
                    <span class="hidden sm:inline text-xs font-bold text-gray-500">Personality</span>
                </div>
                <div class="h-px w-10 sm:w-14 bg-gray-200"></div>
                <div class="flex items-center gap-2">
                    <div id="luckyQueenStepRelationshipsNum" class="flex h-7 w-7 items-center justify-center rounded-full bg-gray-200 text-xs font-black text-gray-600">4</div>
                    <span class="hidden sm:inline text-xs font-bold text-gray-500">Relationships</span>
                </div>
            </div>

            <section class="bg-white rounded-2xl shadow-xl p-6 sm:p-10 border border-gray-200/60">
                <div class="flex flex-col items-center gap-2">
                    <h2 class="text-center text-2xl sm:text-3xl font-bold text-gray-900">Choose Lucky Queen</h2>
                    <p class="text-center text-sm text-gray-500 max-w-xl">Select one queen to be the "Lucky Queen" (El Roscón de Reinas). She will receive a special advantage.</p>
                </div>

                <div class="mt-6 flex items-center justify-center gap-3">
                    <button type="button" onclick="setRandomLuckyQueen()" class="h-10 rounded-xl border border-pink-200 bg-pink-50 px-4 text-xs font-bold text-[#ec4899] hover:bg-pink-100 transition inline-flex items-center gap-2">
                        <span class="text-[#ec4899]">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><path d="M16 8h.01"/><path d="M8 8h.01"/><path d="M8 16h.01"/><path d="M16 16h.01"/><path d="M12 12h.01"/></svg>
                        </span>
                        <span>Random</span>
                    </button>
                </div>

                <div class="mt-6">
                    <div id="luckyQueenGrid" class="grid grid-cols-3 md:grid-cols-5 gap-2 p-3"></div>
                </div>
            </section>

            <div class="mt-6 grid grid-cols-2 gap-4">
                <button onclick="backFromLuckyQueenPanel()" class="h-12 rounded-2xl border border-gray-200 bg-white text-gray-700 font-bold hover:bg-gray-50 transition flex items-center justify-center gap-2">
                    <span class="text-gray-500">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m15 18-6-6 6-6"/></svg>
                    </span>
                    <span>Back</span>
                </button>
                <button onclick="confirmLuckyQueenAndContinue()" class="h-12 rounded-2xl bg-[#ec4899] text-white font-black shadow-lg hover:bg-[#db2777] transition flex items-center justify-center gap-3">
                    <span>CONTINUE</span>
                    <span class="text-white/90">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m9 18 6-6-6-6"/></svg>
                    </span>
                </button>
            </div>
        </div>

        <div id="personalityPanel" class="hidden mb-10">
            <div class="flex items-center justify-center gap-4 sm:gap-8 pb-6 pt-2">
                <div id="personalityStepBrackets" class="hidden flex items-center gap-2">
                    <div id="personalityStepBracketsNum" class="flex h-7 w-7 items-center justify-center rounded-full bg-pink-100 text-xs font-black text-[#ec4899]">1</div>
                    <span class="hidden sm:inline text-xs font-bold text-gray-500">Brackets</span>
                </div>
                <div id="personalityStepSep2" class="hidden h-px w-10 sm:w-14 bg-pink-200"></div>

                <div id="personalityStepOpener" class="flex items-center gap-2">
                    <div id="personalityStepOpenerNum" class="flex h-7 w-7 items-center justify-center rounded-full bg-pink-100 text-xs font-black text-[#ec4899]">1</div>
                    <span class="hidden sm:inline text-xs font-bold text-gray-500">Season Opener</span>
                </div>
                <div id="personalityStepSep1" class="h-px w-10 sm:w-14 bg-pink-200"></div>
                <div id="personalityStepDouble" class="flex items-center gap-2">
                    <div class="flex h-7 w-7 items-center justify-center rounded-full bg-pink-100 text-xs font-black text-[#ec4899]">2</div>
                    <span class="hidden sm:inline text-xs font-bold text-gray-500">Double Premiere</span>
                </div>
                <div id="personalityStepSep3" class="h-px w-10 sm:w-14 bg-pink-200"></div>

                <div id="personalityStepTwists" class="hidden flex items-center gap-2">
                    <div id="personalityStepTwistsNum" class="flex h-7 w-7 items-center justify-center rounded-full bg-pink-100 text-xs font-black text-[#ec4899]">3</div>
                    <span class="hidden sm:inline text-xs font-bold text-gray-500">Twists</span>
                </div>
                <div id="personalityStepSepTwists" class="hidden h-px w-10 sm:w-14 bg-pink-200"></div>

                <div class="flex items-center gap-2">
                    <div id="personalityStepPersonalityNum" class="flex h-7 w-7 items-center justify-center rounded-full bg-[#ec4899] text-xs font-black text-white">2</div>
                    <span class="hidden sm:inline text-xs font-bold text-gray-900">Personality</span>
                </div>
                <div id="personalityStepSep4" class="h-px w-10 sm:w-14 bg-pink-200"></div>
                <div class="flex items-center gap-2">
                    <div id="personalityStepRelationshipsNum" class="flex h-7 w-7 items-center justify-center rounded-full bg-gray-200 text-xs font-black text-gray-600">3</div>
                    <span class="hidden sm:inline text-xs font-bold text-gray-500">Relationships</span>
                </div>
            </div>

            <section class="bg-white rounded-2xl shadow-xl p-6 sm:p-10 border border-gray-200/60">
                <div class="flex flex-col items-center gap-2">
                    <h2 class="text-center text-2xl sm:text-3xl font-bold text-gray-900">Queen Personality</h2>
                    <p class="text-center text-sm text-gray-500 max-w-xl">
                        Set one dominant personality trait for each queen:<br>
                        <b>📈 Fair</b>: Judges based on stats.<br>
                        <b>🧠 Strategy</b>: Eliminates strong competition.<br>
                        <b>💖 Loyal</b>: Protects friends.<br>
                        <b>🎭 Chaos</b>: Makes unpredictable choices.
                    </p>
                </div>

                <div class="mt-6 flex items-center justify-center gap-3">
                    <button type="button" onclick="resetAllPersonalities()" class="h-10 rounded-xl border border-gray-200 bg-white px-4 text-xs font-bold text-gray-700 hover:bg-gray-50 transition inline-flex items-center gap-2">
                        <span class="text-gray-500">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
                        </span>
                        <span>Reset All</span>
                    </button>
                    <button type="button" onclick="randomAllPersonalities()" class="h-10 rounded-xl border border-pink-200 bg-pink-50 px-4 text-xs font-bold text-[#ec4899] hover:bg-pink-100 transition inline-flex items-center gap-2">
                        <span class="text-[#ec4899]">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><path d="M16 8h.01"/><path d="M8 8h.01"/><path d="M8 16h.01"/><path d="M16 16h.01"/><path d="M12 12h.01"/></svg>
                        </span>
                        <span>Random All</span>
                    </button>
                </div>

                <div class="mt-6 rounded-2xl border border-gray-200/70 bg-gray-50/40 overflow-hidden">
                    <div id="personalityGrid" class="max-h-[420px] md:max-h-[520px] overflow-y-auto"></div>
                </div>
            </section>

            <div class="mt-6 grid grid-cols-2 gap-4">
                <button onclick="backFromPersonalityPanel()" class="h-12 rounded-2xl border border-gray-200 bg-white text-gray-700 font-bold hover:bg-gray-50 transition flex items-center justify-center gap-2">
                    <span class="text-gray-500">‹</span>
                    <span>Back</span>
                </button>
                <button onclick="openRelationshipsPanel()" id="genWithPersonalityBtn" class="h-12 rounded-2xl bg-[#ec4899] text-white font-black shadow-lg hover:bg-[#db2777] transition flex items-center justify-center gap-3">
                    <span>CONTINUE</span>
                    <span class="text-white/90">›</span>
                </button>
            </div>
        </div>

        <div id="scenarioScreen" class="hidden">
            <div class="overflow-visible">
                <div class="bg-gray-50/60 px-0 pt-3 pb-6">
                    <div class="w-full bg-white rounded-3xl border border-gray-200/60 shadow-xl min-h-[440px] flex flex-col overflow-hidden">
                        <div id="stageContent" class="flex-grow p-6 sm:p-10 flex flex-col items-center justify-center text-center"></div>
                        <div class="border-t border-gray-200/60 px-6 sm:px-10 py-6 flex items-center justify-center">
                            <button onclick="advanceScenario()" id="nextBtn" class="h-10 px-10 rounded-full bg-[#ec4899] text-white text-xs font-black uppercase shadow-lg hover:bg-[#db2777] transition inline-flex items-center justify-center">
                                Next
                            </button>
                        </div>
                    </div>
                </div>

                <div class="px-0 pb-2 flex items-center justify-between gap-3">
                    <button type="button" id="prevEpBtn" onclick="goPrevEpisode()" class="h-9 px-4 rounded-full border border-gray-200 bg-white/70 text-[11px] font-bold text-gray-700 hover:bg-white transition inline-flex items-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed">
                        <span class="text-gray-500">‹</span>
                        <span>Previous Ep</span>
                    </button>
                    <div id="episodeNavLabel" class="text-[11px] font-semibold text-gray-400">Episode 1 / 1</div>
                    <button type="button" id="nextEpBtn" onclick="goNextEpisode()" class="h-9 px-4 rounded-full border border-gray-200 bg-white/70 text-[11px] font-bold text-gray-700 hover:bg-white transition inline-flex items-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed">
                        <span>Next Ep</span>
                        <span class="text-gray-500">›</span>
                    </button>
                </div>
                <div class="hidden" id="debugInfo">Phase: Intro</div>
            </div>

            <div id="trackRecordPlaceholder"></div>
            <div id="trackRecordContainer" class="mt-6 hidden w-full bg-transparent p-0">
                <div class="overflow-x-auto">
                    <div class="track-record-table-wrapper">
                        <table class="track-record-table" id="trackRecordTable"></table>
                    </div>
                </div>
                <div class="flex items-center justify-center mt-4 mb-2">
                    <button type="button" id="downloadTrackRecordBtn" class="h-8 px-4 rounded-lg border border-gray-200 bg-gray-100 text-xs font-bold text-gray-700 hover:bg-gray-200 shadow-sm transition flex items-center justify-center">Download as image</button>
                </div>
                <div id="lipstickTableContainer" class="mt-4 hidden">
                    <h3 class="text-sm font-bold text-gray-500 uppercase mb-2">Lipstick Choices</h3>
                    <div class="overflow-x-auto">
                        <table class="custom-table" id="lipstickTable"></table>
                    </div>
                </div>
            </div>
        </div>
    <div id="toast-container" class="fixed bottom-5 right-5 z-50 flex flex-col gap-2 pointer-events-none"></div>
    </main>

    <script src="lip-sync-songs.js"></script>
    <script src="queens.js"></script>
    <script>

    const queensDb = window.queensDb;
    const queenNames = Object.keys(queensDb).sort();

    function createQueenCardHtml({
        domKey,
        queenName,
        photoUrl,
        score,
        baseClasses = "border-gray-200 bg-gray-50",
        widthClass = "w-44 sm:w-56",
        cardId = "",
        imgId = "",
        scoreId = "",
        badgeId = "",
        scoreData = null,
        additionalContent = ""
    }) {
        return `
            <div ${cardId ? `id="${cardId}"` : ''} class="flex flex-col items-center gap-2 rounded-2xl border ${baseClasses} p-5 ${widthClass} min-w-0 transition">
                <img ${imgId ? `id="${imgId}"` : ''} src="${photoUrl}" class="queen-img-lg" alt="">
                <span class="w-full truncate text-center text-sm font-bold text-gray-900 sm:text-base">${queenName}</span>
                <span ${scoreId ? `id="${scoreId}"` : ''} ${scoreData !== null ? `data-score="${scoreData}"` : ''} class="text-xs text-gray-500">Score: ${score}</span>
                ${additionalContent}
                <span ${badgeId ? `id="${badgeId}"` : ''} class="hidden mt-2 rounded-full px-3 py-1 text-xs font-bold max-w-full text-center leading-tight whitespace-normal"></span>
            </div>
        `;
    }

    let selectedQueens = [];
    let browseQueensOpen = false;
    let doublePremiereEp1Cast = [];
    let doublePremiereEp2Cast = [];
    let premiereType = 'normal';
    let returnFormat = 'none';
    let luckyQueenTwist = false;
    let selectedLuckyQueen = null;
    const MAX_CAST = 18;

    const GAME_CONSTANTS = {
        POINTS: {
            WIN: 5,
            TOP2: 4.5,
            HIGH: 4,
            SAFE: 3,
            LOW: 2,
            BTM: 1,
            ELIM: 0,
            QUIT: 0,
            DISQ: 0,
            RETURN: 0,
            TOURNAMENT_WIN_ELIM: 2.5, 
            TOURNAMENT_TOP2_ELIM: 2.25, 
            ALLSTARS_LIPSYNC_LOSER: 4.5,
            DOUBLE_PREMIERE_TOP2: 4.5
        },
        THRESHOLDS: {
            DOUBLE_SHANTAY_CHANCE: 0.65,
            DOUBLE_SASHAY_CHANCE: 0.15,
            HIGH_SCORE: 16 
        }
    };

    window._tournamentBracketState = window._tournamentBracketState || { 
        assignment: {}, 
        colors: { A: '#6b7280', B: '#6b7280', C: '#6b7280' } 
    };

    function showToast(message, type = 'info') {
        const container = document.getElementById('toast-container');
        if (!container) return alert(message); 

        const toast = document.createElement('div');
        toast.className = `px-6 py-3 rounded-xl shadow-xl text-white font-bold text-sm transform transition-all duration-300 translate-y-10 opacity-0 pointer-events-auto flex items-center gap-3 ${
            type === 'error' ? 'bg-red-500' : 
            type === 'success' ? 'bg-green-500' : 'bg-gray-800'
        }`;
        
        toast.innerHTML = `
            <span>${type === 'error' ? '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/><path d="M12 9v4"/><path d="M12 17h.01"/></svg>' : type === 'success' ? '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><path d="M22 4 12 14.01l-3-3"/></svg>' : '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg>'}</span>
            <span>${message}</span>
        `;

        container.appendChild(toast);

        requestAnimationFrame(() => {
            toast.classList.remove('translate-y-10', 'opacity-0');
        });

        setTimeout(() => {
            toast.classList.add('opacity-0', 'translate-y-2');
            setTimeout(() => toast.remove(), 300);
        }, 3000);
    }

    const RELATIONSHIP_TYPES = [
        { id: 'drag_family', label: 'Drag Family (Unbreakable)' },
        { id: 'great', label: 'Great' },
        { id: 'good', label: 'Good' },
        { id: 'neutral', label: 'Neutral' },
        { id: 'bad', label: 'Bad' },
        { id: 'chop', label: 'Chop' }
    ];
    const DEFAULT_RELATIONSHIP = 'neutral';
    const PERSONALITY_TYPES = [
        { id: 'fair', label: 'Fair' },
        { id: 'strategy', label: 'Strategy' },
        { id: 'loyal', label: 'Loyal' },
        { id: 'chaos', label: 'Chaos' }
    ];
    const DEFAULT_PERSONALITY = 'fair';

    function getRelationshipKey(a, b) { return [a, b].sort().join('|'); }

    function getSelectedSeasonMode() {
        const sel = document.getElementById('seasonModeSelect');
        if (sel && sel.value) return sel.value;
        return document.querySelector('input[name="seasonMode"]:checked')?.value || 'regular';
    }

    function getSelectedFinaleType() {
        const sel = document.getElementById('finaleTypeSelect');
        if (sel && sel.value) return sel.value;
        return document.querySelector('input[name="finaleType"]:checked')?.value || '3';
    }

    function setPremiereType(value) {
        premiereType = value;
        const sel = document.getElementById('premiereTypeSelect');
        if (sel) sel.value = value;
        const radio = document.querySelector(`input[name="premiereType"][value="${value}"]`);
        if (radio) radio.checked = true;
        updatePreSimStepIndicators();
        updateStartButtonState();
    }

    function isDoublePremiereType(value) {
        return value === 'double' || value === 'double_elim';
    }

    function getSelectedReturnFormat() {
        const sel = document.getElementById('returnFormatSelect');
        if (sel && sel.value) return sel.value;
        return returnFormat || 'none';
    }

    function setReturnFormat(value) {
        returnFormat = value || 'none';
        const sel = document.getElementById('returnFormatSelect');
        if (sel) sel.value = returnFormat;
        updateReturnFormatAvailability();
    }

    function updateReturnFormatAvailability() {
        const sel = document.getElementById('returnFormatSelect');
        if (!sel) return;
        const seasonMode = getSelectedSeasonMode();
        const eligibleMode = seasonMode === 'regular' || seasonMode === 'beaver' || seasonMode === 'allstars';
        const eligible = eligibleMode && selectedQueens.length >= 6;
        const chooseOption = sel.querySelector('option[value="choose"]');
        if (chooseOption) chooseOption.disabled = !eligible;
        if (!eligible && returnFormat === 'choose') {
            returnFormat = 'none';
        }
        if (!eligibleMode || seasonMode === 'tournament') {
            returnFormat = 'none';
            sel.disabled = true;
        } else {
            sel.disabled = false;
        }
        sel.value = returnFormat;
    }

    function getReturnEpisodeForCast(castSize, finaleLimit = 3, premiereType = 'normal') {
        let range = [];
        const offset = (premiereType === 'double' || premiereType === 'split') ? 2 : 0;


        if (finaleLimit === 4) {
             if (castSize <= 6) range = [2]; 
             else if (castSize <= 8) range = [3, 4];
             else if (castSize <= 12) range = [5, 6];
             else if (castSize <= 16) range = [6, 7, 8];
             else range = [7, 8, 9];
        } 
        else {
             if (castSize <= 6) range = [3];
             else if (castSize <= 8) range = [4, 5];
             else if (castSize <= 12) range = [6, 7];
             else if (castSize <= 16) range = [7, 8, 9];
             else range = [8, 9, 10];
        }

        range = range.map(ep => ep + offset);

        const maxEp = (castSize - finaleLimit) + offset;

        range = range.filter(ep => ep <= maxEp);

        if (range.length === 0 && maxEp >= (2 + offset)) {
            return maxEp;
        }

        if (!range || range.length === 0) return null;
        return range[Math.floor(Math.random() * range.length)];
    }

    function updatePreSimStepIndicators() {
        const checkbox = document.getElementById('luckyQueenTwist');
        if (checkbox) {
            luckyQueenTwist = checkbox.checked;
        }
        const isDouble = isDoublePremiereType(premiereType);
        const hasTwist = luckyQueenTwist; 

        const configs = [
            {
                // Opener Picker Panel
                doubleId: 'openerStepDouble',
                sepId: 'openerStepSep1',
                twistId: 'openerStepTwists',
                twistSepId: 'openerStepSepTwists',
                twistNumId: 'openerStepTwistsNum',
                personalityNumId: 'openerStepPersonalityNum',
                relationshipsNumId: 'openerStepRelationshipsNum'
            },
            {
                // Double Premiere Panel
                doubleId: null, // Always visible if in this panel
                sepId: null,
                twistId: 'doublePremiereStepTwists',
                twistSepId: 'doublePremiereStepSepTwists',
                twistNumId: 'doublePremiereStepTwistsNum',
                personalityNumId: 'doublePremiereStepPersonalityNum',
                relationshipsNumId: 'doublePremiereStepRelationshipsNum'
            },
            {
                // Lucky Queen (Twists) Panel
                doubleId: 'luckyQueenStepDouble',
                sepId: 'luckyQueenStepSepDouble', 
                twistId: null, // Always visible if in this panel
                twistSepId: null,
                twistNumId: 'luckyQueenStepNum',
                personalityNumId: 'luckyQueenStepPersonalityNum',
                relationshipsNumId: 'luckyQueenStepRelationshipsNum'
            },
            {
                // Personality Panel
                doubleId: 'personalityStepDouble',
                sepId: 'personalityStepSep1',
                twistId: 'personalityStepTwists',
                twistSepId: 'personalityStepSepTwists',
                twistNumId: 'personalityStepTwistsNum',
                personalityNumId: 'personalityStepPersonalityNum',
                relationshipsNumId: 'personalityStepRelationshipsNum'
            },
            {
                // Relationships Panel
                doubleId: 'relationshipsStepDouble',
                sepId: 'relationshipsStepSep1',
                twistId: 'relationshipsStepTwists',
                twistSepId: 'relationshipsStepSepTwists',
                twistNumId: 'relationshipsStepTwistsNum',
                personalityNumId: 'relationshipsStepPersonalityNum',
                relationshipsNumId: 'relationshipsStepRelationshipsNum'
            }
        ];

        configs.forEach((cfg) => {
            // Handle Double Premiere Visibility
            if (cfg.doubleId) {
                const doubleEl = document.getElementById(cfg.doubleId);
                const sepEl = document.getElementById(cfg.sepId);
                if (doubleEl) doubleEl.classList.toggle('hidden', !isDouble);
                if (sepEl) sepEl.classList.toggle('hidden', !isDouble);
            }

            // Handle Twists Visibility
            if (cfg.twistId) {
                const twistEl = document.getElementById(cfg.twistId);
                const twistSepEl = document.getElementById(cfg.twistSepId);
                if (twistEl) twistEl.classList.toggle('hidden', !hasTwist);
                if (twistSepEl) twistSepEl.classList.toggle('hidden', !hasTwist);
            }

            // Calculate Step Numbers
            let currentStep = 1; // Opener is 1
            
            if (isDouble) {
                currentStep++; // Double is 2
            }
            
            if (hasTwist) {
                currentStep++;
                if (cfg.twistNumId) {
                    const el = document.getElementById(cfg.twistNumId);
                    if (el) el.innerText = currentStep;
                }
            }

            currentStep++;
            if (cfg.personalityNumId) {
                const el = document.getElementById(cfg.personalityNumId);
                if (el) el.innerText = currentStep;
            }

            currentStep++;
            if (cfg.relationshipsNumId) {
                const el = document.getElementById(cfg.relationshipsNumId);
                if (el) el.innerText = currentStep;
            }
        });
    }

    function updateStartButtonState() {
        const btn = document.getElementById('generateBtn');
        if (!btn) return;
        const hint = document.getElementById('startSeasonHint');

        const seasonMode = getSelectedSeasonMode();
        let min = 4;
        if (seasonMode === 'tournament') min = 18;
        else if (isDoublePremiereType(premiereType)) min = 10;
        else if (seasonMode === 'allstars') min = 6;

        if (hint) {
            hint.textContent = seasonMode === 'tournament'
                ? `Select exactly ${MAX_CAST} queens to start`
                : `Select at least ${min} queens to start`;
        }

        if (seasonMode === 'tournament') {
            btn.disabled = selectedQueens.length !== MAX_CAST;
            updateReturnFormatAvailability();
            return;
        }
        btn.disabled = selectedQueens.length < min || selectedQueens.length > MAX_CAST;
        updateReturnFormatAvailability();
    }

    function onStartSeasonClick() {
        const seasonMode = getSelectedSeasonMode();

        // Force disable Lucky Queen if not in regular or beaver mode
        const isSupported = (seasonMode === 'regular' || seasonMode === 'beaver');
        if (!isSupported) {
            luckyQueenTwist = false;
            const lqCheckbox = document.getElementById('luckyQueenTwist');
            if (lqCheckbox) lqCheckbox.checked = false;
        }

        if (selectedQueens.length > MAX_CAST) {
            showToast(`Max cast size is ${MAX_CAST} queens.`, 'error');
            return;
        }
        if (seasonMode === 'tournament' && selectedQueens.length !== MAX_CAST) {
            showToast(`Tournament requires exactly ${MAX_CAST} queens.`, 'error');
            return;
        }
        document.getElementById('setupPanel').classList.add('hidden');
        if (seasonMode === 'tournament') {
            openTournamentBracketPanel();
            return;
        }
        
    const ggRadio = document.querySelector('input[name="seasonOpener"][value="Girl Groups"]');
        if (ggRadio) {
            const label = ggRadio.closest('label');
            if (isDoublePremiereType(premiereType)) {
                if (label) label.classList.add('hidden');
                if (ggRadio.checked) {
                    const randomRadio = document.querySelector('input[name="seasonOpener"][value="Random"]');
                    if (randomRadio) randomRadio.checked = true;
                }
            } else {
                if (label) label.classList.remove('hidden');
            }
        }

        const panel = document.getElementById('openerPickerPanel');
        panel.classList.remove('hidden');
        panel.style.display = '';
    }

    function goBackFromOpenerPicker() {
        document.getElementById('openerPickerPanel').classList.add('hidden');
        document.getElementById('setupPanel').classList.remove('hidden');
    }

    function confirmOpenerAndContinue() {
        const seasonMode = getSelectedSeasonMode();
        if (selectedQueens.length > MAX_CAST) {
            showToast(`Max cast size is ${MAX_CAST} queens.`, 'error');
            return;
        }
        if (seasonMode === 'tournament' && selectedQueens.length !== MAX_CAST) {
            showToast(`Tournament requires exactly ${MAX_CAST} queens.`, 'error');
            return;
        }
        document.getElementById('openerPickerPanel').classList.add('hidden');
        if (seasonMode === 'tournament') {
            openTournamentBracketPanel();
            return;
        }
        if (seasonMode !== 'tournament' && isDoublePremiereType(premiereType)) {
            document.getElementById('doublePremierePanel').classList.remove('hidden');
            openDoublePremierePanel();
            return;
        }

        const isSupported = (seasonMode === 'regular' || seasonMode === 'beaver');
        const isLuckyQueen = document.getElementById('luckyQueenTwist') ? document.getElementById('luckyQueenTwist').checked : false;
        
        if (isSupported && isLuckyQueen) {
            openLuckyQueenPanel();
            return;
        }
        
        const minForRelationships = (seasonMode === 'allstars' || seasonMode === 'tournament') ? 6 : 4;
        if (selectedQueens.length >= minForRelationships) {
            openPersonalityPanel();
        } else {
            generateSeason();
        }
    }

    function ensureRelationshipsState() {
        if (!window._relationshipsState) window._relationshipsState = {};
        for (let i = 0; i < selectedQueens.length; i++) {
            for (let j = i + 1; j < selectedQueens.length; j++) {
                const key = getRelationshipKey(selectedQueens[i], selectedQueens[j]);
                if (window._relationshipsState[key] === undefined) window._relationshipsState[key] = DEFAULT_RELATIONSHIP;
            }
        }
    }

    function renderRelationshipsGrid() {
        ensureRelationshipsState();
        const currentQueen = window._relationshipsCurrentQueen || selectedQueens[0];
        if (!selectedQueens.includes(currentQueen)) window._relationshipsCurrentQueen = selectedQueens[0];

        const selectEl = document.getElementById('relationshipsQueenSelect');
        const selectPhotoEl = document.getElementById('relationshipsQueenSelectPhoto');
        const photoEl = document.getElementById('relationshipsQueenPhoto');
        const nameEl = document.getElementById('relationshipsQueenName');
        if (selectEl) {
            selectEl.innerHTML = selectedQueens.map((q, idx) => `
                <option value="${idx}" ${q === currentQueen ? 'selected' : ''}>${q}</option>
            `).join('');
        }
        if (selectPhotoEl && queensDb[currentQueen]) selectPhotoEl.src = queensDb[currentQueen].photo;
        if (photoEl && queensDb[currentQueen]) photoEl.src = queensDb[currentQueen].photo;
        if (nameEl) nameEl.textContent = currentQueen;

        const grid = document.getElementById('relationshipsGrid');
        const others = selectedQueens.filter(q => q !== currentQueen);
        grid.innerHTML = others.map((other, idx) => {
            const key = getRelationshipKey(currentQueen, other);
            const keyAttr = key.replace(/"/g, '&quot;');
            const current = window._relationshipsState[key] || DEFAULT_RELATIONSHIP;
            const photo = queensDb[other] ? queensDb[other].photo : '';
            return `
                <div class="flex items-center justify-between gap-3 px-4 py-3 border-b border-gray-200/60 bg-white">
                    <div class="flex items-center gap-3 min-w-0 flex-1">
                        <img src="${photo}" alt="" class="w-10 h-10 rounded-full object-cover border-2 border-white shadow flex-shrink-0">
                        <span class="text-sm font-bold text-gray-800 truncate">${other}</span>
                    </div>
                    <select data-rel-key="${keyAttr}" class="relationship-select h-9 sm:h-10 rounded-xl border border-gray-200 bg-white px-2 sm:px-3 text-[11px] sm:text-xs font-bold text-gray-700 w-[132px] sm:w-auto sm:min-w-[180px] overflow-hidden text-ellipsis whitespace-nowrap focus:border-[#ec4899] focus:ring-1 focus:ring-pink-200" onchange="updateRelationshipState(this.getAttribute('data-rel-key'), this.value)">
                        ${RELATIONSHIP_TYPES.map(r => `<option value="${r.id}" ${r.id === current ? 'selected' : ''}>${r.label}</option>`).join('')}
                    </select>
                </div>`;
        }).join('');
    }

    function switchRelationshipsQueen(queenName) {
        window._relationshipsCurrentQueen = queenName;
        renderRelationshipsGrid();
    }

    function prevRelationshipsQueen() {
        if (!selectedQueens.length) return;
        const currentQueen = window._relationshipsCurrentQueen || selectedQueens[0];
        const idx = selectedQueens.indexOf(currentQueen);
        const nextIdx = idx <= 0 ? selectedQueens.length - 1 : idx - 1;
        switchRelationshipsQueen(selectedQueens[nextIdx]);
    }

    function nextRelationshipsQueen() {
        if (!selectedQueens.length) return;
        const currentQueen = window._relationshipsCurrentQueen || selectedQueens[0];
        const idx = selectedQueens.indexOf(currentQueen);
        const nextIdx = idx === -1 || idx >= selectedQueens.length - 1 ? 0 : idx + 1;
        switchRelationshipsQueen(selectedQueens[nextIdx]);
    }

    function updateRelationshipState(key, value) { if (window._relationshipsState) window._relationshipsState[key] = value; }

    function setAllRelationships(value) {
        if (!window._relationshipsState) return;
        Object.keys(window._relationshipsState).forEach(k => { window._relationshipsState[k] = value; });
        document.querySelectorAll('.relationship-select').forEach(s => { s.value = value; });
    }

    function randomAllRelationships() {
        ensureRelationshipsState();
        const ids = RELATIONSHIP_TYPES.map(r => r.id);
        Object.keys(window._relationshipsState).forEach(k => {
            window._relationshipsState[k] = ids[Math.floor(Math.random() * ids.length)];
        });
        renderRelationshipsGrid();
    }

    function goBackToCast() {
        const bracketPanel = document.getElementById('tournamentBracketPanel');
        if (bracketPanel) bracketPanel.classList.add('hidden');
        const dp = document.getElementById('doublePremierePanel');
        if (dp) dp.classList.add('hidden');
        const pp = document.getElementById('personalityPanel');
        if (pp) pp.classList.add('hidden');
        document.getElementById('relationshipsPanel').classList.add('hidden');
        document.getElementById('setupPanel').classList.remove('hidden');
    }

    function backFromRelationshipsPanel() {
        openPersonalityPanel();
    }

    function ensureTournamentBracketState() {
        if (!window._tournamentBracketState) window._tournamentBracketState = { assignment: {}, colors: { A: '#6b7280', B: '#6b7280', C: '#6b7280' } };
        const st = window._tournamentBracketState;
        if (!st.assignment) st.assignment = {};
        if (!st.colors) st.colors = { A: '#6b7280', B: '#6b7280', C: '#6b7280' };
        Object.keys(st.assignment).forEach(k => { if (!selectedQueens.includes(k)) delete st.assignment[k]; });
        selectedQueens.forEach(q => { if (st.assignment[q] === undefined) st.assignment[q] = ''; });
        return st;
    }

    function updateBracketColor(bracket, color) {
        const st = ensureTournamentBracketState();
        if (st.colors) {
            st.colors[bracket] = color;
        }
    }

    function getTournamentGroupsFromState() {
        const st = ensureTournamentBracketState();
        const groupA = [];
        const groupB = [];
        const groupC = [];
        selectedQueens.forEach(q => {
            const g = st.assignment[q] || '';
            if (g === 'A') groupA.push(q);
            else if (g === 'B') groupB.push(q);
            else if (g === 'C') groupC.push(q);
        });
        return { groupA, groupB, groupC };
    }

    function renderTournamentBracketPanel() {
        const { groupA, groupB, groupC } = getTournamentGroupsFromState();
        const counts = document.getElementById('tournamentBracketCounts');
        if (counts) counts.textContent = `Bracket 1 ${groupA.length}/6 • Bracket 2 ${groupB.length}/6 • Bracket 3 ${groupC.length}/6`;

        const contBtn = document.getElementById('tournamentBracketsContinueBtn');
        if (contBtn) contBtn.disabled = !(groupA.length === 6 && groupB.length === 6 && groupC.length === 6);

        const list = document.getElementById('tournamentBracketQueenList');
        if (list) {
            const st = ensureTournamentBracketState();
            list.innerHTML = selectedQueens.map(q => {
                const current = st.assignment[q] || '';
                const photo = queensDb[q] ? queensDb[q].photo : '';
                return `
                    <div class="flex items-center gap-3 py-2 px-3 rounded-xl border border-gray-100 bg-white hover:bg-gray-50 transition">
                        <img src="${photo}" alt="" class="w-10 h-10 rounded-full object-cover border-2 border-white shadow flex-shrink-0">
                        <span class="text-sm font-bold text-gray-800 flex-1 truncate">${q}</span>
                        <select class="text-xs font-bold rounded-lg border-2 border-gray-200 px-2 py-1.5 bg-white min-w-[120px] focus:border-[#ec4899] focus:ring-1 focus:ring-[#ec4899] focus:outline-none"
                            onchange="updateTournamentBracketAssignment('${q.replace(/'/g, "\\'").replace(/"/g, '&quot;')}', this.value)">
                            <option value="" ${current === '' ? 'selected' : ''}>Unassigned</option>
                            <option value="A" ${current === 'A' ? 'selected' : ''}>Bracket 1</option>
                            <option value="B" ${current === 'B' ? 'selected' : ''}>Bracket 2</option>
                            <option value="C" ${current === 'C' ? 'selected' : ''}>Bracket 3</option>
                        </select>
                    </div>`;
            }).join('');
        }

        const renderGroup = (elId, arr) => {
            const el = document.getElementById(elId);
            if (!el) return;
            el.innerHTML = arr.map(q => {
                const photo = queensDb[q] ? queensDb[q].photo : '';
                return `
                    <div class="flex items-center gap-2 py-1.5 px-2 rounded-xl border border-gray-100 bg-gray-50">
                        <img src="${photo}" alt="" class="w-7 h-7 rounded-full object-cover border-2 border-white shadow flex-shrink-0">
                        <span class="text-[11px] font-bold text-gray-800 truncate">${q}</span>
                    </div>`;
            }).join('') + Array.from({ length: Math.max(0, 6 - arr.length) }).map(() => `
                <div class="h-[38px] rounded-xl border-2 border-dashed border-gray-200 bg-white"></div>
            `).join('');
        };
        renderGroup('tournamentGroupA', groupA);
        renderGroup('tournamentGroupB', groupB);
        renderGroup('tournamentGroupC', groupC);

        const st = ensureTournamentBracketState();
        if (st.colors) {
            const ca = document.getElementById('bracketColorA');
            const cb = document.getElementById('bracketColorB');
            const cc = document.getElementById('bracketColorC');
            if (ca) ca.value = st.colors.A || '#6b7280';
            if (cb) cb.value = st.colors.B || '#6b7280';
            if (cc) cc.value = st.colors.C || '#6b7280';
        }
    }

    function updateTournamentBracketAssignment(queenName, value) {
        const st = ensureTournamentBracketState();
        const current = st.assignment[queenName] || '';
        if (current === value) return;
        st.assignment[queenName] = value || '';
        const { groupA, groupB, groupC } = getTournamentGroupsFromState();
        const over = (value === 'A' && groupA.length > 6) || (value === 'B' && groupB.length > 6) || (value === 'C' && groupC.length > 6);
        if (over) {
            st.assignment[queenName] = current;
            showToast('This bracket already has 6 queens.', 'error');
        }
        renderTournamentBracketPanel();
    }

    function randomizeTournamentBrackets() {
        const st = ensureTournamentBracketState();
        selectedQueens.forEach(q => { st.assignment[q] = ''; });
        const shuffled = [...selectedQueens].map(q => ({ q, r: Math.random() })).sort((a, b) => a.r - b.r).map(x => x.q);
        const chosen = shuffled.slice(0, 18);
        chosen.slice(0, 6).forEach(q => { st.assignment[q] = 'A'; });
        chosen.slice(6, 12).forEach(q => { st.assignment[q] = 'B'; });
        chosen.slice(12, 18).forEach(q => { st.assignment[q] = 'C'; });
        renderTournamentBracketPanel();
    }

    function clearTournamentBrackets() {
        const st = ensureTournamentBracketState();
        selectedQueens.forEach(q => { st.assignment[q] = ''; });
        renderTournamentBracketPanel();
    }

    function openTournamentBracketPanel() {
        if (selectedQueens.length !== MAX_CAST) {
            showToast(`Tournament requires exactly ${MAX_CAST} queens.`, 'error');
            document.getElementById('setupPanel').classList.remove('hidden');
            return;
        }
        premiereType = 'tournament';
        document.getElementById('openerPickerPanel').classList.add('hidden');
        document.getElementById('doublePremierePanel').classList.add('hidden');
        document.getElementById('relationshipsPanel').classList.add('hidden');
        document.getElementById('personalityPanel').classList.add('hidden');
        document.getElementById('tournamentBracketPanel').classList.remove('hidden');
        
        const bracketStepSep = document.getElementById('tournamentBracketStepSep');
        const bracketStepPers = document.getElementById('tournamentBracketStepPersonality');
        const bracketStepRel = document.getElementById('tournamentBracketStepRelationships');
        if (bracketStepSep) bracketStepSep.classList.remove('hidden');
        if (bracketStepPers) bracketStepPers.classList.remove('hidden');
        if (bracketStepRel) bracketStepRel.classList.remove('hidden');

        ensureTournamentBracketState();
        renderTournamentBracketPanel();
    }

    function confirmTournamentBracketsAndContinue() {
        if (selectedQueens.length !== MAX_CAST) {
            showToast(`Tournament requires exactly ${MAX_CAST} queens.`, 'error');
            return;
        }
        const { groupA, groupB, groupC } = getTournamentGroupsFromState();
        if (!(groupA.length === 6 && groupB.length === 6 && groupC.length === 6)) {
            showToast('Tournament requires 6 queens in each bracket (18 total).', 'error');
            return;
        }
        selectedQueens = [...groupA, ...groupB, ...groupC];
        document.getElementById('tournamentBracketPanel').classList.add('hidden');
        openPersonalityPanel();
    }

    function getRelationshipsFromUI() {
        ensureRelationshipsState();
        const rel = window._relationshipsState ? { ...window._relationshipsState } : {};
        document.querySelectorAll('.relationship-select').forEach(s => {
            const key = s.getAttribute('data-rel-key');
            if (key) rel[key] = s.value;
        });
        return rel;
    }

    function ensurePersonalityState() {
        if (!window._personalityState) window._personalityState = {};
        selectedQueens.forEach(q => {
            if (!window._personalityState[q]) window._personalityState[q] = DEFAULT_PERSONALITY;
        });
    }

    function renderPersonalityGrid() {
        ensurePersonalityState();
        const grid = document.getElementById('personalityGrid');
        if (!grid) return;
        const prevScrollTop = grid.scrollTop;
        const prevScrollLeft = grid.scrollLeft;
        const iconMap = {
            fair: '📈',
            strategy: '🧠',
            loyal: '💖',
            chaos: '🎭'
        };
        const activeStyleById = {
            fair: ' bg-emerald-600 border-emerald-600 text-white',
            strategy: ' bg-orange-500 border-orange-500 text-white',
            loyal: ' bg-pink-500 border-pink-500 text-white',
            chaos: ' bg-purple-600 border-purple-600 text-white'
        };
        grid.innerHTML = selectedQueens.map((q, idx) => {
            const current = window._personalityState[q] || DEFAULT_PERSONALITY;
            const photo = queensDb[q] ? queensDb[q].photo : '';
            const buttons = PERSONALITY_TYPES.map(t => {
                const isActive = t.id === current;
                const base = 'inline-flex items-center justify-center sm:justify-start gap-0 sm:gap-1.5 text-xs font-bold rounded-full border transition w-9 h-9 sm:w-auto sm:h-auto px-0 sm:px-3 py-0 sm:py-1.5';
                const activeCls = activeStyleById[t.id] || ' bg-[#ec4899] border-[#ec4899] text-white';
                const inactiveCls = ' bg-white border-gray-200 text-gray-500 hover:bg-gray-50';
                const icon = iconMap[t.id] || '';
                return `<button type="button" class="${base}${isActive ? activeCls : inactiveCls}" data-queen="${q.replace(/"/g, '&quot;')}" data-value="${t.id}" onclick="updatePersonalityFromButton(this)"><span class="${isActive ? 'text-white/90' : 'text-gray-400'} text-[11px]">${icon}</span><span class="hidden sm:inline">${t.label}</span></button>`;
            }).join(' ');
            return `
                <div class="flex items-center justify-between gap-3 px-4 py-3 border-b border-gray-200/60 bg-white">
                    <div class="flex items-center gap-3 min-w-0 flex-1">
                        <img src="${photo}" alt="" class="w-10 h-10 rounded-full object-cover border-2 border-white shadow flex-shrink-0">
                        <span class="text-sm font-bold text-gray-800 truncate">${q}</span>
                    </div>
                    <div class="flex items-center flex-nowrap gap-2 justify-end flex-none">${buttons}</div>
                </div>`;
        }).join('');
        requestAnimationFrame(() => {
            grid.scrollTop = prevScrollTop;
            grid.scrollLeft = prevScrollLeft;
        });
    }

    function updatePersonalityFromButton(el) {
        const pageX = window.scrollX;
        const pageY = window.scrollY;
        const queen = el.getAttribute('data-queen');
        const value = el.getAttribute('data-value');
        if (!queen || !value) return;
        if (!window._personalityState) window._personalityState = {};
        window._personalityState[queen] = value;
        if (document.activeElement && typeof document.activeElement.blur === 'function') {
            document.activeElement.blur();
        }
        renderPersonalityGrid();
        requestAnimationFrame(() => window.scrollTo(pageX, pageY));
    }

    function resetAllPersonalities() {
        if (!window._personalityState) window._personalityState = {};
        selectedQueens.forEach(q => {
            window._personalityState[q] = DEFAULT_PERSONALITY;
        });
        renderPersonalityGrid();
    }

    function randomAllPersonalities() {
        ensurePersonalityState();
        const ids = PERSONALITY_TYPES.map(t => t.id);
        selectedQueens.forEach(q => {
            const idx = Math.floor(Math.random() * ids.length);
            window._personalityState[q] = ids[idx];
        });
        renderPersonalityGrid();
    }

    function openPersonalityPanel() {
        ensurePersonalityState();
        renderPersonalityGrid();
        document.getElementById('openerPickerPanel').classList.add('hidden');
        document.getElementById('relationshipsPanel').classList.add('hidden');
        const bracketPanel = document.getElementById('tournamentBracketPanel');
        if (bracketPanel) bracketPanel.classList.add('hidden');
        document.getElementById('personalityPanel').classList.remove('hidden');

        const seasonMode = getSelectedSeasonMode();
        if (seasonMode === 'tournament') {
            document.getElementById('personalityStepOpener').classList.add('hidden');
            document.getElementById('personalityStepSep1').classList.add('hidden');
            document.getElementById('personalityStepDouble').classList.add('hidden');
            document.getElementById('personalityStepSep3').classList.add('hidden');
            
            const sep2 = document.getElementById('personalityStepSep2');
            if (sep2) sep2.classList.remove('hidden');
            const bracketStep = document.getElementById('personalityStepBrackets');
            if (bracketStep) bracketStep.classList.remove('hidden');
            
            const bracketNum = document.getElementById('personalityStepBracketsNum');
            if (bracketNum) {
                bracketNum.classList.remove('bg-gray-200', 'text-gray-600');
                bracketNum.classList.add('bg-pink-100', 'text-[#ec4899]');
                bracketNum.textContent = '1';
            }
            const persNum = document.getElementById('personalityStepPersonalityNum');
            if (persNum) {
                persNum.classList.remove('bg-pink-100', 'text-[#ec4899]');
                persNum.classList.add('bg-[#ec4899]', 'text-white');
                persNum.textContent = '2';
            }
            const relNum = document.getElementById('personalityStepRelationshipsNum');
            if (relNum) {
                relNum.textContent = '3';
            }
        } else {
            document.getElementById('personalityStepOpener').classList.remove('hidden');
            document.getElementById('personalityStepSep1').classList.remove('hidden');
            
            if (isDoublePremiereType(premiereType)) {
                document.getElementById('personalityStepDouble').classList.remove('hidden');
                document.getElementById('personalityStepSep3').classList.remove('hidden');
            } else {
                document.getElementById('personalityStepDouble').classList.add('hidden');
                document.getElementById('personalityStepSep3').classList.add('hidden');
            }
            
            const sep2 = document.getElementById('personalityStepSep2');
            if (sep2) sep2.classList.add('hidden');
            const bracketStep = document.getElementById('personalityStepBrackets');
            if (bracketStep) bracketStep.classList.add('hidden');
            
            const opNum = document.getElementById('personalityStepOpenerNum');
            if (opNum) opNum.textContent = '1';
            const pNum = document.getElementById('personalityStepPersonalityNum');
            if (pNum) pNum.textContent = isDoublePremiereType(premiereType) ? '3' : '2';
            const rNum = document.getElementById('personalityStepRelationshipsNum');
            if (rNum) rNum.textContent = isDoublePremiereType(premiereType) ? '4' : '3';
        }
    }

    function openRelationshipsPanel() {
        ensureRelationshipsState();
        renderRelationshipsGrid();
        document.getElementById('personalityPanel').classList.add('hidden');
        const bracketPanel = document.getElementById('tournamentBracketPanel');
        if (bracketPanel) bracketPanel.classList.add('hidden');
        document.getElementById('relationshipsPanel').classList.remove('hidden');

        const isLuckyQueen = document.getElementById('luckyQueenTwist') ? document.getElementById('luckyQueenTwist').checked : false;
        const section = document.getElementById('luckyQueenSelectionSection');
        if (section) {
            if (isLuckyQueen) {
                section.classList.remove('hidden');
                renderLuckyQueenSelection();
            } else {
                section.classList.add('hidden');
            }
        }

        const seasonMode = getSelectedSeasonMode();
        if (seasonMode === 'tournament') {
            document.getElementById('relationshipsStepOpener').classList.add('hidden');
            document.getElementById('relationshipsStepSep1').classList.add('hidden');
            document.getElementById('relationshipsStepDouble').classList.add('hidden');
            document.getElementById('relationshipsStepSep3').classList.add('hidden');
            
            const sep2 = document.getElementById('relationshipsStepSep2');
            if (sep2) sep2.classList.remove('hidden');
            const bracketStep = document.getElementById('relationshipsStepBrackets');
            if (bracketStep) bracketStep.classList.remove('hidden');
            
            const bracketNum = document.getElementById('relationshipsStepBracketsNum');
            if (bracketNum) {
                bracketNum.classList.remove('bg-gray-200', 'text-gray-600');
                bracketNum.classList.add('bg-pink-100', 'text-[#ec4899]');
                bracketNum.textContent = '1';
            }
            const persNum = document.getElementById('relationshipsStepPersonalityNum');
            if (persNum) {
                persNum.classList.remove('bg-pink-100', 'text-[#ec4899]');
                persNum.classList.add('bg-pink-100', 'text-[#ec4899]'); 
                persNum.textContent = '2';
            }
            const relNum = document.getElementById('relationshipsStepRelationshipsNum');
            if (relNum) {
                relNum.classList.remove('bg-pink-100', 'text-[#ec4899]');
                relNum.classList.add('bg-[#ec4899]', 'text-white');
                relNum.textContent = '3';
            }
        } else {
            document.getElementById('relationshipsStepOpener').classList.remove('hidden');
            document.getElementById('relationshipsStepSep1').classList.remove('hidden');
            
            if (isDoublePremiereType(premiereType)) {
                document.getElementById('relationshipsStepDouble').classList.remove('hidden');
                document.getElementById('relationshipsStepSep3').classList.remove('hidden');
            } else {
                document.getElementById('relationshipsStepDouble').classList.add('hidden');
                document.getElementById('relationshipsStepSep3').classList.add('hidden');
            }
            
            const sep2 = document.getElementById('relationshipsStepSep2');
            if (sep2) sep2.classList.add('hidden');
            const bracketStep = document.getElementById('relationshipsStepBrackets');
            if (bracketStep) bracketStep.classList.add('hidden');
            
            const pNum = document.getElementById('relationshipsStepPersonalityNum');
            if (pNum) pNum.textContent = isDoublePremiereType(premiereType) ? '3' : '2';
            const rNum = document.getElementById('relationshipsStepRelationshipsNum');
            if (rNum) rNum.textContent = isDoublePremiereType(premiereType) ? '4' : '3';
        }
    }

    function backFromPersonalityPanel() {
        document.getElementById('personalityPanel').classList.add('hidden');

        const seasonMode = getSelectedSeasonMode();
        const isLuckyQueen = document.getElementById('luckyQueenTwist') ? document.getElementById('luckyQueenTwist').checked : false;

        if (seasonMode === 'tournament') {
            openTournamentBracketPanel();
        } else if (isLuckyQueen) {
            openLuckyQueenPanel();
        } else if (isDoublePremiereType(premiereType)) {
            const dp = document.getElementById('doublePremierePanel');
            if (dp) dp.classList.remove('hidden');
            renderDoublePremiereGrid();
            updateDoublePremiereCount();
        } else {
            const panel = document.getElementById('openerPickerPanel');
            panel.classList.remove('hidden');
            panel.style.display = '';
        }
    }

    function getPersonalityForQueen(name) {
        if (window._personalityState && window._personalityState[name]) return window._personalityState[name];
        return DEFAULT_PERSONALITY;
    }

    function getRelationshipStrength(relType) {
        if (relType === 'drag_family') return 3;
        if (relType === 'great') return 2;
        if (relType === 'good') return 1;
        if (relType === 'neutral') return 0;
        if (relType === 'bad') return -1;
        if (relType === 'chop') return -2;
        return 0;
    }

    function getBeaverSaveScore(entry, saverName, personality, stats, relationships, isFirstEpisode) {
        const name = entry.name;
        const st = stats[name] || {};
        const ppe = st.ppe || 0;
        const perf = entry.total || 0;
        const relKey = getRelationshipKey(saverName, name);
        const relType = (relationships && relationships[relKey]) || DEFAULT_RELATIONSHIP;
        const relScore = getRelationshipStrength(relType);
        let score = 0;
        if (personality === 'fair') {
            if (isFirstEpisode) score += perf;
            else score += ppe * 2;
            score += relScore * 2;
            score += Math.random() * 0.3;
        } else if (personality === 'strategy') {
            score -= ppe * 2;
            score += relScore * 2.5;
            score += Math.random() * 0.3;
        } else if (personality === 'loyal') {
            score += relScore * 3;
            score += Math.random() * 0.5;
        } else if (personality === 'chaos') {
            score += (Math.random() * 2 - 1);
            score += relScore * 0.3;
            score += (Math.random() - 0.5) * 0.5;
        } else {
            score += ppe;
            score += relScore;
        }
        return score;
    }

    function getBeaverSaveReason(saverName, savedName, personality, stats, relationships) {
        const st = stats[savedName] || {};
        const ppe = st.ppe || 0;
        const relKey = getRelationshipKey(saverName, savedName);
        const relType = (relationships && relationships[relKey]) || DEFAULT_RELATIONSHIP;
        const relScore = getRelationshipStrength(relType);
        const strong = ppe >= 3;
        const goodRel = relScore >= 1;
        const badRel = relScore <= -1;
        const base = {
            saver: saverName,
            saved: savedName
        };
        function pick(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }
        if (personality === 'fair') {
            if (strong && !badRel) {
                return pick([
                    `${base.saver} keeps ${base.saved} because having a strong ally is still good business.`,
                    `${base.saver} saves ${base.saved}. That track record is too valuable to lose right now.`
                ]);
            }
            if (goodRel) {
                return pick([
                    `${base.saver} knows the numbers, but loyalty to ${base.saved} wins this time.`,
                    `${base.saver} sees a chance to look fair in front of the judges by saving ${base.saved}.`
                ]);
            }
            return pick([
                `${base.saver} plays it safe and keeps ${base.saved} as the least risky option.`,
                `${base.saver} saves ${base.saved}, hoping this choice will pay off later.`
            ]);
        }
        if (personality === 'strategy') {
            if (strong && !goodRel) {
                return pick([
                    `${base.saver} lets the real threat stay in danger and pulls ${base.saved} out.`,
                    `${base.saver} saves ${base.saved} to keep bigger targets on the chopping block.`
                ]);
            }
            if (goodRel) {
                return pick([
                    `${base.saver} protects ${base.saved}. Even a strategist won't sacrifice her closest ally.`,
                    `${base.saver} plays smart but won't throw ${base.saved} under the bus.`,
                ]);
            }
            return pick([
                `${base.saver} saves ${base.saved}. She knows exactly what she is doing.`,
                `${base.saver} sees value in ${base.saved} and is not ready to let that go yet.`,
            ]);
        }
        if (personality === 'loyal') {
            if (goodRel) {
                return pick([
                    `${base.saver} saves ${base.saved}. That is what you do for someone you care about.`,
                    `${base.saver} was never going to let ${base.saved} go home. At least, not tonight.`
                ]);
            }
            return pick([
                `${base.saver} saves ${base.saved}. Something about her just felt worth protecting.`,
                `${base.saver} goes with her heart and keeps ${base.saved} in the competition.`
            ]);
        }
        if (personality === 'chaos') {
            if (badRel) {
                return pick([
                   `${base.saver} saves ${base.saved} and even she looks surprised by her own decision.`,
                    `${base.saver} does not even like ${base.saved}. She saves her anyway. Classic.`,
                ]);
            }
            return pick([
                `${base.saver} closes her eyes, points, and somehow saves ${base.saved}.`,
                `${base.saver} woke up and chose chaos. ${base.saved} is the lucky winner.`
            ]);
        }
        if (goodRel) {
            return `${base.saver} saves ${base.saved} because their connection is stronger than any strategy.`;
        }
        if (strong) {
            return `${base.saver} keeps ${base.saved} around. You don't throw away such a strong queen like that.`;
        }
        return `${base.saver} saves ${base.saved}.`;
    }

    function getAllStarsElimReason(deciderName, targetName, personality, stats, relationships) {
        const st = stats[targetName] || {};
        const ppe = st.ppe || 0;
        const relKey = getRelationshipKey(deciderName, targetName);
        const relType = (relationships && relationships[relKey]) || DEFAULT_RELATIONSHIP;
        const relScore = getRelationshipStrength(relType);
        const strong = ppe >= 3;
        const weak = ppe < 2;
        const goodRel = relScore >= 1;
        const badRel = relScore <= -1;
        const base = {
            decider: deciderName,
            target: targetName
        };
        function pick(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }
        if (personality === 'fair') {
            if (weak) {
                return pick([
                    `${base.decider} eliminates ${base.target} based on track record.`,
                    `${base.decider} feels ${base.target} has been struggling and it is only fair to send her home.`
                ]);
            }
            if (strong) {
                return pick([
                    `${base.decider} respects ${base.target}'s run, but tonight she fell short.`,
                    `${base.decider} makes a tough call, believing ${base.target} deserved to stay longer but faltered.`
                ]);
            }
            if (goodRel) {
                return pick([
                    `${base.decider} loves ${base.target}, but has to judge fairly on the competition.`,
                    `${base.decider} sees the threat. ${base.target} had a great run, but it ends here.`
                ]);
            }
            return pick([
                `${base.decider} weighs the performance and decides ${base.target} should go.`,
                `${base.decider} keeps it professional and eliminates ${base.target} based on the challenge.`
            ]);
        }
        if (personality === 'strategy') {
            if (strong && !goodRel) {
                return pick([
                    `${base.decider} cuts ${base.target} now, before she can reach the finale.`,
                    `${base.decider} knows ${base.target} could beat her later, so she strikes early.`
                ]);
            }
            if (goodRel && strong) {
                return pick([
                    `${base.decider} takes a huge risk sending ${base.target} home, sacrificing a strong ally.`,
                    `${base.decider} eliminates ${base.target}, proving that no one is safe.`
                ]);
            }
            if (badRel) {
                return pick([
                    `${base.decider} never trusted ${base.target}, and this was the easiest choice to make.`,
                    `${base.decider} has been waiting to cut ${base.target} since episode one.`
                ]);
            }
            return pick([
                `${base.decider} plays the numbers and decides ${base.target} is the most logical choice.`,
                `${base.decider} sends ${base.target} home to keep the game balanced in her favour.`
            ]);
        }
        if (personality === 'loyal') {
            if (goodRel) {
                return pick([
                    `${base.decider} is heartbroken sending ${base.target} home, but someone had to go.`,
                    `${base.decider} tears up a little. "I love you, ${base.target}, but you gotta go.`,
                ]);
            }
            if (badRel) {
                return pick([
                    `${base.decider} does not feel a bond with ${base.target}, so this choice feels obvious.`,
                    `${base.decider} sends ${base.target} home without a second thought.`
                ]);
            }
            if (weak) {
                return pick([
                    `${base.decider} believes ${base.target} has reached the end of her story here.`,
                    `${base.decider} sends ${base.target} home, hoping it will be a graceful exit.`
                ]);
            }
            return pick([
                `${base.decider} follows her heart and chooses ${base.target}, even if it hurts.`,
                `${base.decider} makes a gentle but firm choice to send ${base.target} away.`
            ]);
        }
        if (personality === 'chaos') {
            if (badRel) {
                return pick([
                    `${base.decider} has beef with ${base.target} and absolutely does not care who knows it.`,
                    `${base.decider} and ${base.target} never got along. And now ${base.target} pays the price.`
                ]);
            }
            if (strong) {
                return pick([
                    `${base.decider} eliminates ${base.target} just to shake the game to its core.`,
                    `${base.decider} makes a shocking move, cutting a clear frontrunner in ${base.target}.`
                ]);
            }
            return pick([
                `Eeny, meeny, miny, moe... ${base.target} has got to go.`,
                `${base.decider} closes her eyes, spins around, and points at ${base.target}. Done.`
            ]);
        }
        if (goodRel) {
             return `${base.decider} hates this, but ${base.target} had to go.`;
        }
        if (strong) {
            return `${base.decider} sees ${base.target} as the biggest threat in the room.`;
        }
        if (weak) {
            return `${base.decider} thinks ${base.target} gave it her all. It just wasn't enough.`;
        }
       return `${base.decider} thinks that ${base.target} was the obvious cut.`;
    }

    function generateSeasonWithRelationships() {
        if (selectedQueens.length > MAX_CAST) {
            showToast(`Max cast size is ${MAX_CAST} queens.`, 'error');
            return;
        }
        const relationships = getRelationshipsFromUI();
        if (Object.keys(relationships).length === 0) {
            const pairs = [];
            for (let i = 0; i < selectedQueens.length; i++) for (let j = i + 1; j < selectedQueens.length; j++) pairs.push(getRelationshipKey(selectedQueens[i], selectedQueens[j]));
            pairs.forEach(k => { relationships[k] = DEFAULT_RELATIONSHIP; });
        }
        const seasonMode = getSelectedSeasonMode();
        if (seasonMode === 'tournament' && selectedQueens.length !== MAX_CAST) {
            showToast(`Tournament requires exactly ${MAX_CAST} queens.`, 'error');
            return;
        }
        const relPanel = document.getElementById('relationshipsPanel');
        const persPanel = document.getElementById('personalityPanel');
        if (relPanel) relPanel.classList.add('hidden');
        if (persPanel) persPanel.classList.add('hidden');
        if (seasonMode === 'allstars') generateAllStarsSeason(relationships);
        else if (seasonMode === 'tournament') generateTournamentAllStarsSeason(relationships);
        else generateSeason(relationships);
    }

    function exitScenarioToSetup() {
        const sc = document.getElementById('scenarioScreen');
        if (sc) sc.classList.add('hidden');
        const tr = document.getElementById('trackRecordContainer');
        if (tr) tr.classList.add('hidden');
        const hs = document.getElementById('headerSection');
        if (hs) hs.classList.remove('hidden');
        const sp = document.getElementById('setupPanel');
        if (sp) sp.classList.remove('hidden');
        setHeaderMode('setup');
    }

    function setHeaderMode(mode) {
        const main = document.getElementById('headerMainRow');
        const scenario = document.getElementById('headerScenarioRow');
        const tabs = document.getElementById('headerScenarioTabs');
        if (!main || !scenario) return;
        if (mode === 'scenario') {
            main.classList.add('hidden');
            scenario.classList.remove('hidden');
            if (tabs) tabs.classList.remove('hidden');
        } else {
            scenario.classList.add('hidden');
            main.classList.remove('hidden');
            if (tabs) tabs.classList.add('hidden');
        }
    }

    function jumpToEpisode(idx) {
        const nextIdx = Number(idx);
        if (!isFinite(nextIdx) || !seasonData || !Array.isArray(seasonData.episodes)) return;
        if (nextIdx < 0 || nextIdx >= seasonData.episodes.length) return;
        currentEpIndex = nextIdx;
        const ep = seasonData.episodes[currentEpIndex];
        if (ep && ep.challenge === 'Girl Groups' && ep.groups) ep.groupsShown = false;
        scenarioPhase = 0;
        renderScenario();
    }

    function goPrevEpisode() {
        if (!seasonData || !Array.isArray(seasonData.episodes)) return;
        if (currentEpIndex <= 0) return;
        currentEpIndex -= 1;
        const ep = seasonData.episodes[currentEpIndex];
        if (ep && ep.challenge === 'Girl Groups' && ep.groups) ep.groupsShown = false;
        scenarioPhase = 0;
        renderScenario();
    }

    function goNextEpisode() {
        if (!seasonData || !Array.isArray(seasonData.episodes)) return;
        if (currentEpIndex >= seasonData.episodes.length - 1) return;
        currentEpIndex += 1;
        const ep = seasonData.episodes[currentEpIndex];
        if (ep && ep.challenge === 'Girl Groups' && ep.groups) ep.groupsShown = false;
        scenarioPhase = 0;
        renderScenario();
    }
    
    let seasonData = null;
    let currentEpIndex = 0;
    let scenarioPhase = 0; 

    const challengeConfig = {
        'Talent Show': ['performance', 'comedy', 'fashion'], 'Design': ['design'], 'Girl Groups': ['performance'],
        'Snatch Game': ['comedy', 'acting'], 'Acting': ['improv', 'acting'], 'Makeover': ['design', 'fashion'],
        'Rusical': ['performance', 'acting'], 'Roast': ['comedy'], 'Ball': ['design', 'fashion'], 'Improv': ['comedy', 'improv'],
        'Advert': ['design', 'comedy'], 'Dancing': ['performance', 'improv'], 'Rumix': ['performance', 'comedy'], 'Runway':['fashion'], 'Stand Up':['comedy']
    };
    const challengesList = Object.keys(challengeConfig);
    const lipSyncSongs = window.lipSyncSongs || [];
    const pickRandomLipSyncSong = window.pickRandomLipSyncSong || (() => '');
    const CHALLENGE_DEFINITIONS = {
        'Talent Show': { type: 'Variety', priority: 10, oneTime: true, allowedPhases: ['finale_only'] },
        'Girl Groups': { type: 'Performance', priority: 8, oneTime: true, allowedPhases: ['early', 'mid'] },
        'Design': { type: 'Look', priority: 7, repeatable: true, required: true, allowedPhases: ['early', 'mid', 'late'] },
        'Snatch Game': { type: 'Comedy', priority: 10, required: true, oneTime: true, allowedPhases: ['mid'] },
        'Rusical': { type: 'Performance', priority: 7, required: true, oneTime: true, allowedPhases: ['mid'] },
        'Acting': { type: 'Acting', priority: 4, repeatable: true, allowedPhases: ['early', 'mid'] },
        'Improv': { type: 'Comedy', priority: 4, repeatable: true, allowedPhases: ['early', 'mid'] },
        'Advert': { type: 'Comedy', priority: 5, repeatable: true, allowedPhases: ['mid', 'late'] },
        'Dancing': { type: 'Performance', priority: 4, repeatable: true, allowedPhases: ['mid', 'late'] },
        'Roast': { type: 'Comedy', priority: 9, oneTime: true, allowedPhases: ['late'] },
        'Makeover': { type: 'Look', priority: 9, required: true, oneTime: true, allowedPhases: ['late'] },
        'Ball': { type: 'Look', priority: 8, oneTime: true, allowedPhases: ['mid', 'late'] },
        'Rumix': { type: 'Performance', priority: 9, oneTime: true, allowedPhases: ['finale_only'] },
        'Runway': { type: 'Look', priority: 5, oneTime: true, allowedPhases: ['early', 'mid'] },
        'Stand Up': { type: 'Comedy', priority: 4, repeatable: true, allowedPhases: ['mid', 'late'] },
    };

    function hasRunwayForChallenge(chal) {
        if (!chal) return false;
        if (chal === 'Design' || chal === 'Ball' || chal === 'Makeover' || chal === 'Runway') return false;
        const lower = String(chal).toLowerCase();
        if (lower.includes('finale')) return false;
        return true;
    }

   
    const RIGGORY_PPE_THRESHOLD = 0.35;

    function calcLipSyncScore(queenName, context, stats) {
        const queen = queensDb[queenName];
        if (!queen) return { name: queenName, score: 0, breakdown: '' };
        const base = queen.lipsync;
        const luck = Math.random() * 7;
        if (context === 'allstars_top2') {
            return { name: queenName, score: base + luck, breakdown: '' };
        }
        const st = stats && stats[queenName];
        const ppe = st ? st.ppe : 0;
        const bottoms = st ? st.bottoms : 0;
        if (context === 'lalaparuza') {
            const luckTenth = Math.round(luck * 10) / 10;
            return { name: queenName, score: base + luckTenth, breakdown: `LipSync:${base.toFixed(1)} + Random:${luckTenth.toFixed(1)}` };
        }
        if (context === 'btm2') {
            const trBonus = ppe * 2.5;
            const fatigue = bottoms * 1.5;
            return { name: queenName, score: base + luck + trBonus - fatigue, breakdown: `LipSync:${base.toFixed(1)} + Random:${luck.toFixed(1)} + TR:${trBonus.toFixed(1)} - Fatigue:${fatigue.toFixed(1)}` };
        }
        if (context === 'finale') {
            const trBonus = ppe * 1.5;
            return { name: queenName, score: base + luck + trBonus, breakdown: `LipSync:${base.toFixed(1)} + Random:${luck.toFixed(1)} + TR:${trBonus.toFixed(1)}` };
        }
        return { name: queenName, score: base + luck, breakdown: `LipSync:${base.toFixed(1)} + Random:${luck.toFixed(1)}` };
    }

    const SOFTMAX_TEMPERATURE = 5;
    const STREAK_PENALTY_MULTIPLIER = 1;

    function hashString(str) {
        let h = 0;
        for (let i = 0; i < str.length; i++) {
            h = ((h << 5) - h) + str.charCodeAt(i);
            h |= 0;
        }
        return h;
    }

    function getVolatilityForQueen(name) {
        const h = Math.abs(hashString(String(name || '')));
        const r = (h % 1000) / 1000;
        return 0.85 + r * 0.3;
    }

    function addNormalizedTotals(scores, scoreKey = 'total', outKey = 'normTotal') {
        if (!scores || !scores.length) return scores;
        const vals = scores.map(s => Number(s?.[scoreKey])).filter(v => isFinite(v));
        if (!vals.length) {
            scores.forEach(s => { s[outKey] = 0; });
            return scores;
        }
        const mean = vals.reduce((a, b) => a + b, 0) / vals.length;
        const variance = vals.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / vals.length;
        const std = Math.sqrt(variance) || 0;
        scores.forEach(s => {
            const v = Number(s?.[scoreKey]);
            s[outKey] = std > 0 && isFinite(v) ? (v - mean) / std : 0;
        });
        return scores;
    }

    function getDynamicTemperature(scores, scoreKey = 'total') {
        const vals = (scores || []).map(s => Number(s?.[scoreKey])).filter(v => isFinite(v));
        if (vals.length < 2) return SOFTMAX_TEMPERATURE;
        vals.sort((a, b) => b - a);
        const gap = Math.max(0, vals[0] - vals[1]);
        const boost = Math.max(0, 1.5 - Math.min(gap, 1.5));
        return Math.min(6, Math.max(2, SOFTMAX_TEMPERATURE + boost));
    }

    function getWinStreak(recentWins, name) {
        const v = recentWins && name ? recentWins[name] : 0;
        return (typeof v === 'number' && isFinite(v) && v > 0) ? v : 0;
    }

    function getWinStreakPenalty(streak) {
        if (streak >= 5) return 8;
        if (streak === 4) return 5.5;
        if (streak === 3) return 3.5;
        if (streak === 2) return 2;
        if (streak === 1) return 1;
        return 0;
    }

    function applyWinStreakPenalty(scores, recentWins, penaltyMultiplier, scoreKey = 'total') {
        if (!scores || !scores.length) return scores;
        const mult = (typeof penaltyMultiplier === 'number' && isFinite(penaltyMultiplier)) ? penaltyMultiplier : 1;
        if (!mult) return scores;
        return scores.map(s => {
            const streak = getWinStreak(recentWins, s.name);
            const basePenalty = getWinStreakPenalty(streak);
            if (!basePenalty) return s;
            const v = Number(s?.[scoreKey]);
            if (!isFinite(v)) return s;
            return { ...s, [scoreKey]: v - basePenalty * mult };
        });
    }

    function pickWinnersWithStreak(scores, count, recentWins, penaltyMultiplier, scoreKey = 'total', temperature = SOFTMAX_TEMPERATURE) {
        const adjusted = applyWinStreakPenalty(scores, recentWins, penaltyMultiplier, scoreKey);
        const picked = pickSoftmaxItems(adjusted, count, scoreKey, temperature);
        if (!picked.length) return [];
        const byName = new Map(scores.map(s => [s.name, s]));
        return picked.map(p => byName.get(p.name)).filter(Boolean);
    }

    function updateRecentWins(recentWins, winners, cast) {
        if (!recentWins || !cast) return;
        const winnerNames = new Set((winners || []).map(w => typeof w === 'string' ? w : w?.name).filter(Boolean));
        for (let i = 0; i < cast.length; i++) {
            const name = cast[i];
            const prev = getWinStreak(recentWins, name);
            recentWins[name] = winnerNames.has(name) ? prev + 1 : 0;
        }
    }

    function pickSoftmaxIndex(items, scoreKey, temperature) {
        if (!items || items.length === 0) return -1;
        const t = Math.max(0.25, temperature || 1);
        let max = -Infinity;
        for (let i = 0; i < items.length; i++) {
            const v = Number(items[i]?.[scoreKey]);
            if (v > max) max = v;
        }
        let sum = 0;
        const weights = new Array(items.length);
        for (let i = 0; i < items.length; i++) {
            const v = Number(items[i]?.[scoreKey]);
            const w = Math.exp(((isFinite(v) ? v : -Infinity) - max) / t);
            weights[i] = w;
            sum += w;
        }
        if (!(sum > 0) || !isFinite(sum)) return Math.floor(Math.random() * items.length);
        let r = Math.random() * sum;
        for (let i = 0; i < weights.length; i++) {
            r -= weights[i];
            if (r <= 0) return i;
        }
        return weights.length - 1;
    }

    function pickSoftmaxItems(items, count, scoreKey, temperature) {
        const pool = (items || []).slice();
        const out = [];
        const n = Math.max(0, Math.min(count || 0, pool.length));
        for (let i = 0; i < n; i++) {
            const idx = pickSoftmaxIndex(pool, scoreKey, temperature);
            if (idx < 0) break;
            out.push(pool[idx]);
            pool.splice(idx, 1);
        }
        return out;
    }

    function getDoublePremiereBuckets(scores, winnersOverride, scoreKey = 'total') {
        const n = scores.length;
        const temp = getDynamicTemperature(scores, scoreKey);
        const winners = (winnersOverride && winnersOverride.length)
            ? winnersOverride.slice(0, Math.min(2, n))
            : pickSoftmaxItems(scores, Math.min(2, n), scoreKey, temp);
        const winnerNames = new Set(winners.map(w => w.name));
        const rest = scores.filter(s => !winnerNames.has(s.name));
        let high = [];
        let safe = [];
        let low = [];
        if (n === 5) {
            high = rest.slice(0, 1);
            safe = rest.slice(1);
        } else if (n === 6) {
            high = rest.slice(0, 1);
            safe = rest.slice(1, 3);
            low = rest.slice(3, 4);
        } else if (n === 7) {
            high = rest.slice(0, 1);
            safe = rest.slice(1, 4);
            low = rest.slice(4, 5);
        } else if (n === 8) {
            high = rest.slice(0, 2);
            safe = rest.slice(2, 4);
            low = rest.slice(4);
        } else if (n >= 9) {
            high = rest.slice(0, 2);
            low = rest.slice(-2);
            safe = rest.slice(2, rest.length - 2);
        } else {
            safe = rest.slice();
        }
        return { winners, high, safe, low };
    }

    function pickChallengeForEpisode(epNum, state, opener, isLastCompetitiveEp, finaleLimit, totalCastSize) {
        const usedCount = state.usedCount || (state.usedCount = {});
        const lastType = state.lastChallengeType || null;
        const lastChal = state.lastChallenge || null;
        

        const startCount = totalCastSize || 14;
        const currentCount = Math.max(1, startCount - (epNum - 1));
        const castPercent = currentCount / startCount;

        let currentPhase = 'mid';
        if (castPercent > 0.70) currentPhase = 'early';
        else if (castPercent < 0.45) currentPhase = 'late';
        if (isLastCompetitiveEp) {
            const talentShowUsed = (usedCount['Talent Show'] || 0) > 0;
            const rumixUsed = (usedCount['Rumix'] || 0) > 0;
            let targetChallenge = '';

            if (talentShowUsed && !rumixUsed) {
                targetChallenge = 'Rumix';
            } else if (rumixUsed && !talentShowUsed) {
                targetChallenge = 'Talent Show';
            } else {
                const opts = ['Rumix', 'Talent Show'];
                targetChallenge = opts[Math.floor(Math.random() * opts.length)];
            }
            
            usedCount[targetChallenge] = (usedCount[targetChallenge] || 0) + 1;
            if (CHALLENGE_DEFINITIONS[targetChallenge]) {
                state.lastChallengeType = CHALLENGE_DEFINITIONS[targetChallenge].type;
                state.lastChallenge = targetChallenge;
            }
            return targetChallenge;
        }

        if (epNum === 1) {
            let chal1;
            if (opener === 'Random') {
                const allowedOpeners = ['Talent Show', 'Runway', 'Design', 'Girl Groups', 'Rumix'];
                const potential = Object.keys(CHALLENGE_DEFINITIONS).filter(c => {
                    if (!allowedOpeners.includes(c)) return false;

                    const def = CHALLENGE_DEFINITIONS[c];
                    if (def.allowedPhases && !def.allowedPhases.includes('early') && c !== 'Rumix' && c !== 'Talent Show') return false;
                    if (isDoublePremiereType(premiereType) && c === 'Girl Groups') return false;
                    return true;
                });
                chal1 = potential.length > 0 ? potential[Math.floor(Math.random() * potential.length)] : 'Talent Show';
            } else {
                chal1 = opener;
            }
            usedCount[chal1] = (usedCount[chal1] || 0) + 1;
            state.lastChallengeType = CHALLENGE_DEFINITIONS[chal1]?.type;
            state.lastChallenge = chal1;
            return chal1;
        }

        const allChallenges = Object.keys(CHALLENGE_DEFINITIONS);
        let candidates = [];
        const isValid = (chal, strictPhase = true) => {
            const def = CHALLENGE_DEFINITIONS[chal];
            const count = usedCount[chal] || 0;
            
            if (def.oneTime && count > 0) return false;
            if (!def.repeatable && count > 0 && !def.oneTime) return false;
            if (chal === lastChal) return false;

            if (chal === 'Girl Groups' && (currentCount === 7 || currentCount === 5)) return false;

            if (strictPhase && def.allowedPhases) {
                if (!def.allowedPhases.includes(currentPhase)) return false;
            }

            return true;
        };

        candidates = allChallenges.filter(c => isValid(c, true));

        if (candidates.length === 0) {
            candidates = allChallenges.filter(c => isValid(c, false));
        }

        let nextPhase = currentPhase;
        const nextCount = Math.max(1, startCount - epNum);
        const nextPercent = nextCount / startCount;
        if (nextPercent > 0.70) nextPhase = 'early';
        else if (nextPercent < 0.45) nextPhase = 'late';
        else nextPhase = 'mid';

        const critical = candidates.filter(c => {
            const def = CHALLENGE_DEFINITIONS[c];
            if (!def.required || (usedCount[c] || 0) > 0) return false;
            if (def.allowedPhases && def.allowedPhases.includes(currentPhase) && !def.allowedPhases.includes(nextPhase)) {
                return true;
            }
            
            return false;
        });

        if (critical.length > 0) {
            const picked = critical[Math.floor(Math.random() * critical.length)];
            usedCount[picked] = (usedCount[picked] || 0) + 1;
            state.lastChallengeType = CHALLENGE_DEFINITIONS[picked].type;
            state.lastChallenge = picked;
            return picked;
        }
        let weightedPool = [];
        
        candidates.forEach(c => {
            const def = CHALLENGE_DEFINITIONS[c];
            let weight = def.priority || 5;
            if (def.required && (usedCount[c] || 0) === 0) {
                weight += 20; 
            }
            if (lastType && def.type === lastType) {
                weight = 0.1; 
            }
            const w = Math.max(1, Math.round(weight));
            for(let i=0; i<w; i++) weightedPool.push(c);
        });

        if (weightedPool.length === 0) {
            return 'Design'; 
        }

        const selected = weightedPool[Math.floor(Math.random() * weightedPool.length)];
        usedCount[selected] = (usedCount[selected] || 0) + 1;
        state.lastChallengeType = CHALLENGE_DEFINITIONS[selected].type;
        state.lastChallenge = selected;
        return selected;
    }
    function getQueenSeason(name) {
        const queen = queensDb[name];
        if (!queen) return '';
        if (queen.seasons && queen.seasons.length > 0) return queen.seasons[0];
        
        // Fallback: try to parse from photo URL if seasons data is missing
        return getSeasonLabelFromPhoto(queen.photo);
    }

    function getSeasonLabelFromPhoto(photo) {
        const p = String(photo || '');
        
        // Try to parse using regex patterns
        const matchS = p.match(/S(\d+)CastMug/);
        if (matchS) return `US S${matchS[1]}`;
        
        const matchAS = p.match(/AS(\d+)CastMug/);
        if (matchAS) return `US AS${matchAS[1]}`;
        
        const matchCDR = p.match(/CDR(\d+)CastMug/);
        if (matchCDR) return `CDR ${matchCDR[1]}`;
        
        const matchDRUK = p.match(/DRUK(\d+)CastMug/);
        if (matchDRUK) return `UK ${matchDRUK[1]}`;

        const matchUK = p.match(/UK(\d+)CastMug/);
        if (matchUK) return `UK ${matchUK[1]}`;
        
        const matchUKvsTW = p.match(/UKvsTW(\d+)CastMug/);
        if (matchUKvsTW) return `UKvsTW${matchUKvsTW[1]}`;
        
        const matchCAvsTW = p.match(/CAvsTW(\d+)CastMug/);
        if (matchCAvsTW) return `CAvsTW${matchCAvsTW[1]}`;

        const matchGAS = p.match(/GAS(\d+)CastMug/);
        if (matchGAS) return `GAS ${matchGAS[1]}`;
        
        const matchTitans = p.match(/Titans(\d+)CastMug/);
        if (matchTitans) return `Titans ${matchTitans[1]}`;

        return '';
    }

    function addQueenFromSearch(name) {
        if (selectedQueens.length >= MAX_CAST) {
            showToast(`Max cast size is ${MAX_CAST} queens.`, 'error');
            return;
        }
        if (!selectedQueens.includes(name)) selectedQueens.push(name);
        const input = document.getElementById('queenSearchInput');
        if (input) input.value = '';
        renderQueensGrid();
    }



    function renderQueensGrid() {
        const grid = document.getElementById('queensGrid');
        if (!grid) return;

        const selectedGrid = document.getElementById('selectedQueensGrid');
        const input = document.getElementById('queenSearchInput');
        const query = (input?.value || '').trim().toLowerCase();
        const resultsEl = document.getElementById('queenSearchResults');
        const countEl = document.getElementById('selectedCount');
        const yourCastCountEl = document.getElementById('yourCastCount');
        const totalEl = document.getElementById('totalQueensCount');
        const browsePanel = document.getElementById('browseQueensPanel');
        const browseChevron = document.getElementById('browseQueensChevron');

        if (totalEl) totalEl.textContent = String(queenNames.length);
        if (countEl) countEl.textContent = `${selectedQueens.length} queens`;
        if (yourCastCountEl) yourCastCountEl.textContent = String(selectedQueens.length);

        updateStartButtonState();
        updateReturnFormatAvailability();

        if (selectedGrid) {
            selectedGrid.innerHTML = selectedQueens.map(q => {
                const safe = q.replace(/'/g, "\\'").replace(/"/g, '&quot;');
                return `
                    <button type="button" onclick="toggleQueen('${safe}')" class="inline-flex items-center gap-2 rounded-full bg-pink-100 text-pink-700 px-3 py-1.5 text-xs font-bold hover:bg-pink-200 transition">
                        <img src="${queensDb[q].photo}" alt="" class="w-5 h-5 rounded-full object-cover">
                        <span class="leading-none">${q}</span>
                    </button>`;
            }).join('');
        }

        if (resultsEl) {
            if (!query) {
                resultsEl.classList.add('hidden');
                resultsEl.innerHTML = '';
            } else {
                const matches = queenNames.filter(q => q.toLowerCase().includes(query)).slice(0, 12);
                resultsEl.classList.remove('hidden');
                if (!matches.length) {
                    resultsEl.innerHTML = `<div class="px-4 py-3 text-sm font-bold text-gray-400">No matches</div>`;
                } else {
                    resultsEl.innerHTML = matches.map(q => {
                        const safe = q.replace(/'/g, "\\'").replace(/"/g, '&quot;');
                        const selected = selectedQueens.includes(q);
                        const qData = queensDb[q];
                        const season = getQueenSeason(q);
                        const action = selected ? 'Added' : '+ Add';
                        const actionClass = selected ? 'text-gray-300' : 'text-pink-600';
                        const onRow = selected ? '' : `onclick="addQueenFromSearch('${safe}')"`;
                        const onAdd = selected ? '' : `onclick="addQueenFromSearch('${safe}'); event.stopPropagation();"`;
                        const rowClass = selected ? '' : 'cursor-pointer hover:bg-gray-50';
                        return `
                            <div ${onRow} class="flex items-center justify-between px-4 py-2 ${rowClass}">
                                <div class="flex items-center gap-3 min-w-0">
                                    <img src="${queensDb[q].photo}" alt="" class="w-10 h-10 rounded-full object-cover flex-none">
                                    <div class="min-w-0">
                                        <div class="text-sm font-bold text-gray-900 truncate">${q}</div>
                                        <div class="text-xs font-bold text-gray-400 truncate">${season}</div>
                                    </div>
                                </div>
                                <button type="button" ${onAdd} class="text-sm font-bold ${actionClass} hover:opacity-80 disabled:opacity-50" ${selected ? 'disabled' : ''}>${action}</button>
                            </div>`;
                    }).join('');
                }
            }
        }

        const open = browseQueensOpen;
        if (browsePanel) browsePanel.classList.toggle('hidden', !open);
        if (browseChevron) browseChevron.style.transform = open ? 'rotate(180deg)' : '';

        if (!open) {
            grid.classList.add('hidden');
            grid.innerHTML = '';
            return;
        }

        grid.classList.remove('hidden');
        const list = query ? queenNames.filter(q => q.toLowerCase().includes(query)) : queenNames;
        grid.innerHTML = list.map(q => {
            const safe = q.replace(/'/g, "\\'").replace(/"/g, '&quot;');
            const selected = selectedQueens.includes(q);
            return `
                <div onclick="toggleQueen('${safe}')" class="cursor-pointer p-2 rounded-xl border flex flex-col items-center gap-1 ${selected ? 'border-pink-300 bg-pink-50' : 'border-gray-200 bg-white hover:bg-gray-50'}">
                    <img src="${queensDb[q].photo}" alt="" class="w-10 h-10 rounded-full object-cover">
                    <span class="text-[10px] font-bold text-center leading-tight text-gray-800">${q}</span>
                </div>`;
        }).join('');
    }

    function toggleBrowseQueens() {
        browseQueensOpen = !browseQueensOpen;
        renderQueensGrid();
    }

    function applyCastPreset(preset) {
        const hasSeason = (name, season) => {
            const seasons = queensDb[name] && Array.isArray(queensDb[name].seasons) ? queensDb[name].seasons : [];
            return seasons.includes(season);
        };
        
        const presetMap = {
            us18: { season: 'US S18' },
            us17: { season: 'US S17' },
            us16: { season: 'US S16' },
            us15: { season: 'US S15' },
            us14: { season: 'US S14' },
            us13: { season: 'US S13' },
            us9: { season: 'US S9' },
            us7: { season: 'US S7' },
            us6: { season: 'US S6' },
            us5: { season: 'US S5' },
            us4: { season: 'US S4' },
            cdr6: { season: 'CDR S6' },
            cdr1: { season :'CDR S1'},
            uk7: { season: 'UK 7' },
            uk6: { season: 'UK 6' },
            uk5: { season: 'UK 5' },
            UKvsTW3: { season: 'UKvsTW3' }
        };

        const cfg = presetMap[preset];
        if (cfg) {
            selectedQueens = queenNames.filter(q => hasSeason(q, cfg.season));
        }
        renderQueensGrid();
    }

    function toggleQueen(name) {
        selectedQueens.includes(name) ? selectedQueens = selectedQueens.filter(q => q !== name) : selectedQueens.push(name);
        renderQueensGrid();
    }
    function addRandomQueen() {
        if (selectedQueens.length >= MAX_CAST) {
            showToast(`Max cast size is ${MAX_CAST} queens.`, 'error');
            return;
        }
        const pool = queenNames.filter(q => !selectedQueens.includes(q));
        if (!pool.length) return;
        const picked = pool[Math.floor(Math.random() * pool.length)];
        selectedQueens.push(picked);
        renderQueensGrid();
    }
    function selectAll() { selectedQueens = [...queenNames]; renderQueensGrid(); }
    function deselectAll() { selectedQueens = []; renderQueensGrid(); }
    function toggleSeasonMode() {
        const seasonMode = getSelectedSeasonMode();
        const regularOptions = document.getElementById('regularOptions');
        if (regularOptions) {
            const showFinaleOptions = seasonMode !== 'tournament';
            regularOptions.style.display = showFinaleOptions ? 'block' : 'none';
        }
        const premiereOptions = document.getElementById('premiereOptions');
        if (premiereOptions) {
            const showPremiereOptions = seasonMode !== 'tournament';
            premiereOptions.style.display = showPremiereOptions ? 'block' : 'none';
            if (!showPremiereOptions) {
                setPremiereType('normal');
            }
        }

        // Hide Lucky Queen Twist for All Stars and Tournament
        const luckyQueenContainer = document.getElementById('luckyQueenTwistContainer');
        const luckyQueenCheckbox = document.getElementById('luckyQueenTwist');
        if (luckyQueenContainer && luckyQueenCheckbox) {
            const isSupported = (seasonMode === 'regular' || seasonMode === 'beaver');
            luckyQueenContainer.style.display = isSupported ? 'block' : 'none';
            if (!isSupported) {
                luckyQueenCheckbox.checked = false;
                luckyQueenTwist = false;
            }
        }

        updateStartButtonState();
        updateReturnFormatAvailability();
    }

    function openDoublePremierePanel() {
        doublePremiereEp1Cast = [];
        renderDoublePremiereGrid();
        updateDoublePremiereCount();
    }

    function renderDoublePremiereGrid() {
        const grid = document.getElementById('doublePremiereGrid');
        if (!grid) return;
        grid.innerHTML = selectedQueens.map(q => `
            <div onclick="toggleDoublePremiereQueen('${q.replace(/'/g, "\\'").replace(/"/g, '&quot;')}')" class="cursor-pointer p-2 rounded-xl border-2 flex flex-col items-center gap-1 ${doublePremiereEp1Cast.includes(q) ? 'border-pink-400 bg-pink-100/70' : 'border-transparent bg-gray-50'}">
                <img src="${queensDb[q].photo}" class="w-10 h-10 rounded-full object-cover border-2 border-white shadow">
                <span class="text-[10px] font-bold text-center leading-tight text-gray-800">${q}</span>
            </div>`).join('');
    }

    function updateDoublePremiereCount() {
        const label = document.getElementById('doublePremiereCount');
        if (!label) return;
        const total = selectedQueens.length;
        const target = Math.ceil(total / 2);
        label.innerText = `${doublePremiereEp1Cast.length} queens for Episode 1 (needs ${target})`;
    }

    function toggleDoublePremiereQueen(name) {
        if (doublePremiereEp1Cast.includes(name)) {
            doublePremiereEp1Cast = doublePremiereEp1Cast.filter(q => q !== name);
        } else {
            doublePremiereEp1Cast.push(name);
        }
        renderDoublePremiereGrid();
        updateDoublePremiereCount();
    }

    function randomDoublePremiereSelection() {
        const total = selectedQueens.length;
        const count = Math.ceil(total / 2);
        const shuffled = [...selectedQueens].map(q => ({ q, r: Math.random() })).sort((a, b) => a.r - b.r).map(x => x.q);
        doublePremiereEp1Cast = shuffled.slice(0, count);
        renderDoublePremiereGrid();
        updateDoublePremiereCount();
    }

    function backFromDoublePremiere() {
        document.getElementById('doublePremierePanel').classList.add('hidden');
        const panel = document.getElementById('openerPickerPanel');
        panel.classList.remove('hidden');
        panel.style.display = '';
    }

    function confirmDoublePremiereAndContinue() {
        if (selectedQueens.length > MAX_CAST) {
            showToast(`Max cast size is ${MAX_CAST} queens.`, 'error');
            return;
        }
        const total = selectedQueens.length;
        const required = Math.ceil(total / 2);
        if (doublePremiereEp1Cast.length !== required) {
            showToast(`You need to select exactly ${required} queens for the first episode.`, 'error');
            return;
        }
        const set = new Set(doublePremiereEp1Cast);
        doublePremiereEp1Cast = [...doublePremiereEp1Cast];
        doublePremiereEp2Cast = selectedQueens.filter(q => !set.has(q));
        
        document.getElementById('doublePremierePanel').classList.add('hidden');
        
        const seasonMode = getSelectedSeasonMode();
        const isSupported = (seasonMode === 'regular' || seasonMode === 'beaver');
        const isLuckyQueen = document.getElementById('luckyQueenTwist') ? document.getElementById('luckyQueenTwist').checked : false;
        
        if (isSupported && isLuckyQueen) {
            openLuckyQueenPanel();
            return;
        }

        const minForRelationships = (seasonMode === 'allstars' || seasonMode === 'tournament') ? 6 : 4;
        if (selectedQueens.length >= minForRelationships) {
            openPersonalityPanel();
        } else {
            generateSeason();
        }
    }

    function openLuckyQueenPanel() {
        const panel = document.getElementById('luckyQueenPanel');
        if (panel) {
            panel.classList.remove('hidden');
            renderLuckyQueenSelection();
            updateLuckyQueenStepIndicators();
        }
    }

    function backFromLuckyQueenPanel() {
        document.getElementById('luckyQueenPanel').classList.add('hidden');
        if (premiereType === 'double' || premiereType === 'double_elim' || premiereType === 'split') {
            document.getElementById('doublePremierePanel').classList.remove('hidden');
        } else {
            const panel = document.getElementById('openerPickerPanel');
            panel.classList.remove('hidden');
            panel.style.display = '';
        }
    }

    function confirmLuckyQueenAndContinue() {
        document.getElementById('luckyQueenPanel').classList.add('hidden');
        const seasonMode = getSelectedSeasonMode();
        const minForRelationships = (seasonMode === 'allstars' || seasonMode === 'tournament') ? 6 : 4;
        if (selectedQueens.length >= minForRelationships) {
            openPersonalityPanel();
        } else {
            generateSeason();
        }
    }

    function renderLuckyQueenSelection() {
        const grid = document.getElementById('luckyQueenGrid');
        if (!grid) return;
        
        // Validate selectedLuckyQueen is in cast
        if (selectedLuckyQueen && !selectedQueens.includes(selectedLuckyQueen)) {
            selectedLuckyQueen = null;
        }

        grid.innerHTML = selectedQueens.map(q => {
            const isSelected = selectedLuckyQueen === q;
            return `
            <div onclick="toggleLuckyQueen('${q.replace(/'/g, "\\'").replace(/"/g, '&quot;')}')" class="relative cursor-pointer p-2 rounded-xl border-2 flex flex-col items-center gap-1 ${isSelected ? 'border-pink-400 bg-pink-100/70' : 'border-transparent bg-gray-50'}">
                <img src="${queensDb[q].photo}" class="w-10 h-10 rounded-full object-cover border-2 border-white shadow">
                <span class="text-[10px] font-bold text-center leading-tight text-gray-800">${q}</span>
                ${isSelected ? `
                <div class="absolute top-1 right-1 bg-[#ec4899] text-white rounded-full p-0.5 shadow-sm">
                    <svg xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"/></svg>
                </div>
                ` : ''}
            </div>`;
        }).join('');
    }

    function toggleLuckyQueen(name) {
        if (selectedLuckyQueen === name) {
            selectedLuckyQueen = null;
        } else {
            selectedLuckyQueen = name;
        }
        renderLuckyQueenSelection();
    }

    function setRandomLuckyQueen() {
        if (selectedQueens.length === 0) return;
        const random = selectedQueens[Math.floor(Math.random() * selectedQueens.length)];
        selectedLuckyQueen = random;
        renderLuckyQueenSelection();
        confirmLuckyQueenAndContinue();
    }

    function toggleLuckyQueenSelect() {
        const checkbox = document.getElementById('luckyQueenTwist');
        if (checkbox) {
            luckyQueenTwist = checkbox.checked;
            updatePreSimStepIndicators();
        }
    }

    function updateLuckyQueenStepIndicators() {
        updatePreSimStepIndicators();
    }



    function chooseLipsticks(top2, bottom, stats, relationships, untuckedInfluences) {
        const choices = {};
        const rels = relationships || {};
        top2.forEach(queen => {
            const personality = getPersonalityForQueen(queen.name);
            const scored = bottom.map(entry => {
                const name = entry.name;
                const st = stats[name] || {};
                const ppe = st.ppe || 0;
                const perf = entry.total || 0;
                const relKey = getRelationshipKey(queen.name, name);
                const relType = rels[relKey] || DEFAULT_RELATIONSHIP;
                const relScore = getRelationshipStrength(relType);
                const episodesCount = st.episodesCount || 0;
                const isFirstEpisode = episodesCount <= 1;
                let saveScore = 0;
                if (personality === 'fair') {
                    if (isFirstEpisode) saveScore += perf;
                    else saveScore += ppe * 2;
                    saveScore += relScore * 2;
                    saveScore += Math.random() * 0.3;
                } else if (personality === 'strategy') {
                    saveScore -= ppe * 2;
                    saveScore += relScore * 2.5;
                    saveScore += Math.random() * 0.3;
                } else if (personality === 'loyal') {
                    saveScore += relScore * 3;
                    saveScore += Math.random() * 0.5;
                } else if (personality === 'chaos') {
                    saveScore += (Math.random() * 2 - 1);
                    saveScore += relScore * 0.3;
                    saveScore += (Math.random() - 0.5) * 0.5;
                } else {
                    saveScore += ppe;
                    saveScore += relScore;
                }
                return { name, relType, saveScore };
            });
            const nonFamily = scored.filter(s => s.relType !== 'drag_family');
            const pool = nonFamily.length ? nonFamily : scored;
            pool.sort((a, b) => a.saveScore - b.saveScore);
            const pick = pool[0];
            choices[queen.name] = pick ? pick.name : (bottom[0] ? bottom[0].name : null);
        });
        return choices;
    }

    function simulateDoublePremiereAllStarsEpisode(groupCast, chal, epNumber, stats, recentWins, remainingCount, relationships, scoreMode, relationshipTension) {
        const hasRunway = hasRunwayForChallenge(chal);
        const scores = groupCast.map(q => {
            const queen = queensDb[q];
            const challengeStats = challengeConfig[chal];
            const base = challengeStats.reduce((acc, s) => acc + queen[s], 0) / challengeStats.length;
            const challengeTotal = base;

            const randomForChallenge = Math.random() * 5 - 2.5;
            const randomForRunway = hasRunway ? (Math.random() * 5 - 2.5) : 0;
            const randomTotal = 0;

            const challengeWithRandom = challengeTotal + randomForChallenge;

            let desc = "Safe";
            let statusClass = "perf-safe";
            if (challengeWithRandom > 12) { desc = "SLAYED!"; statusClass = "perf-slay"; }
            else if (challengeWithRandom > 8) { desc = "Great job"; statusClass = "perf-good"; }
            else if (challengeWithRandom > 6) { desc = "Okay"; statusClass = "perf-safe"; }
            else if (challengeWithRandom > 4) { desc = "Struggled"; statusClass = "perf-bad"; }
            else { desc = "FLOP"; statusClass = "perf-flop"; }
            let runwayTotal = 0;
            let runwayDesc = "";
            let runwayStatusClass = "";
            let runwayWithRandom = 0;
            let runwayDetails = "";
            if (hasRunway) {
                const fashionBase = queen.fashion;
                runwayTotal = fashionBase;
                runwayWithRandom = runwayTotal + randomForRunway;

                if (runwayWithRandom > 12) { runwayDesc = "SLAYED!"; runwayStatusClass = "perf-slay"; }
                else if (runwayWithRandom > 8) { runwayDesc = "Great job"; runwayStatusClass = "perf-good"; }
                else if (runwayWithRandom > 6) { runwayDesc = "Okay"; runwayStatusClass = "perf-safe"; }
                else if (runwayWithRandom > 4) { runwayDesc = "Struggled"; runwayStatusClass = "perf-bad"; }
                else { runwayDesc = "FLOP"; runwayStatusClass = "perf-flop"; }
                runwayDetails = `(${runwayWithRandom.toFixed(1)})`;
            }

            const challengeWeighted = hasRunway ? challengeWithRandom * 0.8 : challengeWithRandom;
            const runwayWeighted = hasRunway ? runwayWithRandom * 0.2 : 0;
            const totalBase = challengeWeighted + runwayWeighted;

            const lastPlacement = stats && stats[q] ? stats[q].lastPlacement : null;
            let winModifier = 0;
            {
                const consWins = (stats && stats[q]) ? (stats[q].consecutiveWins || 0) : 0;
                const consHighs = (stats && stats[q]) ? (stats[q].consecutiveHighs || 0) : 0;
                if (consWins > 0) {
                    winModifier = -1.25 - ((consWins - 1) * 0.5);
                } else if (consHighs > 0) {
                    winModifier = -0.5 - ((consHighs - 1) * 0.25);
                }
            }
            
            const total = challengeWeighted + runwayWeighted + randomTotal + winModifier;
            return {
                name: q,
                total,
                totalBase,
                challengeTotal: challengeWithRandom,
                runwayTotal: runwayWithRandom,
                challengeWeighted,
                runwayWeighted,
                randomTotal,
                winModifier,
                desc,
                statusClass,
                runwayDesc,
                runwayStatusClass,
                details: `(${challengeWithRandom.toFixed(1)})`,
                runwayDetails: hasRunway ? `(${runwayWithRandom.toFixed(1)})` : ''
            };
        }).sort((a, b) => b.total - a.total);

        const top2 = scores.slice(0, Math.min(2, scores.length));
        const buckets = getDoublePremiereBuckets(scores, top2, 'total');
        const high = buckets.high;
        const safe = buckets.safe;
        const low = buckets.low;

        const ls1 = calcLipSyncScore(top2[0].name, 'allstars_top2', stats);
        const ls2 = calcLipSyncScore(top2[1].name, 'allstars_top2', stats);
        const lipSyncWinner = ls1.score >= ls2.score ? top2[0].name : top2[1].name;
        const lipSyncLoser = top2.find(w => w.name !== lipSyncWinner).name;
        const lipSyncTop2 = [ls1, ls2];
        const mode = scoreMode || 'classic';
        const rels = relationships || {};
        let pointGifts = [];
        let untuckedScenes = [];

        if (mode === 'tournament') {
            const allNames = scores.map(s => s.name);
            const top2Names = top2.map(t => t.name);
            const givers = allNames.filter(n => !top2Names.includes(n));

            const perfByName = {};
            scores.forEach(s => { perfByName[s.name] = (s && typeof s.total === 'number') ? s.total : 0; });

            const giftsReceived = {};
            const usedRecipients = new Set();

            const scoreTarget = (giver, target) => {
                const personality = getPersonalityForQueen(giver);
                const relType = rels[getRelationshipKey(giver, target)] || DEFAULT_RELATIONSHIP;
                const relScore = getRelationshipStrength(relType);
                const perf = perfByName[target] ?? 0;
                let score = perf;
                if (personality === 'loyal') score += relScore * 8;
                else if (personality === 'strategy') score += relScore * 5;
                else if (personality === 'fair') score += relScore * 3;
                else score += relScore * 2;
                return score;
            };

            const pickSoftmax = (arr, temperature) => {
                if (!arr || !arr.length) return null;
                const t = Math.max(0.12, temperature || 1);
                let max = -Infinity;
                for (let i = 0; i < arr.length; i++) {
                    const v = Number(arr[i] && arr[i].score);
                    if (isFinite(v) && v > max) max = v;
                }
                let sum = 0;
                const weights = new Array(arr.length);
                for (let i = 0; i < arr.length; i++) {
                    const v = Number(arr[i] && arr[i].score);
                    const w = Math.exp(((isFinite(v) ? v : -Infinity) - max) / t);
                    weights[i] = w;
                    sum += w;
                }
                if (!(sum > 0) || !isFinite(sum)) return arr[Math.floor(Math.random() * arr.length)].to;
                let r = Math.random() * sum;
                for (let i = 0; i < weights.length; i++) {
                    r -= weights[i];
                    if (r <= 0) return arr[i].to;
                }
                return arr[arr.length - 1].to;
            };

            const pickRecipient = (giver, candidates) => {
                const personality = getPersonalityForQueen(giver);
                const epsilon = personality === 'chaos' ? 0.35 : (personality === 'loyal' ? 0.08 : 0.15);
                if (Math.random() < epsilon) return candidates[Math.floor(Math.random() * candidates.length)];

                const avoidUsedChance = personality === 'chaos' ? 0.35 : (personality === 'loyal' ? 0.60 : 0.70);
                const pool = (Math.random() < avoidUsedChance)
                    ? candidates.filter(to => !usedRecipients.has(to))
                    : candidates;
                const finalPool = pool.length ? pool : candidates;

                const crowdPenalty = 2.2;
                const scored = finalPool.map(to => {
                    const crowd = giftsReceived[to] || 0;
                    return { to, score: scoreTarget(giver, to) - crowd * crowdPenalty };
                }).sort((a, b) => b.score - a.score);

                const temperature = personality === 'loyal' ? 0.6 : (personality === 'strategy' ? 0.9 : (personality === 'fair' ? 1.0 : 1.4));
                return pickSoftmax(scored, temperature);
            };

            givers.forEach(from => {
                const personality = getPersonalityForQueen(from);
                const TOP2_GIFT_CHANCE = personality === 'chaos' ? 0.12 : 0.04;
                const allowTop2 = Math.random() < TOP2_GIFT_CHANCE;
                const candidates = allNames.filter(n => n !== from && (allowTop2 || !top2Names.includes(n)));
                if (!candidates.length) return;
                const to = pickRecipient(from, candidates);
                if (!to) return;
                giftsReceived[to] = (giftsReceived[to] || 0) + 1;
                usedRecipients.add(to);
                pointGifts.push({ from, to, personality });
            });
        }

        if (relationshipTension) {
            const bottomTmp = [];
            if (low && low.length) {
                low.forEach(q => bottomTmp.push(q));
            } else if (safe && safe.length) {
                const last = safe[safe.length - 1];
                const prev = safe.length > 1 ? safe[safe.length - 2] : null;
                if (last) bottomTmp.push(last);
                if (prev) bottomTmp.push(prev);
            } else if (scores.length >= 2) {
                bottomTmp.push(scores[scores.length - 1], scores[scores.length - 2]);
            }
            const untucked = generateUntucked(top2, bottomTmp, high, safe, low, stats, relationships, relationshipTension);
            untuckedScenes = untucked.scenes || [];
        }

        scores.forEach(s => {
            const name = s.name;
            const st = stats[name];
            const isTop2 = top2.some(w => w.name === name);
            let points = 0;
            let placement = null;
            if (isTop2) {
                if (mode === 'tournament') {
                    if (name === lipSyncWinner) { st.wins++; points = 3; placement = 'WIN'; }
                    else { st.wins++; points = 2; placement = 'HIGH'; }
                } else {
                    if (name === lipSyncWinner) { st.wins++; points = 5; placement = 'WIN'; }
                    else { st.wins++; points = GAME_CONSTANTS.POINTS.ALLSTARS_LIPSYNC_LOSER; placement = 'HIGH'; }
                }
            } else if (high.find(h => h.name === name)) {
                st.highs++;
                points = mode === 'tournament' ? 0 : 4;
                placement = 'HIGH';
            } else if (safe.find(x => x.name === name)) {
                st.safe++;
                points = mode === 'tournament' ? 0 : 3;
                placement = 'SAFE';
            } else if (low.find(l => l.name === name)) {
                st.lows++;
                points = mode === 'tournament' ? 0 : 2;
                placement = 'LOW';
            }
            if (mode === 'tournament' && pointGifts.length) {
                points += pointGifts.filter(g => g.to === name).length;
            }
            st.totalPoints += points;
            st.episodesCount++;
            st.ppe = st.totalPoints / st.episodesCount;
            if (placement === 'WIN' || isTop2) {
                st.consecutiveWins = (st.consecutiveWins || 0) + 1;
                st.consecutiveHighs = 0;
            } else if (placement === 'HIGH') {
                st.consecutiveHighs = (st.consecutiveHighs || 0) + 1;
                st.consecutiveWins = 0;
            } else {
                st.consecutiveWins = 0;
                st.consecutiveHighs = 0;
            }
            st.lastPlacement = placement;
        });

        return {
            episode: epNumber,
            challenge: chal,
            scores,
            winners: top2,
            high,
            safe,
            low,
            bottom: [],
            top2,
            lipSyncTop2,
            pointGifts,
            lipstickChoices: {},
            lipSyncWinner,
            lipSyncLoser,
            eliminated: [],
            untucked: untuckedScenes,
            revealLoserLipstick: false,
            loserLipstick: null,
            sameLipstick: false,
            remainingCount,
            isAllStars: true,
            isFinale: false,
            isDoubleWin: false,
            isDoublePremiere: true,
            isPremiere: true,
            hasRunway
        };
    }

    function simulateDoublePremiereAllStarsEpisodeElim(groupCast, chal, epNumber, stats, recentWins, remainingCount, relationships, scoreMode, relationshipTension) {
        const hasRunway = hasRunwayForChallenge(chal);
        const scores = groupCast.map(q => {
            const queen = queensDb[q];
            const challengeStats = challengeConfig[chal];
            const base = challengeStats.reduce((acc, s) => acc + queen[s], 0) / challengeStats.length;
            const challengeTotal = base;

            const randomForChallenge = Math.random() * 5 - 2.5;
            const randomForRunway = hasRunway ? (Math.random() * 5 - 2.5) : 0;
            const randomTotal = 0;

            const challengeWithRandom = challengeTotal + randomForChallenge;

            let desc = "Safe";
            let statusClass = "perf-safe";
            if (challengeWithRandom > 12) { desc = "SLAYED!"; statusClass = "perf-slay"; }
            else if (challengeWithRandom > 8) { desc = "Great job"; statusClass = "perf-good"; }
            else if (challengeWithRandom > 6) { desc = "Okay"; statusClass = "perf-safe"; }
            else if (challengeWithRandom > 4) { desc = "Struggled"; statusClass = "perf-bad"; }
            else { desc = "FLOP"; statusClass = "perf-flop"; }
            let runwayTotal = 0;
            let runwayDesc = "";
            let runwayStatusClass = "";
            let runwayWithRandom = 0;
            let runwayDetails = "";
            if (hasRunway) {
                const fashionBase = queen.fashion;
                runwayTotal = fashionBase;
                runwayWithRandom = runwayTotal + randomForRunway;

                if (runwayWithRandom > 12) { runwayDesc = "SLAYED!"; runwayStatusClass = "perf-slay"; }
                else if (runwayWithRandom > 8) { runwayDesc = "Great job"; runwayStatusClass = "perf-good"; }
                else if (runwayWithRandom > 6) { runwayDesc = "Okay"; runwayStatusClass = "perf-safe"; }
                else if (runwayWithRandom > 4) { runwayDesc = "Struggled"; runwayStatusClass = "perf-bad"; }
                else { runwayDesc = "FLOP"; runwayStatusClass = "perf-flop"; }
                runwayDetails = `(${runwayWithRandom.toFixed(1)})`;
            }

            const challengeWeighted = hasRunway ? challengeWithRandom * 0.8 : challengeWithRandom;
            const runwayWeighted = hasRunway ? runwayWithRandom * 0.2 : 0;
            const totalBase = challengeWeighted + runwayWeighted;

            const lastPlacement = stats && stats[q] ? stats[q].lastPlacement : null;
            let winModifier = 0;
            {
                const consWins = (stats && stats[q]) ? (stats[q].consecutiveWins || 0) : 0;
                const consHighs = (stats && stats[q]) ? (stats[q].consecutiveHighs || 0) : 0;
                if (consWins > 0) {
                    winModifier = -1.25 - ((consWins - 1) * 0.5);
                } else if (consHighs > 0) {
                    winModifier = -0.5 - ((consHighs - 1) * 0.25);
                }
            }
            const total = totalBase + randomTotal + winModifier;
            return {
                name: q,
                total,
                totalBase,
                challengeTotal: challengeWithRandom,
                runwayTotal: runwayWithRandom,
                challengeWeighted,
                runwayWeighted,
                randomTotal,
                winModifier,
                desc,
                statusClass,
                runwayDesc,
                runwayStatusClass,
                details: `(${challengeWithRandom.toFixed(1)})`,
                runwayDetails: hasRunway ? `(${runwayWithRandom.toFixed(1)})` : ''
            };
        }).sort((a, b) => b.total - a.total);

        const top2 = scores.slice(0, Math.min(2, scores.length));
        const buckets = getDoublePremiereBuckets(scores, top2, 'total');
        let high = buckets.high;
        let safe = buckets.safe;
        let low = buckets.low;
        let bottom = [];

        const ls1 = calcLipSyncScore(top2[0].name, 'allstars_top2', stats);
        const ls2 = calcLipSyncScore(top2[1].name, 'allstars_top2', stats);
        const lipSyncWinner = ls1.score >= ls2.score ? top2[0].name : top2[1].name;
        const lipSyncLoser = top2.find(w => w.name !== lipSyncWinner).name;
        const lipSyncTop2 = [ls1, ls2];
        const mode = scoreMode || 'classic';
        const rels = relationships || {};
        let pointGifts = [];
        let untuckedScenes = [];
        let lipstickChoices = {};
        let eliminated = [];
        let loserTop2 = lipSyncLoser;
        let sameLipstick = false;
        let elimReasons = null;

        if (mode === 'tournament') {
            const allNames = scores.map(s => s.name);
            const top2Names = top2.map(t => t.name);
            const givers = allNames.filter(n => !top2Names.includes(n));

            const perfByName = {};
            scores.forEach(s => { perfByName[s.name] = (s && typeof s.total === 'number') ? s.total : 0; });

            const giftsReceived = {};
            const usedRecipients = new Set();

            const scoreTarget = (giver, target) => {
                const personality = getPersonalityForQueen(giver);
                const relType = rels[getRelationshipKey(giver, target)] || DEFAULT_RELATIONSHIP;
                const relScore = getRelationshipStrength(relType);
                const perf = perfByName[target] ?? 0;

                if (personality === 'loyal') return relScore * 3 + Math.random() * 0.5;
                if (personality === 'strategy') return (-perf) * 3 + relScore * 0.6 + (Math.random() * 0.8 - 0.4);
                if (personality === 'fair') return (perf) * 2.6 + relScore * 0.8 + (Math.random() * 0.8 - 0.4);
                return (Math.random() * 2 - 1) + relScore * 0.3;
            };

            const pickSoftmax = (scored, temperature) => {
                if (!scored.length) return null;
                const t = Math.max(0.25, temperature || 1);
                const max = scored.reduce((m, x) => (x.score > m ? x.score : m), -Infinity);
                let sum = 0;
                const weights = scored.map(x => {
                    const w = Math.exp((x.score - max) / t);
                    sum += w;
                    return w;
                });
                if (sum <= 0 || !isFinite(sum)) return scored[Math.floor(Math.random() * scored.length)].to;
                let r = Math.random() * sum;
                for (let i = 0; i < scored.length; i++) {
                    r -= weights[i];
                    if (r <= 0) return scored[i].to;
                }
                return scored[scored.length - 1].to;
            };

            const pickRecipient = (giver, candidates) => {
                const personality = getPersonalityForQueen(giver);
                const epsilon = personality === 'chaos' ? 0.35 : (personality === 'loyal' ? 0.08 : 0.15);
                if (Math.random() < epsilon) return candidates[Math.floor(Math.random() * candidates.length)];

                const avoidUsedChance = personality === 'chaos' ? 0.35 : (personality === 'loyal' ? 0.60 : 0.70);
                const pool = (Math.random() < avoidUsedChance)
                    ? candidates.filter(to => !usedRecipients.has(to))
                    : candidates;
                const finalPool = pool.length ? pool : candidates;

                const crowdPenalty = 2.2;
                const scored = finalPool.map(to => {
                    const crowd = giftsReceived[to] || 0;
                    return { to, score: scoreTarget(giver, to) - crowd * crowdPenalty };
                }).sort((a, b) => b.score - a.score);

                const temperature = personality === 'loyal' ? 0.6 : (personality === 'strategy' ? 0.9 : (personality === 'fair' ? 1.0 : 1.4));
                return pickSoftmax(scored, temperature);
            };

            givers.forEach(from => {
                const personality = getPersonalityForQueen(from);
                const TOP2_GIFT_CHANCE = personality === 'chaos' ? 0.12 : 0.04;
                const allowTop2 = Math.random() < TOP2_GIFT_CHANCE;
                const candidates = allNames.filter(n => n !== from && (allowTop2 || !top2Names.includes(n)));
                if (!candidates.length) return;
                const to = pickRecipient(from, candidates);
                if (!to) return;
                giftsReceived[to] = (giftsReceived[to] || 0) + 1;
                usedRecipients.add(to);
                pointGifts.push({ from, to, personality });
            });
            if (relationshipTension) {
                const bottomTmp = [];
                if (low && low.length) {
                    low.forEach(q => bottomTmp.push(q));
                } else if (safe && safe.length) {
                    const last = safe[safe.length - 1];
                    const prev = safe.length > 1 ? safe[safe.length - 2] : null;
                    if (last) bottomTmp.push(last);
                    if (prev) bottomTmp.push(prev);
                } else if (scores.length >= 2) {
                    bottomTmp.push(scores[scores.length - 1], scores[scores.length - 2]);
                }
                const untucked = generateUntucked(top2, bottomTmp, high, safe, low, stats, relationships, relationshipTension);
                untuckedScenes = untucked.scenes || [];
            }
        } else {
            const top2Names = new Set(top2.map(t => t.name));
            const nonTop2 = scores.filter(s => !top2Names.has(s.name));
            const bottomCount = groupCast.length <= 5 ? 2 : (Math.random() < 0.25 && scores.length >= 5 ? 3 : 2);
            bottom = nonTop2.slice(-bottomCount);
            const others = scores.filter(s => !top2.find(w => w.name === s.name) && !bottom.find(b => b.name === s.name));
            high = others.slice(0, 2);
            low = others.length > 2 ? [others[others.length - 1]] : [];
            safe = others.filter(s => !high.find(h => h.name === s.name) && !low.find(l => l.name === s.name));
            const untucked = generateUntucked(top2, bottom, high, safe, low, stats, relationships, relationshipTension);
            untuckedScenes = untucked.scenes || [];
            lipstickChoices = chooseLipsticks(top2, bottom, stats, relationships, untucked.influences);
            const chosen = lipstickChoices[lipSyncWinner];
            eliminated = chosen ? [chosen] : [];
            sameLipstick = loserTop2 && chosen ? (lipstickChoices[loserTop2] === chosen) : false;
            if (chosen) {
                const personality = getPersonalityForQueen(lipSyncWinner);
                elimReasons = {};
                elimReasons[chosen] = getAllStarsElimReason(lipSyncWinner, chosen, personality, stats, relationships);
            }
            if (eliminated.length && relationshipTension) {
                const keyElim = getRelationshipKey(lipSyncWinner, eliminated[0]);
                if (!relationshipTension[keyElim]) relationshipTension[keyElim] = 0;
                relationshipTension[keyElim] = Math.min(1, relationshipTension[keyElim] + 0.25);
            }
        }

        scores.forEach(s => {
            const name = s.name;
            const st = stats[name];
            const isTop2 = top2.some(w => w.name === name);
            let points = 0;
            let placement = null;
            if (isTop2) {
                if (mode === 'tournament') {
                    if (name === lipSyncWinner) { st.wins++; points = 3; placement = 'WIN'; }
                    else { st.wins++; points = 2; placement = 'HIGH'; }
                } else {
                    if (name === lipSyncWinner) { st.wins++; points = 5; placement = 'WIN'; }
                    else { st.wins++; points = GAME_CONSTANTS.POINTS.ALLSTARS_LIPSYNC_LOSER; placement = 'HIGH'; }
                }
            } else if (high.find(h => h.name === name)) {
                st.highs++;
                points = mode === 'tournament' ? 0 : 4;
                placement = 'HIGH';
            } else if (safe.find(x => x.name === name)) {
                st.safe++;
                points = mode === 'tournament' ? 0 : 3;
                placement = 'SAFE';
            } else if (low.find(l => l.name === name)) {
                st.lows++;
                points = mode === 'tournament' ? 0 : 2;
                placement = 'LOW';
            } else if (bottom.find(b => b.name === name) && mode !== 'tournament') { 
                st.bottoms++; 
                points = eliminated.includes(name) ? 0 : 1; 
                placement = eliminated.includes(name) ? 'ELIM' : 'BTM';
            }
            if (mode === 'tournament' && pointGifts.length) {
                points += pointGifts.filter(g => g.to === name).length;
            }
            st.totalPoints += points;
            st.episodesCount++;
            st.ppe = st.totalPoints / st.episodesCount;
            if (placement === 'WIN' || isTop2) {
                st.consecutiveWins = (st.consecutiveWins || 0) + 1;
                st.consecutiveHighs = 0;
            } else if (placement === 'HIGH') {
                st.consecutiveHighs = (st.consecutiveHighs || 0) + 1;
                st.consecutiveWins = 0;
            } else {
                st.consecutiveWins = 0;
                st.consecutiveHighs = 0;
            }
            st.lastPlacement = placement;
        });

        const remainingAfter = mode === 'tournament' ? remainingCount : (remainingCount - eliminated.length);

        return {
            episode: epNumber,
            challenge: chal,
            scores,
            winners: top2,
            high,
            safe,
            low,
            bottom,
            top2,
            lipSyncTop2,
            pointGifts,
            lipstickChoices,
            lipSyncWinner,
            lipSyncLoser,
            eliminated: eliminated.length === 1 ? eliminated[0] : eliminated,
            elimReasons: elimReasons,
            untucked: untuckedScenes,
            revealLoserLipstick: mode !== 'tournament' && !sameLipstick && !!(loserTop2 && lipstickChoices[loserTop2]),
            loserLipstick: mode !== 'tournament' ? (loserTop2 ? (lipstickChoices[loserTop2] || null) : null) : null,
            sameLipstick,
            remainingCount: remainingAfter,
            isAllStars: true,
            isFinale: false,
            isDoubleWin: false,
            isDoublePremiere: true,
            isPremiere: true,
            hasRunway
        };
    }

    function generateAllStarsSeason(relationships) {
        const AS_FINALE_SIZE = 2;
        if (selectedQueens.length > MAX_CAST) return showToast(`Max cast size is ${MAX_CAST} queens.`, 'error');
        if (selectedQueens.length < 6) return showToast("All Stars: select at least 6 queens!", 'error');
        const finaleTypeRaw = getSelectedFinaleType();
        const finaleLimit = parseInt(finaleTypeRaw, 10) || 2;
        const finaleFormat = finaleTypeRaw === '4crown' ? 'crown' : 'standard';
        if (selectedQueens.length <= finaleLimit) return showToast("All Stars: select more queens than the finale size (Top " + finaleLimit + ")!", 'error');
        const castAtStart = [...selectedQueens];
        if (!relationships) {
            relationships = {};
            for (let i = 0; i < castAtStart.length; i++) for (let j = i + 1; j < castAtStart.length; j++) relationships[getRelationshipKey(castAtStart[i], castAtStart[j])] = DEFAULT_RELATIONSHIP;
        }

        const stats = {};
        castAtStart.forEach(q => { stats[q] = { wins: 0, highs: 0, safe: 0, lows: 0, bottoms: 0, ppe: 0, totalPoints: 0, episodesCount: 0, consecutiveWins: 0, consecutiveHighs: 0 }; });
        const relationshipTension = {}; 
        let currentCast = [...castAtStart];
        const episodes = [];
        let epNum = 1;
        const recentWins = {};
        const MAX_DOUBLE_WINS = 3;
        let doubleWinCount = 0;
        const opener = (document.querySelector('input[name="seasonOpener"]:checked') || {}).value || 'Random';
        const challengeUsedCount = {};

        const useDoublePremiere = isDoublePremiereType(premiereType) && doublePremiereEp1Cast.length > 0 && doublePremiereEp2Cast.length > 0;

        const selectedReturnFormat = getSelectedReturnFormat();
        const returnEpisode = (selectedReturnFormat === 'choose')
            ? getReturnEpisodeForCast(selectedQueens.length, finaleLimit, premiereType)
            : null;
        const returnPlan = (returnEpisode && selectedQueens.length >= 6) ? { episode: returnEpisode, format: selectedReturnFormat } : null;
        if (useDoublePremiere) {
            const openerChallenge = pickChallengeForEpisode(epNum, challengeUsedCount, opener, false, finaleLimit, castAtStart.length);
            const isElimPremiere = premiereType === 'double_elim';
            let group1 = doublePremiereEp1Cast.filter(q => currentCast.includes(q));
            let group2 = doublePremiereEp2Cast.filter(q => currentCast.includes(q));
            if (group1.length > 0) {
                const ep1 = isElimPremiere
                    ? simulateDoublePremiereAllStarsEpisodeElim(group1, openerChallenge, epNum, stats, recentWins, currentCast.length, relationships, 'classic', relationshipTension)
                    : simulateDoublePremiereAllStarsEpisode(group1, openerChallenge, epNum, stats, recentWins, currentCast.length, relationships, 'classic', relationshipTension);
                episodes.push(ep1);
                if (isElimPremiere) {
                    const elimList = Array.isArray(ep1.eliminated) ? ep1.eliminated : (ep1.eliminated ? [ep1.eliminated] : []);
                    if (elimList.length) {
                        currentCast = currentCast.filter(q => !elimList.includes(q));
                    }
                }
                group2 = group2.filter(q => currentCast.includes(q));
                epNum++;
            }
            if (group2.length > 0) {
                const ep2 = isElimPremiere
                    ? simulateDoublePremiereAllStarsEpisodeElim(group2, openerChallenge, epNum, stats, recentWins, currentCast.length, relationships, 'classic', relationshipTension)
                    : simulateDoublePremiereAllStarsEpisode(group2, openerChallenge, epNum, stats, recentWins, currentCast.length, relationships, 'classic', relationshipTension);
                episodes.push(ep2);
                if (isElimPremiere) {
                    const elimList = Array.isArray(ep2.eliminated) ? ep2.eliminated : (ep2.eliminated ? [ep2.eliminated] : []);
                    if (elimList.length) {
                        currentCast = currentCast.filter(q => !elimList.includes(q));
                    }
                }
                epNum++;
            }
            if (challengeUsedCount.usedCount && challengeUsedCount.usedCount[openerChallenge] !== undefined) {
                challengeUsedCount.usedCount[openerChallenge] += 1;
            }
        }

        while (currentCast.length > finaleLimit) {
            const isPremiereEpisode = false;
            const isLastCompetitiveEp = currentCast.length === finaleLimit + 1;
            const chal = pickChallengeForEpisode(epNum, challengeUsedCount, opener, isLastCompetitiveEp, finaleLimit, castAtStart.length);
            const hasRunway = hasRunwayForChallenge(chal);
            if (returnPlan && epNum === returnPlan.episode) {
                const placeholder = {
                    episode: epNum,
                    challenge: chal,
                    displayChallenge: chal,
                    scores: [],
                    winners: [],
                    top2: [],
                    high: [],
                    safe: [],
                    low: [],
                    bottom: [],
                    eliminated: null,
                    remainingCount: currentCast.length,
                    isFinale: false,
                    isAllStars: true,
                    hasRunway,
                    needsReturnPick: true,
                    returnFormat: returnPlan.format
                };
                episodes.push(placeholder);
                seasonData = {
                    episodes,
                    finale: [],
                    winner: null,
                    queenStats: stats,
                    castQueens: castAtStart,
                    relationships,
                    isAllStars: true,
                    finaleLimit: finaleLimit,
                    returnState: {
                        currentCast: [...currentCast],
                        castAtStart: [...castAtStart],
                        stats,
                        relationships,
                        relationshipTension,
                        recentWins,
                        epNum,
                        finaleLimit,
                        finaleFormat,
                        episodes: [...episodes],
                        challengeUsedCount,
                        opener,
                        returnPlan,
                        doubleWinCount,
                        eliminatedPool: castAtStart.filter(q => !currentCast.includes(q))
                    }
                };
                document.getElementById('setupPanel').classList.add('hidden');
                document.getElementById('scenarioScreen').classList.remove('hidden');
                setHeaderMode('scenario');
                currentEpIndex = 0;
                scenarioPhase = 0;
                renderScenario();
                return;
            }
            const scores = currentCast.map(q => {
                const queen = queensDb[q];
                const challengeStats = challengeConfig[chal];
                const base = challengeStats.reduce((acc, s) => acc + queen[s], 0) / challengeStats.length;
                const challengeTotal = base;
                let desc = "Safe", statusClass = "perf-safe";
                const randomForChallenge = Math.random() * 5 - 2.5;
                const randomForRunway = hasRunway ? (Math.random() * 5 - 2.5) : 0;
                const randomTotal = 0;

                const challengeWithRandom = challengeTotal + randomForChallenge;

                if (challengeWithRandom > 12) { desc = "SLAYED!"; statusClass = "perf-slay"; }
                else if (challengeWithRandom > 8) { desc = "Great job"; statusClass = "perf-good"; }
                else if (challengeWithRandom > 6) { desc = "Okay"; statusClass = "perf-safe"; }
                else if (challengeWithRandom > 4) { desc = "Struggled"; statusClass = "perf-bad"; }
                else { desc = "FLOP"; statusClass = "perf-flop"; }
                let runwayTotal = 0;
                let runwayDesc = "";
                let runwayStatusClass = "";
                let runwayWithRandom = 0;
                let runwayDetails = "";
                if (hasRunway) {
                    const fashionBase = queen.fashion;
                    runwayTotal = fashionBase;
                    runwayWithRandom = runwayTotal + randomForRunway;

                    if (runwayWithRandom > 12) { runwayDesc = "SLAYED!"; runwayStatusClass = "perf-slay"; }
                    else if (runwayWithRandom > 8) { runwayDesc = "Great job"; runwayStatusClass = "perf-good"; }
                    else if (runwayWithRandom > 6) { runwayDesc = "Okay"; runwayStatusClass = "perf-safe"; }
                    else if (runwayWithRandom > 4) { runwayDesc = "Struggled"; runwayStatusClass = "perf-bad"; }
                    else { runwayDesc = "FLOP"; runwayStatusClass = "perf-flop"; }
                    runwayDetails = `(${runwayWithRandom.toFixed(1)})`;
                }

                const challengeWeighted = hasRunway ? challengeWithRandom * 0.8 : challengeWithRandom;
                const runwayWeighted = hasRunway ? runwayWithRandom * 0.2 : 0;
                const totalBase = challengeWeighted + runwayWeighted;

                const lastPlacement = stats && stats[q] ? stats[q].lastPlacement : null;
                let winModifier = 0;
                {
                    const consWins = (stats && stats[q]) ? (stats[q].consecutiveWins || 0) : 0;
                    const consHighs = (stats && stats[q]) ? (stats[q].consecutiveHighs || 0) : 0;
                    if (consWins > 0) {
                        winModifier = -1.25 - ((consWins - 1) * 0.5);
                    } else if (consHighs > 0) {
                        winModifier = -0.5 - ((consHighs - 1) * 0.25);
                    }
                }
                const total = totalBase + randomTotal + winModifier;
                return { 
                    name: q, 
                    total, 
                    totalBase,
                    challengeTotal: challengeWithRandom, 
                    runwayTotal: runwayWithRandom, 
                    challengeWeighted,
                    runwayWeighted,
                    randomTotal,
                    winModifier,
                    desc, 
                    statusClass, 
                    runwayDesc, 
                    runwayStatusClass, 
                    details: `(${challengeWithRandom.toFixed(1)})`,
                    runwayDetails: hasRunway ? `(${runwayWithRandom.toFixed(1)})` : '' 
                };
            }).sort((a, b) => b.total - a.total);

            let winningTeam = null;
            let losingTeam = null;
            let groupScores = null;
            let highTeam = [];
            const useGirlGroupsTeams = chal === 'Girl Groups' && currentCast.length >= 4;

            if (useGirlGroupsTeams) {
                let numGroups = 2;
                if (currentCast.length >= 12) numGroups = 4;
                else if (currentCast.length >= 9) numGroups = 3;

                const shuffledQueens = [...scores];
                for (let i = shuffledQueens.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffledQueens[i], shuffledQueens[j]] = [shuffledQueens[j], shuffledQueens[i]];
                }

                const groups = [];
                for (let i = 0; i < numGroups; i++) groups.push([]);
                shuffledQueens.forEach((q, index) => {
                    groups[index % numGroups].push(q);
                });

                groupScores = groups.map((group, idx) => {
                    const sum = group.reduce((acc, q) => {
                        const perfScore = (typeof q.totalBase === 'number' ? q.totalBase : 0) + 
                                          (typeof q.randomTotal === 'number' ? q.randomTotal : 0);
                        return acc + perfScore;
                    }, 0);
                    const avg = sum / group.length;
                    return { id: idx, avg, members: group };
                });

                groupScores.sort((a, b) => b.avg - a.avg);
                winningTeam = groupScores[0];
                losingTeam = groupScores[groupScores.length - 1];
            }

            let top2 = scores.slice(0, Math.min(2, scores.length)).map(t => ({
                ...t,
                score: (typeof t.score === 'number' && isFinite(t.score)) ? t.score : t.total
            }));

            if (winningTeam) {
                const sortedWinners = [...winningTeam.members].sort((a, b) => b.total - a.total);
                top2 = sortedWinners.slice(0, Math.min(2, sortedWinners.length)).map(t => ({
                    ...t,
                    score: (typeof t.score === 'number' && isFinite(t.score)) ? t.score : t.total
                }));
                const top2NameSet = new Set(top2.map(t => t.name));
                winningTeam.members.forEach(m => {
                    if (!top2NameSet.has(m.name)) {
                        highTeam.push(m);
                    }
                });
            }

            const top2Names = new Set(top2.map(t => t.name));
            const nonTop2 = scores.filter(s => !top2Names.has(s.name));
            const bottomCount = currentCast.length <= 5 ? 2 : (Math.random() < 0.25 && scores.length >= 5 ? 3 : 2);
            let bottom = [];
            if (losingTeam && losingTeam.members && losingTeam.members.length) {
                const sortedLosers = [...losingTeam.members].sort((a, b) => a.total - b.total);
                bottom = sortedLosers.slice(0, Math.min(bottomCount, sortedLosers.length));
            } else {
                bottom = nonTop2.slice(-bottomCount);
            }

            const others = scores.filter(s => !top2Names.has(s.name) && !bottom.find(b => b.name === s.name) && !highTeam.find(h => h.name === s.name));
            let high = others.slice(0, 2);
            let low = others.length > 2 ? [others[others.length - 1]] : [];
            let safe = others.filter(s => !high.find(h => h.name === s.name) && !low.find(l => l.name === s.name));
            if (useGirlGroupsTeams && winningTeam) {
                high = [];
                safe = others.filter(s => !low.find(l => l.name === s.name));
            }

            const combinedHigh = highTeam.length ? [...high, ...highTeam] : high;
            const untucked = generateUntucked(top2, bottom, combinedHigh, safe, low, stats, relationships, relationshipTension);
            const lipstickChoices = isPremiereEpisode ? {} : chooseLipsticks(top2, bottom, stats, relationships, untucked.influences);

            const score1 = Number(top2[0]?.score ?? top2[0]?.total ?? 0);
            const score2 = Number(top2[1]?.score ?? top2[1]?.total ?? 0);
            const ls1 = calcLipSyncScore(top2[0]?.name, 'allstars_top2', stats);
            const ls2 = calcLipSyncScore(top2[1]?.name, 'allstars_top2', stats);

            let isDoubleWin = !isPremiereEpisode && ls1.score > 13 && ls2.score > 13 && Math.abs(ls1.score - ls2.score) < 1 && Math.random() < 0.35 && doubleWinCount < MAX_DOUBLE_WINS;
            let lipSyncWinner = null;
            let eliminated = [];
            let loserTop2 = null;
            let sameLipstick = false;
            if (isDoubleWin) doubleWinCount++;

            let elimReasons = null;
            if (isPremiereEpisode) {
                lipSyncWinner = ls1.score >= ls2.score ? top2[0].name : top2[1].name;
                loserTop2 = top2.find(w => w.name !== lipSyncWinner).name;
                eliminated = [];
            } else if (isDoubleWin) {
                const choice1 = lipstickChoices[top2[0].name];
                const choice2 = lipstickChoices[top2[1].name];
                if (choice1 === choice2) {
                    eliminated = [choice1];
                    sameLipstick = true;
                } else {
                    eliminated = [choice1, choice2];
                    sameLipstick = false;
                }
                elimReasons = {};
                if (choice1) {
                    const personality1 = getPersonalityForQueen(top2[0].name);
                    const reason1 = getAllStarsElimReason(top2[0].name, choice1, personality1, stats, relationships);
                    if (sameLipstick && choice2) {
                        const personality2 = getPersonalityForQueen(top2[1].name);
                        const reason2 = getAllStarsElimReason(top2[1].name, choice2, personality2, stats, relationships);
                        elimReasons[choice1] = [reason1, reason2];
                    } else {
                        elimReasons[choice1] = reason1;
                    }
                }
                if (choice2 && choice2 !== choice1) {
                    const personality2 = getPersonalityForQueen(top2[1].name);
                    elimReasons[choice2] = getAllStarsElimReason(top2[1].name, choice2, personality2, stats, relationships);
                }
            } else {
                lipSyncWinner = ls1.score >= ls2.score ? top2[0].name : top2[1].name;
                const chosen = lipstickChoices[lipSyncWinner];
                eliminated = chosen ? [chosen] : [];
                loserTop2 = top2.find(w => w.name !== lipSyncWinner).name;
                sameLipstick = loserTop2 && chosen ? (lipstickChoices[loserTop2] === chosen) : false;
                if (chosen) {
                    const personality = getPersonalityForQueen(lipSyncWinner);
                    const winReason = getAllStarsElimReason(lipSyncWinner, chosen, personality, stats, relationships);
                    elimReasons = {};
                    elimReasons[chosen] = winReason;
                }
            }

            if (!isPremiereEpisode) {
                eliminated.forEach(eName => {
                    currentCast = currentCast.filter(q => q !== eName);
                });
            }

            scores.forEach(s => {
                const name = s.name;
                const st = stats[name];
                const isTop2 = top2.some(w => w.name === name);
                let points = 0;
                let placement = null;
                if (isTop2) {
                    if (isDoubleWin) { st.wins++; points = 5; placement = 'WIN'; }
                    else if (name === lipSyncWinner) { st.wins++; points = 5; placement = 'WIN'; }
                    else { st.wins++; points = GAME_CONSTANTS.POINTS.ALLSTARS_LIPSYNC_LOSER; placement = 'HIGH'; }
                }
                else if (high.find(h => h.name === name)) { st.highs++; points = 4; placement = 'HIGH'; }
                else if (highTeam.find(h => h.name === name)) { st.highs++; points = 4; placement = 'HIGH TEAM'; }
                else if (safe.find(x => x.name === name)) { st.safe++; points = 3; placement = 'SAFE'; }
                else if (low.find(l => l.name === name)) { st.lows++; points = 2; placement = 'LOW'; }
                else if (bottom.find(b => b.name === name)) { 
                    st.bottoms++; 
                    points = eliminated.includes(name) ? 0 : 1; 
                    placement = eliminated.includes(name) ? 'ELIM' : 'BTM';
                }
                st.totalPoints += points;
            st.episodesCount++;
            st.ppe = st.totalPoints / st.episodesCount;
            if (placement === 'WIN' || isTop2) {
                st.consecutiveWins = (st.consecutiveWins || 0) + 1;
                st.consecutiveHighs = 0;
            } else if (placement === 'HIGH' || placement === 'HIGH TEAM') {
                st.consecutiveHighs = (st.consecutiveHighs || 0) + 1;
                st.consecutiveWins = 0;
            } else {
                st.consecutiveWins = 0;
                st.consecutiveHighs = 0;
            }
            st.lastPlacement = placement;
            });

            episodes.push({
                episode: epNum,
                challenge: chal,
                scores,
                winners: top2,
                high, highTeam, safe, low,
                bottom,
                top2,
                lipSyncTop2: [ls1, ls2],
                lipstickChoices,
                lipSyncWinner: isDoubleWin ? "DOUBLE WIN" : lipSyncWinner,
                lipSyncLoser: loserTop2,
                eliminated: eliminated.length === 1 ? eliminated[0] : eliminated,
                elimReasons: elimReasons,
                untucked: untucked.scenes,
                revealLoserLipstick: !isPremiereEpisode && !isDoubleWin && !sameLipstick && !!(loserTop2 && lipstickChoices[loserTop2]),
                loserLipstick: (!isPremiereEpisode && !isDoubleWin && loserTop2) ? (lipstickChoices[loserTop2] || null) : null,
                sameLipstick,
                remainingCount: currentCast.length,
                isAllStars: true,
                isFinale: false,
                isDoubleWin,
                isPremiere: isPremiereEpisode,
                groups: groupScores
            });

            if (!isPremiereEpisode && eliminated.length) {
                const keyElim = getRelationshipKey(lipSyncWinner, eliminated);
                if (!relationshipTension[keyElim]) relationshipTension[keyElim] = 0;
                relationshipTension[keyElim] = Math.min(1, relationshipTension[keyElim] + 0.25);
            }
            epNum++;
        }

        const sortedByPPE = [...currentCast].sort((a, b) => stats[b].ppe - stats[a].ppe);
        const withWins = sortedByPPE.filter(q => stats[q].wins > 0);
        let winnerName = withWins.length > 0 ? withWins[0] : sortedByPPE[0];
        let finaleEpisodePayload;

        if (finaleLimit === 4 && finaleFormat === 'crown') {
            const shuffled = [...currentCast].map(x => ({ x, r: Math.random() })).sort((a, b) => a.r - b.r).map(o => o.x);
            const pair1 = [shuffled[0], shuffled[1]];
            const pair2 = [shuffled[2], shuffled[3]];
            const runMatch = (a, b) => {
                const sa = calcLipSyncScore(a, 'lalaparuza', stats);
                const sb = calcLipSyncScore(b, 'lalaparuza', stats);
                const aWins = sa.score >= sb.score;
                const winner = aWins ? a : b;
                const loser = aWins ? b : a;
                const song = (window.pickRandomLipSyncSong && typeof window.pickRandomLipSyncSong === 'function')
                    ? window.pickRandomLipSyncSong()
                    : '';
                return {
                    a, b,
                    scoreA: sa.score, breakdownA: sa.breakdown,
                    scoreB: sb.score, breakdownB: sb.breakdown,
                    winner, loser,
                    song
                };
            };
            const m1 = runMatch(pair1[0], pair1[1]);
            const m2 = runMatch(pair2[0], pair2[1]);
            const finalLipSyncQueens = [m1.winner, m2.winner];
            const finalSorted = finalLipSyncQueens.map(q => calcLipSyncScore(q, 'finale', stats)).sort((a, b) => b.score - a.score);
            
            if (finalLipSyncQueens.length >= 2) {
                const q1 = finalLipSyncQueens[0];
                const q2 = finalLipSyncQueens[1];
                const ppe1 = stats[q1] ? stats[q1].ppe : 0;
                const ppe2 = stats[q2] ? stats[q2].ppe : 0;
                winnerName = ppe1 >= ppe2 ? q1 : q2;
            } else {
                winnerName = finalLipSyncQueens[0] || currentCast[0];
            }
            const lostRound1 = [m1.loser].filter(Boolean);
            const lostRound2 = [m2.loser].filter(Boolean);
            const lostRound3 = finalLipSyncQueens.filter(q => q !== winnerName);
            const runnerUps = finalLipSyncQueens.filter(q => q !== winnerName);
            const eliminatedInFinale = [...lostRound2, ...lostRound1];
            finaleEpisodePayload = {
                episode: epNum,
                challenge: "Grand Finale — Lip Sync For The Crown",
                lipSyncSong: (window.pickRandomLipSyncSong && typeof window.pickRandomLipSyncSong === 'function') ? window.pickRandomLipSyncSong() : '',
                scores: [],
                winners: [{ name: winnerName, total: 100 }],
                top2: [],
                bottom: [],
                remainingCount: currentCast.length,
                isAllStars: true,
                isFinale: true,
                isCrownFinale: true,
                finalists: currentCast,
                crownRound1: [m1],
                crownRound2: [m2],
                finalLipSyncQueens,
                finalLipSyncScores: finalSorted,
                eliminatedInFinale,
                lostRound1,
                lostRound2,
                lostRound3,
                runnerUps,
                winner: winnerName
            };
        } else if (finaleLimit >= 3) {
            const finalePerformanceScores = currentCast.map(q => {
                const queen = queensDb[q];
                const performanceScore = queen.performance;
                const lipsyncScore = queen.lipsync;
                const luck = Math.random() * 7;
                const total = (performanceScore + lipsyncScore) / 2 + luck;
                return {
                    name: q,
                    total: total,
                    performanceScore: performanceScore,
                    lipsyncScore: lipsyncScore,
                    luck: luck,
                    passed: total >= 8
                };
            }).sort((a, b) => b.total - a.total);

            let finalLipSyncQueens = [];
            if (finaleLimit === 3) {
                const eligibleQueens = sortedByPPE.filter(q => {
                    const perfScore = finalePerformanceScores.find(s => s.name === q);
                    return perfScore && perfScore.passed && stats[q].wins > 0;
                });
                if (eligibleQueens.length === 0) {
                    finalLipSyncQueens = sortedByPPE.slice(0, 2).filter(q => stats[q].wins > 0);
                } else if (eligibleQueens.length >= 3) {
                    const diff = stats[eligibleQueens[1]].ppe - stats[eligibleQueens[2]].ppe;
                    finalLipSyncQueens = diff <= 0.1 ? eligibleQueens.slice(0, 3) : eligibleQueens.slice(0, 2);
                } else {
                    finalLipSyncQueens = eligibleQueens.length >= 2 ? eligibleQueens : sortedByPPE.slice(0, 2).filter(q => stats[q].wins > 0);
                }
            } else if (finaleLimit === 4) {
                const eligibleQueens = sortedByPPE.filter(q => {
                    const perfScore = finalePerformanceScores.find(s => s.name === q);
                    return perfScore && perfScore.passed && stats[q].wins > 0;
                });
                if (eligibleQueens.length === 0) {
                    finalLipSyncQueens = sortedByPPE.slice(0, 2).filter(q => stats[q].wins > 0);
                } else if (eligibleQueens.length >= 4) {
                    const diff34 = stats[eligibleQueens[2]].ppe - stats[eligibleQueens[3]].ppe;
                    if (diff34 <= 0.1) {
                        finalLipSyncQueens = eligibleQueens.slice(0, 4);
                    } else {
                        const diff23 = stats[eligibleQueens[1]].ppe - stats[eligibleQueens[2]].ppe;
                        finalLipSyncQueens = diff23 <= 0.3 ? eligibleQueens.slice(0, 3) : eligibleQueens.slice(0, 2);
                    }
                } else {
                    finalLipSyncQueens = eligibleQueens.length >= 2 ? eligibleQueens : sortedByPPE.slice(0, 2).filter(q => stats[q].wins > 0);
                }
            }
            if (finalLipSyncQueens.length < 2) {
                const withWins = sortedByPPE.filter(q => stats[q].wins > 0).slice(0, 2);
                finalLipSyncQueens = withWins.length >= 2 ? withWins : sortedByPPE.slice(0, 2);
            }

            const finalLipSyncScores = finalLipSyncQueens.map(q => calcLipSyncScore(q, 'finale', stats)).sort((a, b) => b.score - a.score);

            const eliminatedInFinale = currentCast.filter(q => !finalLipSyncQueens.includes(q));
            const runnerUps = finalLipSyncQueens.filter(q => q !== winnerName);

            finaleEpisodePayload = {
                episode: epNum,
                challenge: "Grand Finale Performance",
                lipSyncSong: (window.pickRandomLipSyncSong && typeof window.pickRandomLipSyncSong === 'function') ? window.pickRandomLipSyncSong() : '',
                scores: finalePerformanceScores,
                winners: [{ name: winnerName, total: 100 }],
                top2: [],
                bottom: [],
                remainingCount: currentCast.length,
                isAllStars: true,
                isFinale: true,
                finalists: finalLipSyncQueens,
                finalePerformanceScores: finalePerformanceScores,
                finalLipSyncQueens: finalLipSyncQueens,
                finalLipSyncScores: finalLipSyncScores,
                eliminatedInFinale: eliminatedInFinale,
                runnerUps: runnerUps,
                winner: winnerName
            };
        } else {
            finaleEpisodePayload = {
                episode: epNum,
                challenge: "Grand Finale",
                lipSyncSong: (window.pickRandomLipSyncSong && typeof window.pickRandomLipSyncSong === 'function') ? window.pickRandomLipSyncSong() : '',
                scores: [],
                winners: [{ name: winnerName, total: 100 }],
                top2: [],
                bottom: [],
                remainingCount: currentCast.length,
                isAllStars: true,
                isFinale: true,
                finalists: currentCast,
                winner: winnerName,
                runnerUps: currentCast.filter(q => q !== winnerName)
            };
        }

        episodes.push(finaleEpisodePayload);

        seasonData = {
            episodes,
            finale: currentCast,
            winner: winnerName,
            queenStats: stats,
            castQueens: castAtStart,
            relationships,
            isAllStars: true,
            finaleLimit: finaleLimit,
            finaleFormat: finaleFormat
        };

        document.getElementById('setupPanel').classList.add('hidden');
        document.getElementById('scenarioScreen').classList.remove('hidden');
        setHeaderMode('scenario');
        currentEpIndex = 0;
        scenarioPhase = 0;
        renderScenario();
    }

    function generateTournamentAllStarsSeason(relationships) {
        if (selectedQueens.length !== MAX_CAST) return showToast(`Tournament of All Stars: select exactly ${MAX_CAST} queens!`, 'error');
        const finaleLimit = parseInt(getSelectedFinaleType(), 10) || 2;

        let castAtStart = null;
        let groups = null;
        const bracketState = window._tournamentBracketState;
        if (bracketState && bracketState.assignment) {
            const groupA = selectedQueens.filter(q => bracketState.assignment[q] === 'A');
            const groupB = selectedQueens.filter(q => bracketState.assignment[q] === 'B');
            const groupC = selectedQueens.filter(q => bracketState.assignment[q] === 'C');
            if (groupA.length === 6 && groupB.length === 6 && groupC.length === 6) {
                groups = [groupA, groupB, groupC];
                castAtStart = [...groupA, ...groupB, ...groupC];
            }
        }

        if (!castAtStart) {
            castAtStart = [...selectedQueens];
        }

        if (!relationships) {
            relationships = {};
            for (let i = 0; i < castAtStart.length; i++) for (let j = i + 1; j < castAtStart.length; j++) relationships[getRelationshipKey(castAtStart[i], castAtStart[j])] = DEFAULT_RELATIONSHIP;
        }

        const stats = {};
        castAtStart.forEach(q => { stats[q] = { wins: 0, highs: 0, safe: 0, lows: 0, bottoms: 0, ppe: 0, totalPoints: 0, episodesCount: 0, consecutiveWins: 0, consecutiveHighs: 0 }; });
        const relationshipTension = {};

        if (!groups) {
            const shuffled = [...castAtStart].map(q => ({ q, r: Math.random() })).sort((a, b) => a.r - b.r).map(x => x.q);
            groups = [shuffled.slice(0, 6), shuffled.slice(6, 12), shuffled.slice(12, 18)];
        }
        const groupLabels = ['Bracket 1', 'Bracket 2', 'Bracket 3'];

        const episodes = [];
        const recentWins = {};
        let epNum = 1;
        const challengeKeys = Object.keys(challengeConfig || {});
        const usedChallenges = new Set();
        const challengePresets = [
            ['Girl Groups', 'Improv', 'Makeover'],
            ['Design', 'Roast', 'Rusical'],
            ['Acting', 'Design', 'Girl Groups']
        ];

        const resolveChallenge = (name) => {
            if (challengeConfig && challengeConfig[name]) return name;
            const lower = String(name || '').toLowerCase();
            const found = challengeKeys.find(k => String(k).toLowerCase() === lower);
            if (found) return found;
            const fallback = challengeKeys.length ? challengeKeys[Math.floor(Math.random() * challengeKeys.length)] : name;
            return fallback;
        };

        const pickRandomUnusedChallenge = () => {
            const pool = challengeKeys.filter(k => !usedChallenges.has(k));
            const pickFrom = pool.length ? pool : challengeKeys;
            if (!pickFrom.length) return 'Challenge';
            return pickFrom[Math.floor(Math.random() * pickFrom.length)];
        };

        const semifinalists = [];
        const presetsForGroups = [...challengePresets]
            .map(p => ({ p, r: Math.random() }))
            .sort((a, b) => a.r - b.r)
            .map(x => x.p);
        for (let gi = 0; gi < groups.length; gi++) {
            const groupCast = groups[gi];
            const preset = presetsForGroups[gi] || [];
            for (let i = 0; i < 3; i++) {
                const chal = resolveChallenge(preset[i]);
                usedChallenges.add(chal);
                const ep = simulateDoublePremiereAllStarsEpisode(groupCast, chal, epNum, stats, recentWins, groupCast.length, relationships, 'tournament', relationshipTension);
                ep.isDoublePremiere = false;
                ep.isPremiere = true;
                ep.isTournament = true;
                ep.tournamentStage = groupLabels[gi];
                ep.displayChallenge = `${groupLabels[gi]} — ${chal}`;
                episodes.push(ep);
                epNum++;
            }

            const adv = [...groupCast].sort((a, b) => (stats[b].totalPoints - stats[a].totalPoints) || (Math.random() - 0.5)).slice(0, 3);
            const bracketEliminated = groupCast.filter(q => !adv.includes(q));
            const lastGroupEpisodeIndex = episodes.length - 1;
            if (episodes[lastGroupEpisodeIndex]) {
                episodes[lastGroupEpisodeIndex].bracketSemifinalists = [...adv];
                episodes[lastGroupEpisodeIndex].bracketEliminated = bracketEliminated;
            }
            semifinalists.push(...adv);
        }

        const bracketEliminatedPool = episodes
            .filter(e => e && e.bracketEliminated && Array.isArray(e.bracketEliminated))
            .flatMap(e => e.bracketEliminated);

        const semi1Challenge = resolveChallenge('Snatch Game');
        usedChallenges.add(semi1Challenge);

        const semi1Placeholder = {
            episode: epNum,
            challenge: semi1Challenge,
            displayChallenge: `Semi-Finals — ${semi1Challenge}`,
            scores: [],
            winners: [],
            top2: [],
            high: [],
            safe: [],
            low: [],
            bottom: [],
            eliminated: null,
            remainingCount: semifinalists.length,
            isAllStars: false,
            isFinale: false,
            isTournament: true,
            tournamentStage: 'Semi-Finals',
            needsReturnPick: true,
            hasRunway: hasRunwayForChallenge(semi1Challenge),
            runwayShown: false
        };
        episodes.push(semi1Placeholder);
        epNum++;

        seasonData = {
            episodes,
            finale: [],
            winner: null,
            queenStats: stats,
            castQueens: castAtStart,
            relationships,
            isAllStars: true,
            isTournament: true,
            finaleLimit: finaleLimit,
            tournamentState: {
                currentCast: [...semifinalists],
                eliminatedPool: [...bracketEliminatedPool],
                usedChallenges,
                challengeKeys,
                recentWins,
                stats,
                relationshipTension,
                finaleLimit,
                nextEpNumber: epNum,
                postReturnGenerated: false
            }
        };

        document.getElementById('setupPanel').classList.add('hidden');
        document.getElementById('scenarioScreen').classList.remove('hidden');
        setHeaderMode('scenario');
        currentEpIndex = 0;
        scenarioPhase = 0;
        renderScenario();
    }

    function simulateTournamentRegularElimEpisode(currentCast, chal, epNumber, stats, recentWins, relationships, relationshipTension) {
        const hasRunway = hasRunwayForChallenge(chal);
        const scores = currentCast.map(q => {
            const queen = queensDb[q];
            const challengeStats = challengeConfig[chal];
            const base = challengeStats.reduce((acc, s) => acc + queen[s], 0) / challengeStats.length;
            const challengeTotal = base;

            const randomForChallenge = Math.random() * 5 - 2.5;
            const randomForRunway = hasRunway ? (Math.random() * 5 - 2.5) : 0;
            const randomTotal = 0;

            const challengeWithRandom = challengeTotal + randomForChallenge;

            let desc = "Safe";
            let statusClass = "perf-safe";
            if (challengeWithRandom > 12) { desc = "SLAYED!"; statusClass = "perf-slay"; }
            else if (challengeWithRandom > 8) { desc = "Great job"; statusClass = "perf-good"; }
            else if (challengeWithRandom > 6) { desc = "Okay"; statusClass = "perf-safe"; }
            else if (challengeWithRandom > 4) { desc = "Struggled"; statusClass = "perf-bad"; }
            else { desc = "FLOP"; statusClass = "perf-flop"; }

            let runwayTotal = 0;
            let runwayDesc = "";
            let runwayStatusClass = "";
            let runwayWithRandom = 0;
            
            if (hasRunway) {
                const fashionBase = queen.fashion;
                runwayTotal = fashionBase;
                runwayWithRandom = runwayTotal + randomForRunway;
                
                if (runwayWithRandom > 12) { runwayDesc = "SLAYED!"; runwayStatusClass = "perf-slay"; }
                else if (runwayWithRandom > 8) { runwayDesc = "Great job"; runwayStatusClass = "perf-good"; }
                else if (runwayWithRandom > 6) { runwayDesc = "Okay"; runwayStatusClass = "perf-safe"; }
                else if (runwayWithRandom > 4) { runwayDesc = "Struggled"; runwayStatusClass = "perf-bad"; }
                else { runwayDesc = "FLOP"; runwayStatusClass = "perf-flop"; }
            }

            const challengeWeighted = hasRunway ? challengeWithRandom * 0.8 : challengeWithRandom;
            const runwayWeighted = hasRunway ? runwayWithRandom * 0.2 : 0;
            const totalBase = challengeWeighted + runwayWeighted;

            const lastPlacement = stats && stats[q] ? stats[q].lastPlacement : null;
            const disableWinPenalty = epNumber === 10;
            let winModifier = 0;
            if (!disableWinPenalty) {
                const consWins = (stats && stats[q]) ? (stats[q].consecutiveWins || 0) : 0;
                const consHighs = (stats && stats[q]) ? (stats[q].consecutiveHighs || 0) : 0;
                if (consWins > 0) {
                    winModifier = -1.25 - ((consWins - 1) * 0.5);
                } else if (consHighs > 0) {
                    winModifier = -0.5 - ((consHighs - 1) * 0.25);
                }
            }
            const total = totalBase + randomTotal + winModifier;
            return {
                name: q,
                total,
                totalBase,
                challengeTotal: challengeWithRandom,
                runwayTotal: runwayWithRandom,
                challengeWeighted,
                runwayWeighted,
                randomTotal,
                winModifier,
                desc,
                statusClass,
                runwayDesc,
                runwayStatusClass,
                details: `(${challengeWithRandom.toFixed(1)})`,
                runwayDetails: hasRunway ? `(${runwayWithRandom.toFixed(1)})` : ''
            };
        }).sort((a, b) => b.total - a.total);

        const winners = scores.slice(0, 1);
        const winnerNames = new Set(winners.map(w => w.name));
        const nonWinners = scores.filter(s => !winnerNames.has(s.name));

        const btm = [nonWinners[nonWinners.length - 1], nonWinners[nonWinners.length - 2]].filter(Boolean);
        const others = nonWinners.filter(s => !btm.some(b => b.name === s.name));
        const high = others.slice(0, 2);
        const low = others.length > 2 ? [others[others.length - 1]] : [];
        const safe = others.filter(s => !high.some(h => h.name === s.name) && !low.some(l => l.name === s.name));

        let untuckedScenes = [];
        if (relationshipTension) {
            const untucked = generateUntucked(winners, btm, high, safe, low, stats, relationships, relationshipTension);
            untuckedScenes = untucked.scenes || [];
        }

        const ls1 = calcLipSyncScore(btm[0].name, 'btm2', stats);
        const ls2 = calcLipSyncScore(btm[1].name, 'btm2', stats);

        let elim = ls1.score < ls2.score ? btm[0].name : btm[1].name;
        const otherBtm = btm[0].name === elim ? btm[1].name : btm[0].name;
        if (stats[elim].ppe >= stats[otherBtm].ppe + RIGGORY_PPE_THRESHOLD) {
            elim = otherBtm;
        }

        const updatedCast = currentCast.filter(q => q !== elim);

        scores.forEach(s => {
            const name = s.name;
            const st = stats[name];
            let points = 0;
            let placement = null;

            if (winners.some(w => w.name === name)) { st.wins++; points = 5; placement = 'WIN'; }
            else if (high.some(h => h.name === name)) { st.highs++; points = 4; placement = 'HIGH'; }
            else if (safe.some(x => x.name === name)) { st.safe++; points = 3; placement = 'SAFE'; }
            else if (low.some(l => l.name === name)) { st.lows++; points = 2; placement = 'LOW'; }
            else if (btm.some(b => b.name === name)) {
                st.bottoms++;
                points = elim === name ? 0 : 1;
                placement = elim === name ? 'ELIM' : 'BTM';
            }

            st.totalPoints += points;
            st.episodesCount++;
            st.ppe = st.totalPoints / st.episodesCount;
            if (placement === 'WIN') {
                st.consecutiveWins = (st.consecutiveWins || 0) + 1;
                st.consecutiveHighs = 0;
            } else if (placement === 'HIGH') {
                st.consecutiveHighs = (st.consecutiveHighs || 0) + 1;
                st.consecutiveWins = 0;
            } else {
                st.consecutiveWins = 0;
                st.consecutiveHighs = 0;
            }
            st.lastPlacement = placement;
        });

        const epData = {
            episode: epNumber,
            challenge: chal,
            scores,
            winners,
            isDouble: false,
            isDoubleShantay: false,
            high,
            safe,
            low,
            bottom: [
                { name: btm[0].name, score: ls1.score, info: ls1.breakdown },
                { name: btm[1].name, score: ls2.score, info: ls2.breakdown }
            ],
            eliminated: elim,
            remainingCount: updatedCast.length,
            isFinale: false,
            hasRunway
        };
        if (untuckedScenes.length > 0) epData.untucked = untuckedScenes;
        return { epData, updatedCast };
    }
    function simulateDoublePremiereRegularEpisode(groupCast, chal, epNumber, stats, recentWins, relationshipTension, relationships, currentCastSize, finaleLimit, isBeaverFormat, isElimPremiere, doubleShantayUsed, luckyQueenCtx) {
        const isAllStars = false;
        const hasRunway = hasRunwayForChallenge(chal);
        const scores = groupCast.map(q => {
            const queen = queensDb[q];
            const challengeStats = challengeConfig[chal];
            const base = challengeStats.reduce((acc, s) => acc + queen[s], 0) / challengeStats.length;
            const challengeTotal = base;

            const randomForChallenge = Math.random() * 5 - 2.5;
            const randomForRunway = hasRunway ? (Math.random() * 5 - 2.5) : 0;
            const randomTotal = 0;

            const challengeWithRandom = challengeTotal + randomForChallenge;

            let desc = "Safe";
            let statusClass = "perf-safe";
            if (challengeWithRandom > 12) { desc = "SLAYED!"; statusClass = "perf-slay"; }
            else if (challengeWithRandom > 8) { desc = "Great job"; statusClass = "perf-good"; }
            else if (challengeWithRandom > 6) { desc = "Okay"; statusClass = "perf-safe"; }
            else if (challengeWithRandom > 4) { desc = "Struggled"; statusClass = "perf-bad"; }
            else { desc = "FLOP"; statusClass = "perf-flop"; }
            let runwayTotal = 0;
            let runwayDesc = "";
            let runwayStatusClass = "";
            let runwayWithRandom = 0;
            let runwayDetails = "";
            if (hasRunway) {
                const fashionBase = queen.fashion;
                runwayTotal = fashionBase;
                runwayWithRandom = runwayTotal + randomForRunway;

                if (runwayWithRandom > 12) { runwayDesc = "SLAYED!"; runwayStatusClass = "perf-slay"; }
                else if (runwayWithRandom > 8) { runwayDesc = "Great job"; runwayStatusClass = "perf-good"; }
                else if (runwayWithRandom > 6) { runwayDesc = "Okay"; runwayStatusClass = "perf-safe"; }
                else if (runwayWithRandom > 4) { runwayDesc = "Struggled"; runwayStatusClass = "perf-bad"; }
                else { runwayDesc = "FLOP"; runwayStatusClass = "perf-flop"; }
                runwayDetails = `(${runwayWithRandom.toFixed(1)})`;
            }

            const challengeWeighted = hasRunway ? challengeWithRandom * 0.8 : challengeWithRandom;
            const runwayWeighted = hasRunway ? runwayWithRandom * 0.2 : 0;
            const totalBase = challengeWeighted + runwayWeighted;

            const lastPlacement = stats && stats[q] ? stats[q].lastPlacement : null;
            let winModifier = 0;
            {
                const consWins = (stats && stats[q]) ? (stats[q].consecutiveWins || 0) : 0;
                const consHighs = (stats && stats[q]) ? (stats[q].consecutiveHighs || 0) : 0;
                if (consWins > 0) {
                    winModifier = -1.25 - ((consWins - 1) * 0.5);
                } else if (consHighs > 0) {
                    winModifier = -0.5 - ((consHighs - 1) * 0.25);
                }
            }
            const total = totalBase + randomTotal + winModifier;
            return { 
                name: q, 
                total, 
                totalBase,
                challengeTotal: challengeWithRandom, 
                runwayTotal: runwayWithRandom, 
                challengeWeighted,
                runwayWeighted,
                randomTotal,
                winModifier,
                desc, 
                statusClass, 
                runwayDesc, 
                runwayStatusClass, 
                details: `(${challengeWithRandom.toFixed(1)})`,
                runwayDetails: hasRunway ? `(${runwayWithRandom.toFixed(1)})` : ''
            };
        }).sort((a, b) => b.total - a.total);

        if (!isElimPremiere) {
            const top2 = scores.slice(0, Math.min(2, scores.length));
            const buckets = getDoublePremiereBuckets(scores, top2, 'total');
            const high = buckets.high;
            const safe = buckets.safe;
            const low = buckets.low;
            const ls1 = calcLipSyncScore(top2[0].name, 'allstars_top2', stats);
            const ls2 = calcLipSyncScore(top2[1].name, 'allstars_top2', stats);
            const lipSyncWinner = ls1.score >= ls2.score ? top2[0].name : top2[1].name;
            const lipSyncLoser = top2.find(w => w.name !== lipSyncWinner).name;
            const lipSyncTop2 = [ls1, ls2];
            const luckyQueenSave = null;

            let untuckedScenes = [];
            if (relationshipTension) {
                const bottomTmp = [];
                if (low && low.length) {
                    low.forEach(q => bottomTmp.push(q));
                } else if (safe && safe.length) {
                    const last = safe[safe.length - 1];
                    const prev = safe.length > 1 ? safe[safe.length - 2] : null;
                    if (last) bottomTmp.push(last);
                    if (prev) bottomTmp.push(prev);
                } else if (scores.length >= 2) {
                    bottomTmp.push(scores[scores.length - 1], scores[scores.length - 2]);
                }
                const untucked = generateUntucked(top2, bottomTmp, high, safe, low, stats, relationships, relationshipTension);
                untuckedScenes = untucked.scenes || [];
            }

            scores.forEach(s => {
                const name = s.name;
                const st = stats[name];
                let points = 0;
                let placement = null;
                if (top2.find(w => w.name === name)) {
                    if (name === lipSyncWinner) { st.wins++; points = 5; placement = 'WIN'; }
                    else { points = GAME_CONSTANTS.POINTS.DOUBLE_PREMIERE_TOP2; placement = 'HIGH'; }
                } else if (high.find(h => h.name === name)) { st.highs++; points = 4; placement = 'HIGH'; }
                else if (safe.find(x => x.name === name)) { st.safe++; points = 3; placement = 'SAFE'; }
                else if (low.find(l => l.name === name)) { st.lows++; points = 2; placement = 'LOW'; }
                st.totalPoints += points;
                st.episodesCount++;
                st.ppe = st.totalPoints / st.episodesCount;
                st.lastPlacement = placement;

                if (placement === 'WIN') {
                    st.consecutiveWins = (st.consecutiveWins || 0) + 1;
                    st.consecutiveHighs = 0;
                } else if (placement === 'HIGH' || placement === 'HIGH TEAM') {
                    st.consecutiveHighs = (st.consecutiveHighs || 0) + 1;
                    st.consecutiveWins = 0;
                } else {
                    st.consecutiveWins = 0;
                    st.consecutiveHighs = 0;
                }
            });

            const epData = {
                episode: epNumber,
                challenge: chal,
                scores,
                winners: top2,
                isDouble: false,
                isDoubleShantay: false,
                high,
                safe,
                low,
                bottom: [],
                top2,
                lipSyncTop2,
                lipSyncWinner,
                lipSyncLoser,
                eliminated: null,
                remainingCount: currentCastSize,
                isFinale: false,
                isDoublePremiere: true,
                isPremiere: true,
                hasRunway,
                isBeaverFormat,
                beaverSaved: null,
                beaverReason: null,
                beaverBottom3: null,
                luckyQueenSave
            };
            if (untuckedScenes.length > 0) epData.untucked = untuckedScenes;
            return { epData, eliminated: null, doubleShantayUsed };
        }

        let winningTeam = null;
        let losingTeam = null;
        let groupScores = null;
        if (chal === 'Girl Groups' && groupCast.length >= 4) {
            let numGroups = 2;
            if (groupCast.length >= 12) numGroups = 4;
            else if (groupCast.length >= 9) numGroups = 3;

            const shuffledQueens = [...scores];
            for (let i = shuffledQueens.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffledQueens[i], shuffledQueens[j]] = [shuffledQueens[j], shuffledQueens[i]];
            }

            const groups = [];
            for (let i = 0; i < numGroups; i++) groups.push([]);
            shuffledQueens.forEach((q, index) => {
                groups[index % numGroups].push(q);
            });

            groupScores = groups.map((group, idx) => {
                const sum = group.reduce((acc, q) => {
                    const perfScore = (typeof q.challengeTotal === 'number' ? q.challengeTotal : 0) +
                                      (typeof q.randomTotal === 'number' ? q.randomTotal : 0);
                    return acc + perfScore;
                }, 0);
                const avg = sum / group.length;
                return { id: idx, avg, members: group };
            });

            groupScores.sort((a, b) => b.avg - a.avg);
            winningTeam = groupScores[0];
            losingTeam = groupScores[groupScores.length - 1];
        }

        let winners = scores.slice(0, 1);
        if (winningTeam) {
            const sortedWinners = [...winningTeam.members].sort((a, b) => b.total - a.total);
            winners = [sortedWinners[0]];
        }
        const winnerNames = new Set(winners.map(w => w.name));
        const nonWinners = scores.filter(s => !winnerNames.has(s.name));
        let btm = [nonWinners[nonWinners.length - 1], nonWinners[nonWinners.length - 2]].filter(Boolean);
        let high = [], low = [], safe = [], highTeam = [];

        if (winningTeam) {
            const actualWinnerName = winners[0].name;
            winningTeam.members.forEach(m => {
                if (m.name !== actualWinnerName) {
                    highTeam.push(m);
                }
            });
            if (highTeam.length === 0 && winningTeam.members.length > 1) {
                winningTeam.members.slice(1).forEach(m => highTeam.push(m));
            }

            const losingMembers = [...losingTeam.members].sort((a, b) => a.total - b.total);
            btm = [losingMembers[0], losingMembers[1]].filter(Boolean);
            for (let i = 2; i < losingMembers.length; i++) {
                low.push(losingMembers[i]);
            }
            scores.forEach(s => {
                const name = s.name;
                if (!winnerNames.has(name) && !highTeam.find(ht => ht.name === name) && !btm.find(b => b.name === name) && !low.find(l => l.name === name)) {
                    safe.push(s);
                }
            });
        } else {
            const others = nonWinners.filter(s => !btm.find(b => b.name === s.name));
            high = others.slice(0, 2);
            low = others.length > 2 ? [others[others.length - 1]] : [];
            safe = others.filter(s => !high.find(h => h.name === s.name) && !low.find(l => l.name === s.name));
        }

        let beaverSaved = null;
        let beaverSavedForUI = null;
        let beaverBottom3 = null;
        let beaverReason = null;
        if (isBeaverFormat && currentCastSize > finaleLimit) {
            if (nonWinners.length >= 3) {
                beaverBottom3 = nonWinners.slice(-3);
                const saverName = winners[0].name;
                const personality = getPersonalityForQueen(saverName);
                const isFirstEpisode = epNumber === 1;
                const beaverPick = beaverBottom3.reduce((best, s) => {
                    if (!best) return s;
                    const bestScore = getBeaverSaveScore(best, saverName, personality, stats, relationships || {}, isFirstEpisode);
                    const curScore = getBeaverSaveScore(s, saverName, personality, stats, relationships || {}, isFirstEpisode);
                    return curScore > bestScore ? s : best;
                }, null);
                beaverSaved = beaverPick ? beaverPick.name : beaverBottom3[0].name;
                beaverSavedForUI = beaverSaved;
                beaverReason = getBeaverSaveReason(saverName, beaverSaved, personality, stats, relationships || {});
                const lipSyncBottom = beaverBottom3.filter(s => s.name !== beaverSaved);
                if (lipSyncBottom.length === 2) {
                    btm[0] = lipSyncBottom[0];
                    btm[1] = lipSyncBottom[1];
                }
            }
        }

        if (beaverBottom3 && beaverBottom3.length) {
            const bottomNames = new Set(beaverBottom3.map(s => s.name));
            const filterNonBottom = arr => arr.filter(x => !bottomNames.has(x.name));
            if (high.length) {
                const newHigh = filterNonBottom(high);
                high.splice(0, high.length, ...newHigh);
            }
            if (highTeam && highTeam.length) {
                const newHighTeam = filterNonBottom(highTeam);
                highTeam.splice(0, highTeam.length, ...newHighTeam);
            }
            if (safe.length) {
                const newSafe = filterNonBottom(safe);
                safe.splice(0, safe.length, ...newSafe);
            }
            low.length = 0;
        }

        // Lucky Queen Save Logic
        let luckyQueenSave = null;
        let luckyQueenTwistData = null;

        // --- RESTRICT LUCKY QUEEN TO REGULAR & BEAVER FORMATS ONLY ---
        const isRegularOrBeaver = !isAllStars;
        
        if (isRegularOrBeaver && luckyQueenCtx && luckyQueenCtx.name && !luckyQueenCtx.used && currentCastSize > finaleLimit + 1) {
            const lqName = luckyQueenCtx.name;
            const lqIndex = btm.findIndex(b => b.name === lqName);
            if (lqIndex !== -1) {
                let replacement = null;
                let sourceArray = null;
                
                const originalBottom = [...btm];
                
                // Calculate original lip sync scores for twist reveal
                const origLs1 = calcLipSyncScore(btm[0].name, 'btm2', stats);
                const origLs2 = calcLipSyncScore(btm[1].name, 'btm2', stats);
                const originalBottomData = [
                    { name: btm[0].name, score: origLs1.score, info: origLs1.breakdown },
                    { name: btm[1].name, score: origLs2.score, info: origLs2.breakdown }
                ];

                let replacementSourceTier = 'low'; // default fallback

                if (low.length > 0) { replacement = low[low.length - 1]; sourceArray = low; replacementSourceTier = 'low'; }
                else if (safe.length > 0) { replacement = safe[safe.length - 1]; sourceArray = safe; replacementSourceTier = 'safe'; }
                else if (high.length > 0) { replacement = high[high.length - 1]; sourceArray = high; replacementSourceTier = 'high'; }
                else if (highTeam && highTeam.length > 0) { replacement = highTeam[highTeam.length - 1]; sourceArray = highTeam; replacementSourceTier = 'highTeam'; }
                else if (winners.length > 0) { replacement = winners[winners.length - 1]; sourceArray = winners; replacementSourceTier = 'win'; }
                
                if (isBeaverFormat && beaverSaved) {
                    const beaverQueen = scores.find(s => s.name === beaverSaved);
                    if (beaverQueen) {
                        replacement = beaverQueen;
                        
                        if (low.find(s => s.name === beaverSaved)) sourceArray = low;
                        else if (safe.find(s => s.name === beaverSaved)) sourceArray = safe;
                        else if (high.find(s => s.name === beaverSaved)) sourceArray = high;
                        else if (highTeam && highTeam.find(s => s.name === beaverSaved)) sourceArray = highTeam;
                        else if (winners.find(s => s.name === beaverSaved)) sourceArray = winners;
                        else sourceArray = null;

                        replacementSourceTier = 'beaver';
                        beaverSaved = null;
                    }
                }

                if (replacement) {
                    const lqObj = btm[lqIndex];
                    btm.splice(lqIndex, 1); // Remove Lucky Queen from BTM
                    
                    const tiers = [low, safe, high, winners];
                    if (highTeam) tiers.push(highTeam);
                    
                    tiers.forEach(tier => {
                        const idx = tier.findIndex(s => s.name === replacement.name);
                        if (idx !== -1) tier.splice(idx, 1);
                    });
                    
                    low.push(lqObj);
                    
                    btm.push(replacement);
                    
                    luckyQueenCtx.used = true;
                    luckyQueenSave = { saved: lqName, replaced: replacement.name };
                    
                    luckyQueenTwistData = {
                        savedQueen: lqName,
                        replacementQueen: replacement.name,
                        originalBottom: originalBottomData,
                        placementBeforeSave: 'btm',
                        replacementSourceTier: replacementSourceTier
                    };
                }
            }
        }

        let untuckedScenes = [];
        if (relationshipTension) {
            const combinedHigh = [...high, ...highTeam];
            const untucked = generateUntucked(winners, btm, combinedHigh, safe, low, stats, relationships, relationshipTension);
            untuckedScenes = untucked.scenes || [];
        }

        const ls1 = calcLipSyncScore(btm[0].name, 'btm2', stats);
        const ls2 = calcLipSyncScore(btm[1].name, 'btm2', stats);
        let elim = null;
        let isDoubleShantay = false;
        if (isElimPremiere) {
            let elimCandidate = ls1.score < ls2.score ? btm[0].name : btm[1].name;
            const otherBtm = btm[0].name === elimCandidate ? btm[1].name : btm[0].name;
            if (stats[elimCandidate].ppe >= stats[otherBtm].ppe + RIGGORY_PPE_THRESHOLD) {
                elimCandidate = otherBtm;
            }
            const scoreDiff = Math.abs(ls1.score - ls2.score);
            const rollShantay = Math.random();
            if (ls1.score > 13 && ls2.score > 13 && scoreDiff < 1 && rollShantay < 0.30 && currentCastSize > finaleLimit + 2 && !doubleShantayUsed) {
                elimCandidate = null;
                isDoubleShantay = true;
                doubleShantayUsed = true;
            }
            elim = elimCandidate;
        }

        const remainingCount = elim ? (currentCastSize - 1) : currentCastSize;
        const isBeaverEpisode = isBeaverFormat && beaverSaved;

        scores.forEach(s => {
            const name = s.name;
            const st = stats[name];
            let points = 0;
            let placement = null;
            const isBeaverQueen = isBeaverEpisode && name === beaverSaved;
            const inBottom = btm.find(b => b.name === name);

            if (winners.find(w => w.name === name) && !inBottom) { st.wins++; points = 5; placement = 'WIN'; } 
            else if (high.find(h => h.name === name) && !inBottom) { st.highs++; points = 4; placement = 'HIGH'; }
            else if (highTeam.find(h => h.name === name) && !inBottom) { st.highs++; points = 4; placement = 'HIGH TEAM'; }
            else if (safe.find(x => x.name === name) && !inBottom) { st.safe++; points = 3; placement = 'SAFE'; }
            else if (low.find(l => l.name === name) && !inBottom) { st.lows++; points = 2; placement = 'LOW'; }
            else if (inBottom || isBeaverQueen) {
                st.bottoms++;
                if (elim === name) { points = 0; placement = 'ELIM'; }
                else if (isBeaverQueen) { points = 2; placement = 'BTM'; }
                else { points = 1; placement = 'BTM'; }
            }
            st.totalPoints += points;
            st.episodesCount++;
            st.ppe = st.totalPoints / st.episodesCount;
            if (placement === 'WIN') {
                st.consecutiveWins = (st.consecutiveWins || 0) + 1;
                st.consecutiveHighs = 0;
            } else if (placement === 'HIGH' || placement === 'HIGH TEAM') {
                st.consecutiveHighs = (st.consecutiveHighs || 0) + 1;
                st.consecutiveWins = 0;
            } else {
                st.consecutiveWins = 0;
                st.consecutiveHighs = 0;
            }
            st.lastPlacement = placement;
        });

        const epData = {
            episode: epNumber,
            challenge: chal,
            scores,
            winners,
            isDouble: false,
            isDoubleShantay,
            high,
            highTeam,
            safe,
            low,
            bottom: [
                { name: btm[0].name, score: ls1.score, info: ls1.breakdown },
                { name: btm[1].name, score: ls2.score, info: ls2.breakdown }
            ],
            eliminated: elim,
            remainingCount,
            isFinale: false,
            isDoublePremiere: true,
            isPremiere: true,
            hasRunway,
            isBeaverFormat,
            beaverSaved: beaverSavedForUI || beaverSaved,
            beaverSavedForUI,
            beaverReason,
            beaverBottom3: beaverBottom3 ? beaverBottom3.map(s => s.name) : null,
            groups: groupScores,
            lipSyncSong: window.pickRandomLipSyncSong ? window.pickRandomLipSyncSong() : '',
            luckyQueenSave,
            luckyQueenTwistData
        };
        if (untuckedScenes.length > 0) epData.untucked = untuckedScenes;
        return { epData, eliminated: elim, doubleShantayUsed };
    }

    function generateSeason(relationships) {
        const isAllStars = false;
        if (selectedQueens.length > MAX_CAST) return showToast(`Max cast size is ${MAX_CAST} queens.`, 'error');
        const seasonMode = getSelectedSeasonMode();
        const isBeaverFormat = seasonMode === 'beaver';
        if (seasonMode === 'allstars') {
            generateAllStarsSeason(relationships);
            return;
        }
        if (seasonMode === 'tournament') {
            generateTournamentAllStarsSeason(relationships);
            return;
        }
        const finaleTypeRaw = getSelectedFinaleType();
        const finaleLimit = parseInt(finaleTypeRaw, 10);
        const finaleFormat = finaleTypeRaw === '4crown' ? 'crown' : 'standard';
        if (selectedQueens.length <= finaleLimit) return showToast("Select more queens!", 'error');

        const isLuckyQueenTwist = document.getElementById('luckyQueenTwist') ? document.getElementById('luckyQueenTwist').checked : false;
        let luckyQueen = null;
        let luckyQueenUsed = false;

        let currentCast = [...selectedQueens];
        const castAtStart = [...selectedQueens];
        
        if (isLuckyQueenTwist && castAtStart.length > 0) {
            if (selectedLuckyQueen && castAtStart.includes(selectedLuckyQueen)) {
                luckyQueen = selectedLuckyQueen;
            } else {
                luckyQueen = castAtStart[Math.floor(Math.random() * castAtStart.length)];
            }
        }
        
        if (!relationships) {
            relationships = {};
            for (let i = 0; i < castAtStart.length; i++) {
                for (let j = i + 1; j < castAtStart.length; j++) {
                    relationships[getRelationshipKey(castAtStart[i], castAtStart[j])] = DEFAULT_RELATIONSHIP;
                }
            }
        }

        const episodes = [];
        const relationshipTension = (relationships && Object.keys(relationships).length > 0) ? {} : null;
    
        const stats = {};
        castAtStart.forEach(q => {
            stats[q] = { wins: 0, highs: 0, safe: 0, lows: 0, bottoms: 0, ppe: 0, totalPoints: 0, episodesCount: 0, consecutiveWins: 0, consecutiveHighs: 0 };
        });

        let recentWins = {};
        let epNum = 1;
        let doubleWinCount = 0;
        let lastDoubleWin = false;
        let doubleShantayUsed = false;
        const opener = (document.querySelector('input[name="seasonOpener"]:checked') || {}).value || 'Random';
        const challengeUsedCount = {};
        const useDoublePremiere = isDoublePremiereType(premiereType) && doublePremiereEp1Cast.length > 0 && doublePremiereEp2Cast.length > 0;

        const selectedReturnFormat = getSelectedReturnFormat();
        const returnEpisode = (selectedReturnFormat === 'choose')
            ? getReturnEpisodeForCast(selectedQueens.length, finaleLimit, premiereType)
            : null;
        const returnPlan = (returnEpisode && selectedQueens.length >= 6) ? { episode: returnEpisode, format: selectedReturnFormat } : null;
        
        const luckyQueenCtx = isLuckyQueenTwist ? { name: luckyQueen, used: luckyQueenUsed } : null;

        if (useDoublePremiere) {
            const openerChallenge = pickChallengeForEpisode(epNum, challengeUsedCount, opener, false, finaleLimit, castAtStart.length);
            const isElimPremiere = premiereType === 'double_elim';
            let group1 = doublePremiereEp1Cast.filter(q => currentCast.includes(q));
            let group2 = doublePremiereEp2Cast.filter(q => currentCast.includes(q));
            if (group1.length > 0) {
                const ep1Result = simulateDoublePremiereRegularEpisode(group1, openerChallenge, epNum, stats, recentWins, relationshipTension, relationships || {}, currentCast.length, finaleLimit, isBeaverFormat, isElimPremiere, doubleShantayUsed, luckyQueenCtx);
                if (isLuckyQueenTwist && group1.includes(luckyQueen)) {
                    ep1Result.epData.luckyQueenFound = luckyQueen;
                }
                if (luckyQueenCtx && luckyQueenCtx.used) luckyQueenUsed = true;

                episodes.push(ep1Result.epData);
                if (isElimPremiere && ep1Result.eliminated) {
                    currentCast = currentCast.filter(q => q !== ep1Result.eliminated);
                }
                if (ep1Result.doubleShantayUsed) doubleShantayUsed = true;
                group2 = group2.filter(q => currentCast.includes(q));
                epNum++;
            }
            if (group2.length > 0) {
                const ep2Result = simulateDoublePremiereRegularEpisode(group2, openerChallenge, epNum, stats, recentWins, relationshipTension, relationships || {}, currentCast.length, finaleLimit, isBeaverFormat, isElimPremiere, doubleShantayUsed, luckyQueenCtx);
                if (isLuckyQueenTwist && group2.includes(luckyQueen)) {
                    ep2Result.epData.luckyQueenFound = luckyQueen;
                }
                if (luckyQueenCtx && luckyQueenCtx.used) luckyQueenUsed = true;

                episodes.push(ep2Result.epData);
                if (isElimPremiere && ep2Result.eliminated) {
                    currentCast = currentCast.filter(q => q !== ep2Result.eliminated);
                }
                if (ep2Result.doubleShantayUsed) doubleShantayUsed = true;
                epNum++;
            }
            if (challengeUsedCount.usedCount && challengeUsedCount.usedCount[openerChallenge] !== undefined) {
                challengeUsedCount.usedCount[openerChallenge] += 1;
            }
        }

        while (currentCast.length > finaleLimit) {
            let luckyQueenSave = null;
            const isLastCompetitiveEp = currentCast.length === finaleLimit + 1;
            const chal = pickChallengeForEpisode(epNum, challengeUsedCount, opener, isLastCompetitiveEp, finaleLimit, castAtStart.length);
            const hasRunway = hasRunwayForChallenge(chal);
            if (returnPlan && epNum === returnPlan.episode) {
                const placeholder = {
                    episode: epNum,
                    challenge: chal,
                    displayChallenge: chal,
                    scores: [],
                    winners: [],
                    isDouble: false,
                    isDoubleShantay: false,
                    high: [],
                    safe: [],
                    low: [],
                    bottom: [],
                    eliminated: null,
                    remainingCount: currentCast.length,
                    isFinale: false,
                    hasRunway,
                    needsReturnPick: true,
                    returnFormat: returnPlan.format
                };
                episodes.push(placeholder);
                seasonData = {
                    episodes,
                    finale: [],
                    winner: null,
                    queenStats: stats,
                    castQueens: castAtStart,
                    finaleLimit: finaleLimit,
                    relationships,
                    isAllStars: false,
                    isTournament: false,
                    returnState: {
                        currentCast: [...currentCast],
                        castAtStart: [...castAtStart],
                        stats,
                        relationships,
                        relationshipTension,
                        recentWins,
                        epNum,
                        finaleLimit,
                        finaleFormat,
                        episodes: [...episodes],
                        isBeaverFormat,
                        challengeUsedCount,
                        opener,
                        doubleShantayUsed,
                        returnPlan,
                        eliminatedPool: castAtStart.filter(q => !currentCast.includes(q))
                    }
                };
                document.getElementById('setupPanel').classList.add('hidden');
                document.getElementById('scenarioScreen').classList.remove('hidden');
                setHeaderMode('scenario');
                currentEpIndex = 0;
                scenarioPhase = 0;
                renderScenario();
                return;
            }

            const scores = currentCast.map(q => {
                const queen = queensDb[q];
                const challengeStats = challengeConfig[chal];
                const base = challengeStats.reduce((acc, s) => acc + queen[s], 0) / challengeStats.length;
                const challengeTotal = base;
                
                const randomForChallenge = Math.random() * 5 - 2.5;
                const randomForRunway = hasRunway ? (Math.random() * 5 - 2.5) : 0;
                const randomTotal = 0;

                const challengeWithRandom = challengeTotal + randomForChallenge;

                let desc = "Safe";
                let statusClass = "perf-safe";

                if (challengeWithRandom > 12) { desc = "SLAYED!"; statusClass = "perf-slay"; }
                else if (challengeWithRandom > 8) { desc = "Great job"; statusClass = "perf-good"; }
                else if (challengeWithRandom > 6) { desc = "Okay"; statusClass = "perf-safe"; }
                else if (challengeWithRandom > 4) { desc = "Struggled"; statusClass = "perf-bad"; }
                else { desc = "FLOP"; statusClass = "perf-flop"; }

                let runwayTotal = 0;
                let runwayDesc = "";
                let runwayStatusClass = "";
                let runwayWithRandom = 0;
                
                if (hasRunway) {
                    const fashionBase = queen.fashion;
                    runwayTotal = fashionBase;
                    runwayWithRandom = runwayTotal + randomForRunway;

                    if (runwayWithRandom > 12) { runwayDesc = "SLAYED!"; runwayStatusClass = "perf-slay"; }
                    else if (runwayWithRandom > 8) { runwayDesc = "Great job"; runwayStatusClass = "perf-good"; }
                    else if (runwayWithRandom > 6) { runwayDesc = "Okay"; runwayStatusClass = "perf-safe"; }
                    else if (runwayWithRandom > 4) { runwayDesc = "Struggled"; runwayStatusClass = "perf-bad"; }
                    else { runwayDesc = "FLOP"; runwayStatusClass = "perf-flop"; }
                }

                const challengeWeighted = hasRunway ? challengeWithRandom * 0.8 : challengeWithRandom;
                const runwayWeighted = hasRunway ? runwayWithRandom * 0.2 : 0;
                const totalBase = challengeWeighted + runwayWeighted;

                const lastPlacement = stats && stats[q] ? stats[q].lastPlacement : null;
                let winModifier = 0;
                {
                    const consWins = (stats && stats[q]) ? (stats[q].consecutiveWins || 0) : 0;
                    const consHighs = (stats && stats[q]) ? (stats[q].consecutiveHighs || 0) : 0;
                    if (consWins > 0) {
                        winModifier = -1.25 - ((consWins - 1) * 0.5);
                    } else if (consHighs > 0) {
                        winModifier = -0.5 - ((consHighs - 1) * 0.25);
                    }
                }
                const total = totalBase + randomTotal + winModifier;

                return { 
                    name: q, 
                    total, 
                    totalBase,
                    challengeTotal: challengeWithRandom, 
                    runwayTotal: runwayWithRandom, 
                    challengeWeighted,
                    runwayWeighted,
                    randomTotal,
                    winModifier,
                    desc, 
                    statusClass, 
                    runwayDesc, 
                    runwayStatusClass, 
                    details: `(${challengeWithRandom.toFixed(1)})`,
                    runwayDetails: hasRunway ? `(${runwayWithRandom.toFixed(1)})` : '' 
                };
            }).sort((a,b) => b.total - a.total);

            // --- GIRL GROUPS TEAM LOGIC ---
            let winningTeam = null;
            let losingTeam = null;
            let groupScores = null;
            let teamAssignments = {};

            const isAllStarsSeason = currentCast.length > 0 && currentCast[0].includes("All Stars"); 
            
            if (chal === 'Girl Groups' && currentCast.length >= 4) {
                let numGroups = 2;
                if (currentCast.length >= 12) numGroups = 4;
                else if (currentCast.length >= 9) numGroups = 3;
                
                const shuffledQueens = [...scores];
                for (let i = shuffledQueens.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffledQueens[i], shuffledQueens[j]] = [shuffledQueens[j], shuffledQueens[i]];
                }

                const groups = [];
                for(let i=0; i<numGroups; i++) groups.push([]);
                
                shuffledQueens.forEach((q, index) => {
                    groups[index % numGroups].push(q);
                });

                groupScores = groups.map((group, idx) => {
                    const sum = group.reduce((acc, q) => {
                        const perfScore = (typeof q.totalBase === 'number' ? q.totalBase : 0) + 
                                          (typeof q.randomTotal === 'number' ? q.randomTotal : 0);
                        return acc + perfScore;
                    }, 0); 
                    const avg = sum / group.length;
                    return { id: idx, avg, members: group };
                });

                groupScores.sort((a, b) => b.avg - a.avg);
                winningTeam = groupScores[0];
                losingTeam = groupScores[groupScores.length - 1]; 
                winningTeam.members.forEach(m => teamAssignments[m.name] = 'WIN_TEAM');
            }

            let isDouble = !isBeaverFormat && scores[0].total > 11.5 && scores[1].total > 11.5 && Math.abs(scores[0].total - scores[1].total) < 1 && Math.random() < 0.35;
            let winners = isDouble ? scores.slice(0, 2) : scores.slice(0, 1);
            
            if (winningTeam) {
                const sortedWinners = [...winningTeam.members].sort((a, b) => b.total - a.total);
                winners = [sortedWinners[0]]; 
                isDouble = false;
            }
            
            const winnerNames = new Set(winners.map(w => w.name));
            const nonWinners = scores.filter(s => !winnerNames.has(s.name));

            let btm = [nonWinners[nonWinners.length - 1], nonWinners[nonWinners.length - 2]].filter(Boolean);
            
            let high = [], safe = [], low = [], highTeam = [];

            if (winningTeam) {
                const actualWinnerName = winners[0].name;

                winningTeam.members.forEach(m => {
                    if (m.name !== actualWinnerName) {
                        highTeam.push(m);
                    }
                });

                if (highTeam.length === 0 && winningTeam.members.length > 1) {
                    winningTeam.members.slice(1).forEach(m => highTeam.push(m));
                }

                const losingMembers = [...losingTeam.members].sort((a, b) => a.total - b.total);
                btm = [losingMembers[0], losingMembers[1]]; 
                
                for (let i = 2; i < losingMembers.length; i++) {
                    low.push(losingMembers[i]);
                }

                scores.forEach(s => {
                    const name = s.name;
                    if (!winnerNames.has(name) && !high.find(h => h.name === name) && !highTeam.find(ht => ht.name === name) && !btm.find(b => b.name === name) && !low.find(l => l.name === name)) {
                        safe.push(s);
                    }
                });

            } else {
                const remainingForSafe = nonWinners.filter(s => !btm.find(b => b.name === s.name));
                
                const highCount = Math.max(2, Math.floor(currentCast.length * 0.25));
                high = remainingForSafe.slice(0, highCount);
                
                const lowCount = Math.max(1, Math.floor(currentCast.length * 0.15));
                low = remainingForSafe.slice(remainingForSafe.length - lowCount);
                
                safe = remainingForSafe.filter(s => !high.includes(s) && !low.includes(s));
            }
            
            const others = nonWinners.filter(s => !btm.find(b => b.name === s.name));
            
            if (!winningTeam) {
                 high = others.slice(0, 2);
                 low = others.length > 2 ? [others[others.length-1]] : [];
                 safe = others.filter(s => !high.find(h => h.name === s.name) && !low.find(l => l.name === s.name));
            } else {
            }

            let beaverSaved = null;
            let beaverSavedForUI = null;
            let beaverBottom3 = null;
            let beaverReason = null;
            if (isBeaverFormat && currentCast.length > finaleLimit) {
                const nonWinners = scores.filter(s => !winners.some(w => w.name === s.name));
                
                if (winningTeam && losingTeam && losingTeam.members.length >= 3) {
                     const sortedLosers = [...losingTeam.members].sort((a,b) => a.total - b.total);
                     beaverBottom3 = sortedLosers.slice(0, 3);
                } 
                else if (nonWinners.length >= 3) {
                    beaverBottom3 = nonWinners.slice(-3);
                }

                if (beaverBottom3 && winners.length > 0) {
                    const saver = winners[0];
                    const saverName = saver.name;
                    const personality = getPersonalityForQueen(saverName);
                    const isFirstEpisode = epNum === 1;
                    
                    const beaverPick = beaverBottom3.reduce((best, s) => {
                        if (!best) return s;
                        const bestScore = getBeaverSaveScore(best, saverName, personality, stats, relationships || {}, isFirstEpisode);
                        const curScore = getBeaverSaveScore(s, saverName, personality, stats, relationships || {}, isFirstEpisode);
                        return curScore > bestScore ? s : best;
                    }, null);
                    
                    beaverSaved = beaverPick ? beaverPick.name : beaverBottom3[0].name;
                    beaverSavedForUI = beaverSaved;
                    beaverReason = getBeaverSaveReason(saverName, beaverSaved, personality, stats, relationships || {});
                    const lipSyncBottom = beaverBottom3.filter(s => s.name !== beaverSaved);
                    if (lipSyncBottom.length === 2) {
                        btm[0] = lipSyncBottom[0];
                        btm[1] = lipSyncBottom[1];
                    }
                }
            }

            if (beaverBottom3 && beaverBottom3.length) {
                const bottomNames = new Set(beaverBottom3.map(s => s.name));
                const filterNonBottom = arr => arr.filter(x => !bottomNames.has(x.name));
                if (high.length) {
                    const newHigh = filterNonBottom(high);
                    high.splice(0, high.length, ...newHigh);
                }
                if (highTeam && highTeam.length) {
                    const newHighTeam = filterNonBottom(highTeam);
                    highTeam.splice(0, highTeam.length, ...newHighTeam);
                }
                if (safe.length) {
                    const newSafe = filterNonBottom(safe);
                    safe.splice(0, safe.length, ...newSafe);
                }
                low.length = 0;
                if (winningTeam && losingTeam && losingTeam.members) {
                    const hasName = (arr, name) => arr.some(x => x.name === name);
                    losingTeam.members.forEach(m => {
                        if (bottomNames.has(m.name)) return;
                        if (hasName(winners, m.name)) return;
                        if (hasName(highTeam, m.name)) return;
                        if (hasName(high, m.name)) return;
                        if (hasName(safe, m.name)) return;
                        safe.push(m);
                    });
                }
            }

            // Lucky Queen Save Logic
            let luckyQueenTwistData = null;

            // --- RESTRICT LUCKY QUEEN TO REGULAR & BEAVER FORMATS ONLY ---
            const isRegularOrBeaver = !isAllStars;

            if (isRegularOrBeaver && luckyQueenCtx && !luckyQueenCtx.used && currentCast.length > finaleLimit + 1) {
                const lqIndex = btm.findIndex(b => b.name === luckyQueenCtx.name);
                if (lqIndex !== -1) {
                    let replacement = null;
                    let sourceArray = null;
                    
                    // Calculate original lip sync scores for twist reveal
                    const origLs1 = calcLipSyncScore(btm[0].name, 'btm2', stats);
                    const origLs2 = calcLipSyncScore(btm[1].name, 'btm2', stats);
                    const originalBottomData = [
                        { name: btm[0].name, score: origLs1.score, info: origLs1.breakdown },
                        { name: btm[1].name, score: origLs2.score, info: origLs2.breakdown }
                    ];

                    let replacementSourceTier = 'low'; // default fallback

                    if (low.length > 0) { replacement = low[low.length - 1]; sourceArray = low; replacementSourceTier = 'low'; }
                    else if (safe.length > 0) { replacement = safe[safe.length - 1]; sourceArray = safe; replacementSourceTier = 'safe'; }
                    else if (high.length > 0) { replacement = high[high.length - 1]; sourceArray = high; replacementSourceTier = 'high'; }
                    else if (highTeam && highTeam.length > 0) { replacement = highTeam[highTeam.length - 1]; sourceArray = highTeam; replacementSourceTier = 'highTeam'; }
                    else if (winners.length > 0) { replacement = winners[winners.length - 1]; sourceArray = winners; replacementSourceTier = 'win'; }
                    
                    if (isBeaverFormat && beaverSaved) {
                        const beaverQueen = scores.find(s => s.name === beaverSaved);
                        if (beaverQueen) {
                            replacement = beaverQueen;
                            
                            if (low.find(s => s.name === beaverSaved)) sourceArray = low;
                            else if (safe.find(s => s.name === beaverSaved)) sourceArray = safe;
                            else if (high.find(s => s.name === beaverSaved)) sourceArray = high;
                            else if (highTeam && highTeam.find(s => s.name === beaverSaved)) sourceArray = highTeam;
                            else if (winners.find(s => s.name === beaverSaved)) sourceArray = winners;
                            else sourceArray = null;

                            replacementSourceTier = 'beaver';
                            beaverSaved = null;
                        }
                    }

                    if (replacement) {
                        const lqObj = btm[lqIndex];
                        btm.splice(lqIndex, 1);
                        
                        const tiers = [low, safe, high, winners];
                        if (highTeam) tiers.push(highTeam);
                        
                        tiers.forEach(tier => {
                            const idx = tier.findIndex(s => s.name === replacement.name);
                            if (idx !== -1) tier.splice(idx, 1);
                        });
                        
                        low.push(lqObj);
                        
                        btm.push(replacement);
                        
                        luckyQueenCtx.used = true;
                        if (typeof luckyQueenUsed !== 'undefined') luckyQueenUsed = true;
                        luckyQueenSave = { saved: luckyQueenCtx.name, replaced: replacement.name };
                        
                        luckyQueenTwistData = {
                            savedQueen: luckyQueenCtx.name,
                            replacementQueen: replacement.name,
                            originalBottom: originalBottomData,
                            placementBeforeSave: 'btm',
                            replacementSourceTier: replacementSourceTier
                        };
                    }
                }
            }

            let untuckedScenes = [];
            if (relationshipTension) {
                const untucked = generateUntucked(winners, btm, [...high, ...highTeam], safe, low, stats, relationships, relationshipTension);
                untuckedScenes = untucked.scenes || [];
            }

            const ls1 = calcLipSyncScore(btm[0].name, 'btm2', stats);
            const ls2 = calcLipSyncScore(btm[1].name, 'btm2', stats);
            
            let elim = ls1.score < ls2.score ? btm[0].name : btm[1].name;
            const otherBtm = btm[0].name === elim ? btm[1].name : btm[0].name;
            if (stats[elim].ppe >= stats[otherBtm].ppe + RIGGORY_PPE_THRESHOLD) {
                elim = otherBtm;
            }
            let isDoubleSashay = false;
            if (ls1.score < 4 && ls2.score < 4 && Math.random() < 0.03 && currentCast.length > finaleLimit + 2) {
                elim = [btm[0].name, btm[1].name];
                isDoubleSashay = true;
            }

            let isDoubleShantay = false;
            const scoreDiff = Math.abs(ls1.score - ls2.score);
            const rollShantay = Math.random();
            if (ls1.score > 13 && ls2.score > 13 && scoreDiff < 1 && rollShantay < 0.30 && currentCast.length > finaleLimit + 2 && !doubleShantayUsed) {
                elim = null; isDoubleShantay = true; doubleShantayUsed = true;
            }
            if (elim) {
                if (Array.isArray(elim)) {
                    currentCast = currentCast.filter(q => !elim.includes(q));
                } else {
                    currentCast = currentCast.filter(q => q !== elim);
                }
            }
            const isBeaverEpisode = isBeaverFormat && beaverSaved;

            scores.forEach(s => {
                const name = s.name;
                const st = stats[name];
                let points = 0;
                let placement = null;

                const isBeaverQueen = isBeaverEpisode && name === beaverSaved;
                const inBottom = btm.find(b => b.name === name);

                if (winners.find(w => w.name === name) && !inBottom) { st.wins++; points = 5; placement = 'WIN'; } 
                else if (high.find(h => h.name === name) && !inBottom) { st.highs++; points = 4; placement = 'HIGH'; }
                else if (highTeam.find(h => h.name === name) && !inBottom) { st.highs++; points = 4; placement = 'HIGH TEAM'; }
                else if (safe.find(x => x.name === name) && !inBottom) { st.safe++; points = 3; placement = 'SAFE'; }
                else if (low.find(l => l.name === name) && !inBottom) { st.lows++; points = 2; placement = 'LOW'; }
                else if (inBottom || isBeaverQueen) {
                    st.bottoms++;
                    const isEliminated = Array.isArray(elim) ? elim.includes(name) : elim === name;
                    if (isEliminated) { points = 0; placement = 'ELIM'; }
                    else if (isBeaverQueen) { points = 2; placement = 'BTM'; }
                    else { points = 1; placement = 'BTM'; }
                }
                st.totalPoints += points;
                st.episodesCount++;
                st.ppe = st.totalPoints / st.episodesCount;
                st.lastPlacement = placement;

                if (placement === 'WIN') {
                    st.consecutiveWins = (st.consecutiveWins || 0) + 1;
                    st.consecutiveHighs = 0;
                } else if (placement === 'HIGH' || placement === 'HIGH TEAM') {
                    st.consecutiveHighs = (st.consecutiveHighs || 0) + 1;
                    st.consecutiveWins = 0;
                } else {
                    st.consecutiveWins = 0;
                    st.consecutiveHighs = 0;
                }
            });

            // Lucky Queen Found Logic (for regular premiere)
            let luckyQueenFound = null;
            if (epNum === 1 && isLuckyQueenTwist && luckyQueen) {
                luckyQueenFound = luckyQueen;
            }

            const epData = {
                episode: epNum,
                challenge: chal,
                scores: scores,
                winners, isDouble, isDoubleShantay, isDoubleSashay,
                high, highTeam, safe, low,
                bottom: [{ name: btm[0].name, score: ls1.score, info: ls1.breakdown }, { name: btm[1].name, score: ls2.score, info: ls2.breakdown }],
                eliminated: elim,
                remainingCount: currentCast.length,
                isFinale: false,
                hasRunway,
                isBeaverFormat,
                beaverSaved: beaverSavedForUI,
                beaverReason,
                beaverBottom3: beaverBottom3 ? beaverBottom3.map(s => s.name) : null,
                groups: (winningTeam || losingTeam) ? groupScores : null,
                lipSyncSong: window.pickRandomLipSyncSong ? window.pickRandomLipSyncSong() : '',
                luckyQueenFound,
                luckyQueenSave,
                luckyQueenTwistData
            };
            if (untuckedScenes.length > 0) epData.untucked = untuckedScenes;
            episodes.push(epData);
            epNum++;
        }
        const sortedByPPE = [...currentCast].sort((a, b) => stats[b].ppe - stats[a].ppe);
        const withWins = sortedByPPE.filter(q => stats[q].wins > 0);
        let winnerName = withWins.length > 0 ? withWins[0] : sortedByPPE[0];

        if (finaleLimit === 4 && finaleFormat === 'crown') {
            const shuffled = [...currentCast].map(x => ({ x, r: Math.random() })).sort((a, b) => a.r - b.r).map(o => o.x);
            const pair1 = [shuffled[0], shuffled[1]];
            const pair2 = [shuffled[2], shuffled[3]];
            const runMatch = (a, b) => {
                const sa = calcLipSyncScore(a, 'lalaparuza', stats);
                const sb = calcLipSyncScore(b, 'lalaparuza', stats);
                const aWins = sa.score >= sb.score;
                const winner = aWins ? a : b;
                const loser = aWins ? b : a;
                const song = (window.pickRandomLipSyncSong && typeof window.pickRandomLipSyncSong === 'function')
                    ? window.pickRandomLipSyncSong()
                    : '';
                return {
                    a, b,
                    scoreA: sa.score, breakdownA: sa.breakdown,
                    scoreB: sb.score, breakdownB: sb.breakdown,
                    winner, loser,
                    song
                };
            };
            const m1 = runMatch(pair1[0], pair1[1]);
            const m2 = runMatch(pair2[0], pair2[1]);
            const finalLipSyncQueens = [m1.winner, m2.winner];
            const finalSorted = finalLipSyncQueens.map(q => calcLipSyncScore(q, 'finale', stats)).sort((a, b) => b.score - a.score);
                        if (finalLipSyncQueens.length >= 2) {
                const q1 = finalLipSyncQueens[0];
                const q2 = finalLipSyncQueens[1];
                const ppe1 = stats[q1] ? stats[q1].ppe : 0;
                const ppe2 = stats[q2] ? stats[q2].ppe : 0;
                winnerName = ppe1 >= ppe2 ? q1 : q2;
            } else {
                winnerName = finalLipSyncQueens[0] || currentCast[0];
            }
            const lostRound1 = [m1.loser].filter(Boolean);
            const lostRound2 = [m2.loser].filter(Boolean);
            const lostRound3 = finalLipSyncQueens.filter(q => q !== winnerName);
            const eliminatedInFinale = [...lostRound2, ...lostRound1];
            const runnerUps = finalLipSyncQueens.filter(q => q !== winnerName);
            episodes.push({
                episode: epNum,
                challenge: "Grand Finale — Lip Sync For The Crown",
                scores: [],
                winners: [{ name: winnerName, total: 100 }],
                isDouble: false,
                isDoubleShantay: false,
                high: [],
                safe: [],
                low: [],
                bottom: [],
                eliminated: null,
                remainingCount: currentCast.length,
                isFinale: true,
                isCrownFinale: true,
                finalists: currentCast,
                crownRound1: [m1],
                crownRound2: [m2],
                finalLipSyncQueens,
                finalLipSyncScores: finalSorted,
                eliminatedInFinale,
                lostRound1,
                lostRound2,
                lostRound3,
                runnerUps
            });
        } else {
            const finalePerformanceScores = currentCast.map(q => {
                const queen = queensDb[q];
                const performanceScore = queen.performance;
                const lipsyncScore = queen.lipsync;
                const luck = Math.random() * 7;
                const total = (performanceScore + lipsyncScore) / 2 + luck;
                
                return {
                    name: q,
                    total: total,
                    performanceScore: performanceScore,
                    lipsyncScore: lipsyncScore,
                    luck: luck,
                    passed: total >= 8
                };
            }).sort((a, b) => b.total - a.total);

            let finalLipSyncQueens = [];
            
            if (finaleLimit === 3) {
                const eligibleQueens = sortedByPPE.filter(q => {
                    const perfScore = finalePerformanceScores.find(s => s.name === q);
                    return perfScore && perfScore.passed && stats[q].wins > 0;
                });
                
                if (eligibleQueens.length === 0) {
                    finalLipSyncQueens = sortedByPPE.slice(0, 2).filter(q => stats[q].wins > 0);
                } else if (eligibleQueens.length >= 3) {
                    const ppe2 = stats[eligibleQueens[1]].ppe;
                    const ppe3 = stats[eligibleQueens[2]].ppe;
                    const diff = ppe2 - ppe3;
                    
                    if (diff <= 0.1) {
                        finalLipSyncQueens = eligibleQueens.slice(0, 3);
                    } else {
                        finalLipSyncQueens = eligibleQueens.slice(0, 2);
                    }
                } else {
                    finalLipSyncQueens = eligibleQueens.length >= 2 ? eligibleQueens : sortedByPPE.slice(0, 2).filter(q => stats[q].wins > 0);
                }
            } else if (finaleLimit === 4) {
                const eligibleQueens = sortedByPPE.filter(q => {
                    const perfScore = finalePerformanceScores.find(s => s.name === q);
                    return perfScore && perfScore.passed && stats[q].wins > 0;
                });
                
                if (eligibleQueens.length === 0) {
                    finalLipSyncQueens = sortedByPPE.slice(0, 2).filter(q => stats[q].wins > 0);
                } else if (eligibleQueens.length >= 4) {
                    const ppe3 = stats[eligibleQueens[2]].ppe;
                    const ppe4 = stats[eligibleQueens[3]].ppe;
                    const diff34 = ppe3 - ppe4;
                    
                    if (diff34 <= 0.1) {
                        finalLipSyncQueens = eligibleQueens.slice(0, 4);
                    } else {
                        const ppe2 = stats[eligibleQueens[1]].ppe;
                        const ppe3_2 = stats[eligibleQueens[2]].ppe;
                        const diff23 = ppe2 - ppe3_2;
                        
                        if (diff23 <= 0.3) {
                            finalLipSyncQueens = eligibleQueens.slice(0, 3);
                        } else {
                            finalLipSyncQueens = eligibleQueens.slice(0, 2);
                        }
                    }
                } else {
                    finalLipSyncQueens = eligibleQueens.length >= 2 ? eligibleQueens : sortedByPPE.slice(0, 2).filter(q => stats[q].wins > 0);
                }
            }
            
            if (finalLipSyncQueens.length < 2) {
                const withWins = sortedByPPE.filter(q => stats[q].wins > 0).slice(0, 2);
                if (withWins.length >= 2) {
                    finalLipSyncQueens = withWins;
                } else {
                    finalLipSyncQueens = sortedByPPE.slice(0, 2);
                }
            }
            
            const finalLipSyncScores = finalLipSyncQueens.map(q => calcLipSyncScore(q, 'finale', stats)).sort((a, b) => b.score - a.score);
            
            const withWins = sortedByPPE.filter(q => stats[q].wins > 0);
            winnerName = withWins.length > 0 ? withWins[0] : sortedByPPE[0];
            
            const eliminatedInFinale = currentCast.filter(q => !finalLipSyncQueens.includes(q));
            const runnerUps = finalLipSyncQueens.filter(q => q !== winnerName);
            
            episodes.push({
                episode: epNum,
                challenge: "Grand Finale Performance",
                scores: finalePerformanceScores,
                winners: [{name: winnerName, total: 100}],
                isDouble: false,
                isDoubleShantay: false,
                high: [],
                safe: [],
                low: [],
                bottom: [],
                eliminated: null,
                remainingCount: currentCast.length,
                isFinale: true,
                finalists: finalLipSyncQueens,
                finalePerformanceScores: finalePerformanceScores,
                finalLipSyncQueens: finalLipSyncQueens,
                finalLipSyncScores: finalLipSyncScores,
                eliminatedInFinale: eliminatedInFinale,
                runnerUps: runnerUps
            });
        }

        seasonData = { episodes, finale: currentCast, winner: winnerName, queenStats: stats, castQueens: castAtStart, finaleLimit: finaleLimit, finaleFormat: finaleFormat, relationships };
        document.getElementById('setupPanel').classList.add('hidden');
        document.getElementById('scenarioScreen').classList.remove('hidden');
        setHeaderMode('scenario');
        currentEpIndex = 0;
        scenarioPhase = 0;
        renderScenario();
    }

    function toggleLipReveal(key) {
        const val = document.getElementById(`lipVal_${key}`);
        const btn = document.getElementById(`lipBtn_${key}`);
        if (!val || !btn) return;
        const show = val.getAttribute('data-show') || 'score';
        if (show === 'result') {
            val.textContent = val.getAttribute('data-score') || '';
            val.className = val.getAttribute('data-score-class') || '';
            val.setAttribute('data-show', 'score');
            btn.textContent = 'Reveal';
        } else {
            val.textContent = val.getAttribute('data-result') || '';
            val.className = val.getAttribute('data-result-class') || '';
            val.setAttribute('data-show', 'result');
            btn.textContent = 'Score';
        }
    }

    function openEpisodeBreakdown() {
        const el = document.getElementById('episodeBreakdownOverlay');
        if (el) el.classList.remove('hidden');
    }

    function closeEpisodeBreakdown() {
        const el = document.getElementById('episodeBreakdownOverlay');
        if (el) el.classList.add('hidden');
    }

    function renderEpisodeBreakdown(ep) {
        const formatScore = (v) => (typeof v === 'number' && isFinite(v)) ? v.toFixed(2) : '0.00';
        
        const hasRunway = (ep.scores || []).some(s => (typeof s.runwayWeighted === 'number' && s.runwayWeighted > 0));
        const chalHeader = hasRunway ? "Challenge Score" : "Challenge Score";
        const runHeader = hasRunway ? "Runway Score" : "Runway Score";

        const scoreRows = (ep.scores || [])
            .map(s => {
                const qName = s.name || s;
                const random = (typeof s.randomTotal === 'number') ? s.randomTotal : 0;
                
                const challenge = (typeof s.challengeWeighted === 'number') ? s.challengeWeighted : 0;
                const runway = (typeof s.runwayWeighted === 'number') ? s.runwayWeighted : 0;
                
                const penalty = (typeof s.winModifier === 'number') ? s.winModifier : 0;
                const total = (typeof s.total === 'number') ? s.total : 0;
                return { qName, challenge, runway, random, penalty, total };
            })
            .sort((a, b) => b.total - a.total)
            .map(row => `
                <tr class="border-b border-gray-100 last:border-0">
                    <td class="py-2 pr-3 text-[11px] font-semibold text-gray-900">${row.qName}</td>
                    <td class="py-2 px-2 text-[11px] text-gray-600 text-right">${formatScore(row.challenge)}</td>
                    <td class="py-2 px-2 text-[11px] text-gray-600 text-right">${formatScore(row.runway)}</td>
                    <td class="py-2 px-2 text-[11px] text-gray-600 text-right">${formatScore(row.penalty)}</td>
                    <td class="py-2 pl-2 text-[11px] font-semibold text-gray-900 text-right">${formatScore(row.total)}</td>
                </tr>
            `).join('');
        const scoreRowsHtml = scoreRows || `<tr><td class="py-3 text-[11px] text-gray-500" colspan="5">No episode data.</td></tr>`;
        return `
            <div class="mt-6 flex justify-center">
                <button type="button" onclick="openEpisodeBreakdown()" class="px-4 py-2 rounded-full text-[11px] font-bold text-gray-700 bg-gray-100 hover:bg-gray-200">Score breakdown</button>
            </div>
            <div id="episodeBreakdownOverlay" class="fixed inset-0 bg-black/40 z-50 hidden">
                <div class="absolute inset-0" onclick="closeEpisodeBreakdown()"></div>
                <div class="relative mx-auto mt-10 w-full max-w-3xl bg-white rounded-2xl p-5 shadow-xl">
                    <div class="flex items-center justify-between mb-3">
                        <div class="text-[11px] font-black uppercase text-gray-700">Episode score breakdown</div>
                        <button type="button" onclick="closeEpisodeBreakdown()" class="text-[10px] font-bold text-gray-500 hover:text-gray-700">Close</button>
                    </div>
                    <div class="overflow-x-auto">
                        <table class="w-full text-[11px]">
                            <thead>
                                <tr class="text-[10px] uppercase text-gray-400">
                                    <th class="py-2 pr-3 text-left font-black">Queen</th>
                                    <th class="py-2 px-2 text-right font-black">${chalHeader}</th>
                                    <th class="py-2 px-2 text-right font-black">${runHeader}</th>
                                    <th class="py-2 px-2 text-right font-black">Penalty</th>
                                    <th class="py-2 pl-2 text-right font-black">Total</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${scoreRowsHtml}
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        `;
    }

    function renderScenario() {
        const stage = document.getElementById('stageContent');
        const debug = document.getElementById('debugInfo');
        const btn = document.getElementById('nextBtn');
        const epLabel = document.getElementById('episodeLabel');
        const episodeNavLabel = document.getElementById('episodeNavLabel');
        const castLabel = document.getElementById('castLeftLabel');
        const chalLabel = document.getElementById('scenarioChallengeLabel');
        const prevEpBtn = document.getElementById('prevEpBtn');
        const nextEpBtn = document.getElementById('nextEpBtn');
        const trackDiv = document.getElementById('trackRecordContainer');
        const trackPlaceholder = document.getElementById('trackRecordPlaceholder');
        if (trackDiv && trackPlaceholder && trackDiv.parentElement !== trackPlaceholder.parentElement) {
            trackPlaceholder.parentElement.insertBefore(trackDiv, trackPlaceholder.nextSibling);
        }
        if (btn) {
            btn.classList.remove('hidden');
            btn.onclick = advanceScenario;
        }

        const getSoftmaxProbabilitiesByName = (items, scoreKey, temperature) => {
            const arr = Array.isArray(items) ? items : [];
            const key = scoreKey || 'total';
            const t = Math.max(0.25, temperature || 1);

            let max = -Infinity;
            for (let i = 0; i < arr.length; i++) {
                const v = Number(arr[i] && arr[i][key]);
                if (isFinite(v) && v > max) max = v;
            }

            let sum = 0;
            const weights = new Array(arr.length);
            for (let i = 0; i < arr.length; i++) {
                const v = Number(arr[i] && arr[i][key]);
                const w = Math.exp(((isFinite(v) ? v : -Infinity) - max) / t);
                weights[i] = w;
                sum += w;
            }

            const out = {};
            if (!(sum > 0) || !isFinite(sum)) {
                const p = arr.length ? 1 / arr.length : 0;
                for (let i = 0; i < arr.length; i++) {
                    const name = arr[i] && arr[i].name;
                    if (name) out[name] = p;
                }
                return out;
            }

            for (let i = 0; i < arr.length; i++) {
                const name = arr[i] && arr[i].name;
                if (!name) continue;
                out[name] = weights[i] / sum;
            }
            return out;
        };

        if (currentEpIndex >= seasonData.episodes.length) {
            renderFinale();
            return;
        }

        const ep = seasonData.episodes[currentEpIndex];
        if (!ep.lipSyncSong) {
            ep.lipSyncSong = pickRandomLipSyncSong();
        }
        epLabel.innerText = ep.isFinale ? 'Finale' : `Episode ${ep.episode}`;
        const eliminatedCount = Array.isArray(ep.eliminated)
            ? ep.eliminated.filter(Boolean).length
            : (ep.eliminated ? 1 : 0);
        castLabel.innerText = `${ep.remainingCount + eliminatedCount} Queens`;

        const getChallengeLabel = () => {
            if (ep.isFinale) return '';
            const name = String(ep.displayChallenge || ep.challenge || '').trim();
            if (!name) return 'MAXI CHALLENGE';
            const upper = name.toUpperCase();
            if (upper.includes('CHALLENGE')) return upper;
            if (upper.includes('FINAL')) return upper;
            return `${upper} CHALLENGE`;
        };
        if (chalLabel) {
            const label = getChallengeLabel();
            chalLabel.textContent = label;
            chalLabel.classList.toggle('hidden', !label);
        }

        if (prevEpBtn) prevEpBtn.disabled = currentEpIndex <= 0;
        if (nextEpBtn) nextEpBtn.disabled = currentEpIndex >= seasonData.episodes.length - 1;
        if (episodeNavLabel) episodeNavLabel.textContent = `Episode ${Math.min(currentEpIndex + 1, seasonData.episodes.length)} / ${seasonData.episodes.length}`;

        const needsAllStarsReturnPick = !!(seasonData.isAllStars && ep.isAllStars && seasonData.returnState && ep.needsReturnPick);
        if (needsAllStarsReturnPick && scenarioPhase === 1) {
            const pool = (seasonData.returnState && Array.isArray(seasonData.returnState.eliminatedPool))
                ? seasonData.returnState.eliminatedPool
                : [];
            
            const prevEpIndex = currentEpIndex - 1;
            const maxEp = prevEpIndex >= 0 && seasonData.episodes[prevEpIndex] ? seasonData.episodes[prevEpIndex].episode : 0;
            const currentStatsArray = calculateQueenStats(seasonData, maxEp);
            const stats = {};
            currentStatsArray.forEach(s => { stats[s.name] = s; });

            const defaultPick = pool.length > 0
                ? [...pool].sort((a, b) => {
                    const ppeA = stats[a]?.ppe ?? -Infinity;
                    const ppeB = stats[b]?.ppe ?? -Infinity;
                    const tpA = stats[a]?.totalPoints ?? 0;
                    const tpB = stats[b]?.totalPoints ?? 0;
                    return (ppeB - ppeA) || (tpB - tpA) || String(a).localeCompare(String(b));
                })[0]
                : '';
            btn.classList.add('hidden');
            stage.innerHTML = `
                <div class="w-full text-center">
                    <h3 class="text-xl font-bold mb-2">Bring Back a Queen</h3>
                    <p class="text-sm text-gray-500 mb-5">Choose one eliminated queen to return.</p>
                    <div class="w-full max-w-md mx-auto px-3">
                        <div class="scenario-card perf-safe p-4 rounded-xl flex flex-col items-center gap-3 border border-gray-200 bg-white shadow-sm text-center">
                            <img
                                id="returnPickImg"
                                src="${defaultPick && queensDb[defaultPick] ? queensDb[defaultPick].photo : ''}"
                                class="queen-img-lg ${defaultPick ? '' : 'hidden'}"
                                alt=""
                            >
                            <div id="returnPickName" class="font-black text-lg text-gray-800 truncate w-full">${defaultPick || 'Select a queen…'}</div>
                            <span
                                id="returnPickPpe"
                                class="${defaultPick ? '' : 'hidden'} px-3 py-1 bg-pink-100 text-pink-700 rounded-full text-xs font-bold whitespace-nowrap"
                            >${defaultPick ? `${(stats[defaultPick]?.ppe ?? 0).toFixed(2)} PPE` : ''}</span>
                        </div>

                        <div class="mt-4 flex flex-col items-center gap-4">
                            <select
                                id="returnPickSelect"
                                class="w-full max-w-xs p-2 rounded-lg bg-white border border-gray-300 text-sm"
                                onchange="onReturnPickChange()"
                            >
                                ${pool.length === 0 ? `<option value="" selected>(No eliminated queens)</option>` : ''}
                                ${pool.map(name => {
                                    const safeVal = String(name).replace(/"/g, '&quot;');
                                    const selected = name === defaultPick ? 'selected' : '';
                                    return `<option value="${safeVal}" ${selected}>${name}</option>`;
                                }).join('')}
                            </select>

                            <button
                                id="returnPickBtn"
                                type="button"
                                class="${defaultPick ? 'px-4 py-2 rounded-xl bg-pink-600 hover:bg-pink-700 text-white font-bold text-sm' : 'px-4 py-2 rounded-xl bg-gray-200 text-gray-500 font-bold text-sm cursor-not-allowed'}"
                                onclick="confirmReturnPick()"
                                ${defaultPick ? '' : 'disabled'}
                            >Return Queen</button>
                        </div>
                    </div>
                </div>
            `;
            debug.innerText = "Return Queen";
            return;
        }

        if (seasonData.isAllStars && ep.isAllStars && !ep.isFinale) {
            if (scenarioPhase === 0) {
                const hasLipstickReveal = !!(ep.lipstickChoices && Object.keys(ep.lipstickChoices).length);
                const runwayLine = (ep.hasRunway !== undefined ? ep.hasRunway : hasRunwayForChallenge(ep.challenge))
                    ? `<div class="mt-2 sc-caption font-heading font-bold text-gray-400">☆ Runway ☆</div>`
                    : '';
                trackDiv.classList.add('hidden');
                if (btn) {
                    btn.classList.remove('hidden');
                    btn.innerHTML = "START";
                }
                stage.innerHTML = `
                    <div class="mx-auto h-14 w-14 rounded-full bg-pink-100 flex items-center justify-center p-3">
                        <img src="images/all-stars.svg" class="w-full h-full object-contain">
                    </div>
                    <div class="mt-6 text-[10px] font-black text-gray-400 uppercase">${ep.isTournament ? 'TOURNAMENT OF ALL STARS' : 'ALL STARS'}</div>
                    <div class="mt-2 font-heading text-3xl sm:text-4xl font-bold text-[#ec4899]">${ep.displayChallenge || ep.challenge}</div>
                    ${runwayLine}
                    <div class="mt-3 text-sm text-gray-500">
                        ${ep.isTournament
                            ? `${ep.tournamentStage ? (ep.tournamentStage) : ''}, may the best drag queen win!`
                            : (hasLipstickReveal
                                ? 'May the best All Star win!'
                                : 'May the best All Star win!')}
                    </div>
                `;
                debug.innerText = "Challenge";
                if (btn) btn.innerHTML = "START";
            } else if (scenarioPhase === 1) {
                if (ep.challenge === 'Girl Groups' && ep.groups && !ep.groupsShown) {
                    if (btn) {
                        btn.classList.remove('hidden');
                        btn.innerHTML = "Start Performances";
                        btn.onclick = () => {
                            ep.groupsShown = true;
                            renderScenario();
                        };
                    }

                    let groupsHtml = `<div class="grid grid-cols-1 md:grid-cols-2 gap-4 w-full max-w-5xl">`;
                    ep.groups.forEach((group, idx) => {
                        groupsHtml += `
                            <div class="w-full rounded-2xl border border-gray-200/70 bg-white/80 shadow-sm overflow-hidden">
                                <div class="flex items-center justify-center px-4 py-3 border-b border-gray-100">
                                    <div class="text-xs font-black text-gray-400 uppercase tracking-wider">Group ${idx + 1}</div>
                                </div>
                                <div class="p-3 grid grid-cols-1 sm:grid-cols-2 gap-2">
                                    ${group.members.map(m => `
                                        <div class="scenario-card perf-safe p-2 rounded-xl flex items-center gap-2">
                                            <img src="${queensDb[m.name].photo}" class="queen-img-sm">
                                            <div class="text-left flex-1 min-w-0">
                                                <div class="font-bold text-sm truncate">${m.name}</div>
                                            </div>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        `;
                    });
                    groupsHtml += `</div>`;

                    stage.innerHTML = `
                    <div class="flex flex-col items-center w-full h-full animate-fade-in pt-4 overflow-y-auto">
                        <div class="w-full flex items-center justify-center max-w-5xl px-2">
                            <div class="sc-section font-heading font-bold text-gray-900 text-center">Groups</div>
                            </div>
                            <div class="mt-3 w-full flex justify-center">
                                ${groupsHtml}
                            </div>
                        </div>
                    `;
                    debug.innerText = "Groups Distribution";
                    return;
                }

                if (btn) btn.classList.remove('hidden');
                const hasRunway = ep.hasRunway !== undefined ? ep.hasRunway : hasRunwayForChallenge(ep.challenge);
                const showRunway = hasRunway && ep.runwayShown;
                
                const perfScores = [...(ep.scores || [])].sort((a, b) => (b.challengeTotal || 0) - (a.challengeTotal || 0));
                const runwayScores = hasRunway ? [...(ep.scores || [])].sort((a, b) => (b.runwayTotal || 0) - (a.runwayTotal || 0)) : [];
                
                const runwayTitle = ep.runway ? String(ep.runway).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/"/g, '&quot;') : '';
                stage.innerHTML = `
                    <div class="w-full self-stretch flex flex-col items-stretch text-left">
                        <div class="w-full flex items-center justify-start gap-2 self-start">
                            <img src="images/mask.svg" class="w-5 h-5 object-contain">
                            <div class="sc-section font-heading font-bold text-gray-900 text-left">Performances</div>
                        </div>
                        <div class="mt-3 rounded-2xl border border-gray-200/70 bg-gray-50/40 overflow-hidden">
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-2 p-2 max-h-[320px] overflow-y-auto">
                                ${perfScores.map(s => `
                                    <div class="scenario-card ${s.statusClass} p-3 rounded-xl flex items-center gap-3 min-h-[64px]">
                                        <img src="${queensDb[s.name].photo}" class="queen-img-sm">
                                        <div class="text-left flex-1 min-w-0">
                                            <div class="font-bold text-sm truncate">${s.name}</div>
                                            <div class="text-[11px] text-gray-600 leading-snug">${s.desc}</div>
                                        </div>
                                        <div class="text-[9px] text-gray-400 font-mono text-right whitespace-nowrap ml-2">${s.details}</div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        ${showRunway ? `
                        <div class="mt-5">
                            <div class="w-full flex items-center justify-start gap-2 self-start">
                                <img src="images/stars.svg" class="w-5 h-5 object-contain">
                                <div class="sc-section font-heading font-bold text-gray-900 text-left">Runway</div>
                                ${runwayTitle ? `<span class="text-xs text-gray-400 truncate">"${runwayTitle}"</span>` : ''}
                            </div>
                            <div class="mt-3 rounded-2xl border border-gray-200/70 bg-gray-50/40 overflow-hidden">
                                <div class="grid grid-cols-1 md:grid-cols-2 gap-2 p-2 max-h-[320px] overflow-y-auto">
                                    ${runwayScores.map(s => `
                                        <div class="scenario-card ${s.runwayStatusClass || 'perf-safe'} p-3 rounded-xl flex items-center gap-3 min-h-[64px]">
                                            <img src="${queensDb[s.name].photo}" class="queen-img-sm">
                                            <div class="text-left flex-1 min-w-0">
                                                <div class="font-bold text-sm truncate">${s.name}</div>
                                                <div class="text-[11px] text-gray-600 leading-snug">${s.runwayDesc || 'Runway'}</div>
                                            </div>
                                            <div class="text-[9px] text-gray-400 font-mono text-right whitespace-nowrap ml-2">${s.runwayDetails || ''}</div>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        </div>` : ''}
                    </div>
                `;
                debug.innerText = "Performance Review";
                if (hasRunway && !ep.runwayShown) {
                    btn.innerHTML = "Runway";
                } else {
                    btn.innerHTML = "Call The Safe Queens";
                }
            } else if (scenarioPhase === 2) {
                const safes = (ep.safe || []).map(s => s.name);
                if (safes.length === 0) {
                    scenarioPhase++;
                    renderScenario();
                    return;
                }
                stage.innerHTML = `
                    <div class="w-full flex flex-col items-center gap-5 text-center">
                        <div class="flex flex-col items-center gap-2">
                            <h3 class="sc-section font-bold w-full text-center">You are Safe...</h3>
                            <div class="h-0.5 w-14 rounded-full bg-gray-200"></div>
                        </div>
                        <div class="w-full max-w-[880px] flex justify-center">
                            <div class="flex flex-wrap justify-center gap-x-8 gap-y-6">
                                ${safes.map(name => `
                                    <div class="flex flex-col items-center w-32">
                                        <img src="${queensDb[name].photo}" class="queen-img-md grayscale opacity-80">
                                        <span class="mt-2 text-[12px] sm:text-[13px] font-semibold text-gray-800 text-center leading-snug truncate w-full">${name}</span>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        <p class="text-[14px] text-gray-500">Please step to the back of the stage.</p>
                    </div>
                `;
                debug.innerText = "Safe Declarations";
                btn.innerHTML = "Critiques";
            } else if (scenarioPhase === 3) {
                const isDoublePremiere = !!ep.isDoublePremiere;
                const top2 = ep.top2 || ep.winners || [];
                const high = ep.high || [];
                const highTeamRaw = ep.highTeam || [];
                const highTeam = highTeamRaw.length ? highTeamRaw : ((ep.challenge === 'Girl Groups' && ep.groups && ep.groups.length)
                    ? (() => {
                        const sortedGroups = [...ep.groups].sort((a, b) => (b.avg || 0) - (a.avg || 0));
                        const winningGroup = sortedGroups[0];
                        if (!winningGroup || !winningGroup.members) return [];
                        const winnerNames = new Set((ep.winners || []).map(w => w.name || w));
                        return winningGroup.members.filter(m => !winnerNames.has(m.name || m));
                    })()
                    : []);
                const low = ep.low || [];
                const bottom = ep.bottom || [];
                const hasBeaver = ep.isBeaverFormat && ep.beaverBottom3 && ep.beaverBottom3.length;
                const topsList = [...top2, ...high, ...highTeam];
                const bottomsList = hasBeaver
                    ? ep.beaverBottom3.map(name => {
                        const sObj = ep.scores.find(s => s.name === name) || { total: 0 };
                        return { name, total: sObj.total };
                    })
                    : [...low, ...bottom];
                const noRealBottoms = isDoublePremiere && !hasBeaver && low.length === 0 && bottom.length === 0;
                const epScores = Array.isArray(ep.scores) ? ep.scores : [];
                const episodeScoreText = (name) => {
                    const sObj = epScores.find(s => s.name === name) || {};
                    const val = (typeof sObj.score === 'number' && isFinite(sObj.score))
                        ? sObj.score
                        : (typeof sObj.total === 'number' && isFinite(sObj.total)) ? sObj.total : 0;
                    return (typeof val === 'number' && isFinite(val)) ? val.toFixed(1) : '0.0';
                };
                stage.innerHTML = `
                    <div class="w-full flex items-center justify-center">
                        <div class="w-full max-w-4xl">
                            <div class="text-center sc-label text-blue-600">THE TOPS</div>
                            <div class="mt-5 flex flex-wrap items-start justify-center gap-x-10 gap-y-7">
                                ${topsList.map(q => {
                                    const qName = q.name || q;
                                    return `
                                        <div class="flex flex-col items-center w-32">
                                            <div class="h-[92px] w-[92px] rounded-full p-[3px] bg-blue-200/60">
                                                <img src="${queensDb[qName].photo}" class="h-full w-full rounded-full object-cover border-2 border-white shadow-md">
                                            </div>
                                            <div class="mt-2 text-[12px] sm:text-[13px] font-bold text-gray-900 text-center leading-snug truncate w-full">${qName}</div>
                                            <div class="mt-1 text-[10px] font-bold text-blue-600">${episodeScoreText(qName)}</div>
                                        </div>
                                    `;
                                }).join('')}
                            </div>

                            <div class="mt-7 flex items-center gap-4">
                                <div class="h-px flex-1 bg-gray-200"></div>
                                <div class="text-[10px] font-black text-gray-400">VS</div>
                                <div class="h-px flex-1 bg-gray-200"></div>
                            </div>

                            <div class="mt-7 text-center sc-label text-rose-500">THE BOTTOMS</div>
                            <div class="mt-5 flex flex-wrap items-start justify-center gap-x-10 gap-y-7">
                                ${(noRealBottoms || bottomsList.length === 0)
                                    ? `<div class="text-[12px] font-semibold text-gray-500">No one is going home tonight.</div>`
                                    : bottomsList.map(q => {
                                        const qName = q.name || q;
                                        return `
                                            <div class="flex flex-col items-center w-32">
                                                <div class="h-[92px] w-[92px] rounded-full p-[3px] bg-rose-200/60">
                                                    <img src="${queensDb[qName].photo}" class="h-full w-full rounded-full object-cover border-2 border-white shadow-md">
                                                </div>
                                                <div class="mt-2 text-[12px] sm:text-[13px] font-bold text-gray-900 text-center leading-snug truncate w-full">${qName}</div>
                                                <div class="mt-1 text-[10px] font-bold text-rose-500">${episodeScoreText(qName)}</div>
                                            </div>
                                        `;
                                    }).join('')}
                            </div>
                            ${renderEpisodeBreakdown(ep)}
                        </div>
                    </div>
                `;
                debug.innerText = "Judges Critiques";
                btn.innerHTML = "Reveal Top 2";
            } else if (scenarioPhase === 4) {
                const isDoublePremiere = !!ep.isDoublePremiere;
                const top2 = ep.top2 || ep.winners || [];
                const high = ep.high || [];
                const highTeamRaw = ep.highTeam || [];
                const highTeam = highTeamRaw.length ? highTeamRaw : ((ep.challenge === 'Girl Groups' && ep.groups && ep.groups.length)
                    ? (() => {
                        const sortedGroups = [...ep.groups].sort((a, b) => (b.avg || 0) - (a.avg || 0));
                        const winningGroup = sortedGroups[0];
                        if (!winningGroup || !winningGroup.members) return [];
                        const winnerNames = new Set((ep.winners || []).map(w => w.name || w));
                        return winningGroup.members.filter(m => !winnerNames.has(m.name || m));
                    })()
                    : []);
                const low = ep.low || [];
                const bottom = ep.bottom || [];
                const hasBeaver = ep.isBeaverFormat && ep.beaverBottom3 && ep.beaverBottom3.length;

                let twistMessage = '';
                if (ep.luckyQueenFound) {
                    twistMessage += `
                        <div class="mb-6 w-full max-w-2xl mx-auto bg-pink-100 border-2 border-pink-400 rounded-xl p-4 flex items-center gap-4 shadow-md animate-bounce-in">
                            <div class="h-12 w-12 flex-shrink-0 bg-white rounded-full flex items-center justify-center text-2xl">🗽</div>
                            <div class="text-left">
                                <div class="font-black text-pink-600 uppercase text-sm">Lucky Queen Twist!</div>
                                <div class="text-gray-800 text-sm font-bold">${ep.luckyQueenFound} found the Lucky Statue in the cake!</div>
                                <div class="text-xs text-gray-600">She can use it to save herself from the bottom two once until the semi-finals.</div>
                            </div>
                        </div>
                    `;
                }
                if (ep.luckyQueenSave) {
                    twistMessage += `
                        <div class="mb-6 w-full max-w-2xl mx-auto bg-amber-100 border-2 border-amber-400 rounded-xl p-4 flex items-center gap-4 shadow-md animate-bounce-in">
                            <div class="h-12 w-12 flex-shrink-0 bg-white rounded-full flex items-center justify-center text-2xl">🗽</div>
                            <div class="text-left">
                                <div class="font-black text-amber-600 uppercase text-sm">Lucky Statue Used!</div>
                                <div class="text-gray-800 text-sm font-bold">${ep.luckyQueenSave.saved} saved herself from the bottom!</div>
                                <div class="text-xs text-gray-600">${ep.luckyQueenSave.replaced} takes her place in the lip sync.</div>
                            </div>
                        </div>
                    `;
                }

                const titleText = "Condragulations!";
                const top2NamesText = top2.map(w => w.name).join(', ');
                const highNamesText = (high || []).map(h => h.name).join(', ');
                const highTeamNamesText = (highTeam || []).map(h => h.name).join(', ');
                const lowNamesText = (low || []).map(l => l.name).join(', ');
                const bottomNames = hasBeaver
                    ? ep.beaverBottom3
                    : (bottom || []).map(b => b.name || b);
                const bottomForScreen = bottomNames.slice(0, 3);
                const bottomNamesText = bottomForScreen.join(', ');
                const renderCard = (qName, badge, badgeClass, borderClass, bgClass) => `
                    <div class="relative flex flex-col items-center w-[150px] rounded-2xl border ${borderClass} ${bgClass} px-4 py-4 shadow-sm">
                        <div class="absolute -top-2 rounded-full ${badgeClass} px-2.5 py-1 text-[10px] font-black uppercase">${badge}</div>
                        <div class="queen-img-results-wrap rounded-full overflow-hidden">
                            <img src="${queensDb[qName].photo}" class="queen-img-results rounded-full">
                        </div>
                        <div class="mt-3 text-[13px] font-bold text-gray-900 text-center leading-snug truncate w-full">${qName}</div>
                    </div>
                `;
                stage.innerHTML = `
                    <div class="w-full flex justify-center">
                        <div class="w-full max-w-3xl text-center">
                            ${twistMessage}
                            <div class="flex flex-col items-center">
                                <div class="flex flex-col items-center gap-0 text-gray-900">
                                <img src="images/crown.svg" class="w-6 h-6 object-contain">
                                <h3 class="sc-section font-bold">${titleText}</h3>
                            </div>
                                <div class="mt-2 h-[3px] w-12 rounded-full bg-amber-400"></div>
                            </div>

                            <div class="mt-6 text-[10px] font-black text-amber-500">CHALLENGE WINNER</div>
                            <div class="mt-6 flex flex-wrap items-start justify-center gap-4">
                                ${top2.map(w => renderCard(w.name, isDoublePremiere ? 'TOP 2' : 'WINNER', 'bg-amber-100 text-amber-800', 'border-amber-200', 'bg-amber-50')).join('')}
                            </div>
                            <p class="mt-2 text-[14px] text-gray-500">${top2NamesText}, you are the winner${isDoublePremiere ? 's' : ''} of this week.</p>

                            <div class="mt-6 flex items-center gap-4">
                                <div class="h-px flex-1 bg-gray-200"></div>
                                <div class="text-[9px] font-black text-gray-400">THE REST</div>
                                <div class="h-px flex-1 bg-gray-200"></div>
                            </div>

                            ${high.length ? `
                                <div class="mt-5">
                                    <div class="text-[10px] font-black text-sky-600">HIGH</div>
                                    <div class="mt-5 flex flex-wrap items-start justify-center gap-4">
                                        ${high.map(h => renderCard(h.name, 'HIGH', 'bg-sky-100 text-sky-700', 'border-sky-200', 'bg-sky-50')).join('')}
                                    </div>
                                    <p class="mt-2 text-[14px] text-gray-500">${highNamesText}, good job.</p>
                                </div>
                            ` : ''}

                            ${highTeam.length ? `
                                <div class="mt-5">
                                    <div class="text-[10px] font-black text-teal-600">HIGH TEAM</div>
                                    <div class="mt-5 flex flex-wrap items-start justify-center gap-4">
                                        ${highTeam.map(ht => renderCard(ht.name, 'HIGH TEAM', 'bg-teal-100 text-teal-700', 'border-teal-200', 'bg-teal-50')).join('')}
                                    </div>
                                    <p class="mt-2 text-[14px] text-gray-500">${highTeamNamesText}, good job as a team.</p>
                                </div>
                            ` : ''}

                            ${low.length ? `
                                <div class="mt-5">
                                    <div class="text-[10px] font-black text-orange-600">LOW</div>
                                    <div class="mt-5 flex flex-wrap items-start justify-center gap-4">
                                        ${low.map(l => renderCard(l.name, 'LOW', 'bg-orange-100 text-orange-700', 'border-orange-200', 'bg-orange-50')).join('')}
                                    </div>
                                    <p class="mt-2 text-[14px] text-gray-500">${lowNamesText}, you are safe... barely.</p>
                                </div>
                            ` : ''}

                            ${bottomForScreen.length ? `
                                <div class="mt-6">
                                    <div class="flex items-center gap-4 text-[10px] font-black text-red-500">
                                        <div class="h-px flex-1 bg-red-200"></div>
                                        <span>X</span>
                                        <span>${bottomForScreen.length === 2 ? 'BOTTOM TWO' : 'BOTTOM'}</span>
                                        <span>X</span>
                                        <div class="h-px flex-1 bg-red-200"></div>
                                    </div>
                                    <div class="mt-5 flex flex-wrap items-start justify-center gap-4">
                                        ${bottomForScreen.map(name => renderCard(name, 'BOTTOM', 'bg-red-100 text-red-700', 'border-red-200', 'bg-red-50')).join('')}
                                    </div>
                                    <p class="mt-2 text-[14px] text-red-500">${bottomNamesText}, you are up for elimination.</p>
                                </div>
                            ` : ''}
                        </div>
                    </div>
                `;
                debug.innerText = "Winner Announcement";
                btn.innerHTML = bottomForScreen.length ? "Lip Sync For Your Life" : "Untucked";
                btn.onclick = advanceScenario;
            } else if (scenarioPhase === 5) {
                const scenes = ep.untucked || [];
                stage.innerHTML = `
                    <div class="w-full">
                        <div class="mx-auto h-12 w-12 rounded-full bg-pink-100 flex items-center justify-center p-3 mb-2">
                            <img src="images/chat.svg" class="w-full h-full object-contain">
                        </div>
                        <h3 class="sc-section font-bold mb-2 w-full text-center">Untucked</h3>
                        <p class="text-[14px] text-gray-500 mb-4 text-center">Girl, if you're not watching Untucked, you're only getting half the story.</p>
                        <div class="space-y-3 max-h-[320px] overflow-y-auto text-left">
                            ${scenes.length ? scenes.map(s => `
                                <div class="p-3 rounded-lg border-l-4 flex items-center gap-3 ${s.type === 'blame' ? 'border-red-400 bg-red-50' : s.type === 'shade' ? 'border-orange-400 bg-orange-50' : s.type === 'support' ? 'border-green-400 bg-green-50' : s.type === 'delulu' ? 'border-yellow-400 bg-yellow-50' : s.type === 'honest' ? 'border-teal-400 bg-teal-50' : s.type === 'strategy' ? 'border-gray-500 bg-gray-100' : 'border-pink-400 bg-pink-50'}">
                                    <div class="flex items-center gap-2 flex-shrink-0">
                                        <img src="${queensDb[s.queen] ? queensDb[s.queen].photo : ''}" class="queen-img-sm border-2 border-white shadow" alt="">
                                        ${s.target ? `<img src="${queensDb[s.target] ? queensDb[s.target].photo : ''}" class="queen-img-sm border-2 border-white shadow" alt="">` : ''}
                                    </div>
                                    <p class="text-sm font-medium text-gray-800 flex-1 text-left">${s.text}</p>
                                </div>
                            `).join('') : '<p class="text-gray-400">Tension in the room. The top 2 keep their choices to themselves.</p>'}
                        </div>
                    </div>
                `;
                debug.innerText = "Untucked";
                btn.innerHTML = ep.isAllStars ? "Lip Sync for Your Legacy" : (ep.isDoublePremiere ? "Lip Sync For The Win" : "Lip Sync For Your Life");
            } else if (scenarioPhase === 6) {
                const top2 = ep.top2 || ((ep.isAllStars || ep.isDoublePremiere) ? ep.winners : ep.bottom) || [];
                const title = ep.isAllStars ? "Lip Sync For Your Legacy" : (ep.isDoublePremiere ? "Lip Sync For The Win" : "Lip Sync For Your Life");
                const lipSyncTop2 = Array.isArray(ep.lipSyncTop2) ? ep.lipSyncTop2 : [];
                // Display Legacy Lip Sync Results
                const revealLegacyResults = () => {
                    top2.forEach(q => {
                        const domKey = (`${ep.episode}_${q.name}`).replace(/[^a-z0-9]+/gi, '_');
                        const isWinner = ep.isDoubleWin || ep.isDoubleShantay || q.name === ep.lipSyncWinner;
                        const isLSFYL = !ep.isAllStars && !ep.isDoublePremiere && !ep.isTournament;

                        let badgeText = isWinner ? 'Winner' : 'Safe';
                        let badgeClass = isWinner ? 'bg-yellow-500 text-white' : 'bg-blue-100 text-blue-700';

                        if (isLSFYL) {
                            badgeText = isWinner ? 'SHANTAY' : 'SASHAY';
                            badgeClass = isWinner ? 'bg-green-500 text-white' : 'bg-red-500 text-white';
                        }

                        const card = document.getElementById(`legacyCard_${domKey}`);
                        const badge = document.getElementById(`legacyBadge_${domKey}`);
                        if (card) {
                            card.className = `flex flex-col items-center gap-2 rounded-2xl border p-5 w-44 sm:w-56 min-w-0 transition ${isWinner ? 'border-amber-300 bg-amber-50 shadow-lg shadow-amber-200/50' : 'border-gray-200 bg-gray-50'}`;
                        }
                        if (badge) {
                            badge.textContent = badgeText;
                            badge.className = `mt-2 rounded-full px-3 py-1 text-xs font-bold ${badgeClass}`;
                            badge.classList.remove('hidden');
                        }
                    });
                    const msg = document.getElementById('legacyMessage');
                    if (msg) {
                        if (ep.isDoubleWin) {
                            // Handle Double Win (Legacy)
                            const names = top2.map(q => q.name || q).join(', ');
                            msg.innerHTML = `${names}, condragulations.<br>You are both winners, baby!`;
                        } else {
                            // Standard Win (Legacy)
                            const winnerName = ep.lipSyncWinner || (top2[0] && top2[0].name) || '';
                            msg.textContent = winnerName ? `${winnerName}, you're winner, baby!` : "you're winner, baby!";
                        }
                        msg.classList.remove('hidden');
                    }
                    const hasLipstickReveal = !!(ep.isAllStars && ep.lipstickChoices && Object.keys(ep.lipstickChoices).length);
                    btn.innerHTML = ep.isTournament ? "Point Gifting" : (hasLipstickReveal ? "Reveal Lipstick" : "Show Track Record");
                    btn.onclick = advanceScenario;
                };
                stage.innerHTML = `
                    <div class="w-full text-center">
                        <div class="flex flex-col items-center gap-2">
                            <div class="mx-auto h-12 w-12 rounded-full bg-pink-100 flex items-center justify-center p-3">
                                <img src="images/sword.svg" class="w-full h-full object-contain">
                            </div>
                            <h2 class="text-2xl font-bold text-gray-900 font-heading">${title}</h2>
                            <div class="text-sm text-gray-500">"${ep.lipSyncSong || ''}"</div>
                        </div>
                        <div class="mt-8 flex items-center justify-center gap-6 sm:gap-10">
                            ${top2.map(q => {
                                const queenName = q && q.name ? q.name : q;
                                const domKey = (`${ep.episode}_${queenName}`).replace(/[^a-z0-9]+/gi, '_');
                                const lipSyncEntry = lipSyncTop2.find(l => l.name === queenName);
                                const rawScore = (lipSyncEntry && typeof lipSyncEntry.score === 'number')
                                    ? lipSyncEntry.score
                                    : (q && typeof q.score === 'number')
                                        ? q.score
                                        : (q && typeof q.total === 'number')
                                            ? q.total
                                            : null;
                                const scoreText = typeof rawScore === 'number' ? rawScore.toFixed(1) : '-';
                                return createQueenCardHtml({
                                    domKey,
                                    queenName,
                                    photoUrl: queensDb[queenName].photo,
                                    score: scoreText,
                                    cardId: `legacyCard_${domKey}`,
                                    badgeId: `legacyBadge_${domKey}`,
                                    baseClasses: "border-gray-200 bg-gray-50"
                                });
                            }).join('')}
                        </div>
                        <div id="legacyMessage" class="mt-6 text-sm text-gray-500 hidden"></div>
                    </div>
                `;
                debug.innerText = "Lip Sync";
                btn.innerHTML = "Results";
                btn.onclick = revealLegacyResults;
            } else if (scenarioPhase === 7) {
                if (ep.isTournament) {
                    const gifts = ep.pointGifts || [];
                    stage.innerHTML = `
                        <div class="w-full text-center">
                            <div class="flex flex-col items-center gap-2">
                                <div class="mx-auto h-12 w-12 rounded-full bg-amber-100 flex items-center justify-center p-3">
                                    <img src="images/gifting.svg" class="w-full h-full object-contain">
                                </div>
                                <h3 class="text-2xl font-bold text-gray-900 font-heading">Point Gifting</h3>
                                <p class="text-[14px] text-gray-500">Each queen awards a point to another competitor</p>
                            </div>
                            <div class="mt-6 w-full max-w-xl mx-auto flex flex-col gap-2">
                                ${gifts.length ? gifts.map(g => `
                                    <div class="flex items-center gap-2 sm:gap-3 rounded-xl border border-amber-200 bg-amber-50 px-3 py-3 sm:px-4">
                                        <div class="flex min-w-0 flex-1 items-center gap-2">
                                            <div class="h-9 w-9 min-h-9 min-w-9 flex-shrink-0 aspect-square rounded-full overflow-hidden border-2 border-amber-200">
                                                <img src="${queensDb[g.from]?.photo || ''}" class="h-full w-full object-cover" alt="">
                                            </div>
                                            <span class="text-sm font-semibold text-gray-900 truncate">${g.from}</span>
                                        </div>
                                        <div class="text-amber-500 text-sm w-4 sm:w-6 text-center flex-shrink-0">→</div>
                                        <div class="flex min-w-0 flex-1 items-center justify-end gap-2">
                                            <span class="text-sm font-semibold text-gray-900 truncate text-right">${g.to}</span>
                                            <div class="h-9 w-9 min-h-9 min-w-9 flex-shrink-0 aspect-square rounded-full overflow-hidden border-2 border-amber-200">
                                                <img src="${queensDb[g.to]?.photo || ''}" class="h-full w-full object-cover" alt="">
                                            </div>
                                        </div>
                                        <div class="flex items-center justify-end gap-1 w-[35px] sm:w-[120px] flex-shrink-0">
                                            <span class="rounded-full bg-amber-100 text-amber-700 text-[10px] font-bold px-2 py-1">+1</span>
                                            <div class="hidden sm:block w-[75px]">
                                                ${g.personality ? `<span class="flex items-center justify-center w-full text-[10px] font-semibold text-amber-700 bg-amber-100 px-2 py-1 rounded-full truncate">${g.personality}</span>` : ''}
                                            </div>
                                        </div>
                                    </div>
                                `).join('') : `
                                    <div class="rounded-xl border border-gray-200 bg-gray-50 px-4 py-6 text-sm text-gray-400">No gifts this round.</div>
                                `}
                            </div>
                        </div>
                    `;
                    debug.innerText = "Point Gifting";
                    btn.innerHTML = "Show Track Record";
                } else if (ep.isPremiere) {
                    const hasLipstickReveal = !!(ep.isAllStars && ep.lipstickChoices && Object.keys(ep.lipstickChoices).length);
                    if (!hasLipstickReveal) {
                        scenarioPhase = 8;
                        renderScenario();
                        return;
                    }
                }
                if (!ep.isTournament && (!ep.isPremiere || (ep.isAllStars && ep.lipstickChoices && Object.keys(ep.lipstickChoices).length))) {
                    const elimNames = Array.isArray(ep.eliminated) ? ep.eliminated : [ep.eliminated];
                    const primaryElim = elimNames[0];
                    const dramaBlock = ep.revealLoserLipstick && ep.loserLipstick
                        ? (ep.loserLipstick !== primaryElim
                            ? `<div class="mt-4 p-3 bg-gray-100 rounded-lg text-left text-sm text-gray-600">
                                <strong>Drama:</strong> The other top 2 had chosen <strong>${ep.loserLipstick}</strong>'s lipstick.
                               </div>`
                            : `<div class="mt-4 p-3 bg-gray-100 rounded-lg text-left text-sm text-gray-500">
                                The other top 2 had the same choice.
                               </div>`)
                        : '';
                    const formatElimReason = (name) => {
                        const v = ep.elimReasons && ep.elimReasons[name];
                        if (!v) return '';
                        if (Array.isArray(v)) {
                            return `<div class="mt-4 text-[14px] text-[#6B7280] font-medium leading-relaxed text-center px-2 max-w-2xl mx-auto">${v.map(line => `<div>${line}</div>`).join('')}</div>`;
                        }
                        return `<p class="mt-4 text-[14px] text-[#6B7280] font-medium leading-relaxed text-center px-2 max-w-2xl mx-auto">${v}</p>`;
                    };
                    const elimCards = elimNames.map(name => `
                            <div class="flex flex-col items-center w-82 sm:w-90">
                                <div class="flex flex-col items-center p-3 sm:p-4 rounded-xl bg-red-50 border-2 border-red-300 w-36 sm:w-52">
                                    <img src="${queensDb[name] ? queensDb[name].photo : ''}" class="queen-img-lg grayscale opacity-90" alt="">
                                    <span class="font-bold mt-1 sm:mt-2 text-center leading-snug px-1 truncate w-28 sm:w-32 text-red-800">${name}</span>
                                    <span class="text-xs font-bold text-red-700 mt-1 sm:mt-2">SASHAY AWAY</span>
                                </div>
                                ${formatElimReason(name)}
                            </div>
                    `).join('');
                    stage.innerHTML = `
                        <div class="w-full text-center">
                            <div class="flex flex-col items-center gap-2 mb-4">
                                <div class="mx-auto h-12 w-12 rounded-full bg-red-100 flex items-center justify-center p-3">
                                    <img src="images/chop.svg" class="w-full h-full object-contain">
                                </div>
                                <h2 class="text-[20px] sm:text-2xl font-black text-gray-800">The winner opens their lipstick...</h2>
                            </div>
                            <div class="flex justify-center gap-3 sm:gap-4 flex-wrap mt-4">
${elimCards}
                            </div>
                            ${dramaBlock}
                        </div>
                    `;
                    debug.innerText = "Elimination";
                    btn.innerHTML = "Show Track Record";
                }
            } else if (scenarioPhase === 8) {
                renderTrackRecordTable(ep.episode);
                stage.innerHTML = `<div class="text-center"><h2 class="text-xl font-bold mb-4">Episode ${ep.episode} Complete</h2><p class="text-gray-500 text-sm">Review the track record below.</p></div>`;
                if (trackDiv) {
                    trackDiv.classList.remove('hidden');
                    stage.appendChild(trackDiv);
                }
                debug.innerText = "Summary";
                btn.innerHTML = "Next Episode →";
            }
            return;
        }

        if (seasonData.isAllStars && ep.isFinale && !(ep.finalLipSyncQueens && ep.finalLipSyncQueens.length >= 2)) {
            if (scenarioPhase === 0) {
                trackDiv.classList.remove('hidden');
                renderTrackRecordTable(99);
                const winner = seasonData.winner;
                const wStats = seasonData.queenStats[winner];
                const finalists = ep.finalists || [];
                stage.innerHTML = `
                    <div class="flex flex-col items-center">
                        <h1 class="text-sm font-bold text-gray-400 uppercase mb-4">All Stars — Winner</h1>
                        <div class="relative">
                            <div class="absolute -inset-2 bg-gradient-to-r from-yellow-300 via-orange-400 to-yellow-300 rounded-full blur-lg opacity-75 animate-pulse"></div>
                            <img src="${queensDb[winner].photo}" class="relative w-48 h-48 rounded-full border-4 border-white shadow-2xl object-cover">
                        </div>
                        <h2 class="text-5xl font-black text-gray-800 mt-6 mb-2">${winner}</h2>
                        <div class="flex gap-2 text-xs font-bold mt-2">
                            <span class="px-3 py-1 bg-blue-100 text-blue-700 rounded-full">🏆 ${wStats.wins} WINS</span>
                            <span class="px-3 py-1 bg-purple-100 text-purple-700 rounded-full">📊 ${wStats.ppe.toFixed(2)} PPE</span>
                        </div>
                        ${finalists.length > 0 ? `<div class="mt-6 pt-4 border-t border-gray-200"><p class="text-xs text-gray-400">Runner-ups: ${finalists.filter(q => q !== winner).join(', ')}</p></div>` : ''}
                        <button onclick="location.reload()" class="mt-8 text-xs underline text-gray-400">Restart</button>
                    </div>
                `;
                debug.innerText = "All Stars Finale";
                btn.classList.add('hidden');
            }
            return;
        }

        if (ep.isFinale) {
            if (ep.isCrownFinale) {
                if (scenarioPhase === 0) {
                    trackDiv.classList.add('hidden');
                    stage.innerHTML = `
                        <div class="mx-auto h-14 w-14 rounded-full bg-yellow-100 flex items-center justify-center p-3">
                            <img src="images/finale-crown.svg" class="w-full h-full object-contain">
                        </div>
                        <div class="mt-6 sc-kicker text-gray-400 uppercase">GRAND FINALE</div>
                        <div class="mt-2 sc-title font-bold text-transparent bg-clip-text bg-gradient-to-r from-yellow-500 to-orange-500">Lip Sync For The Crown</div>
                        <div class="mt-3 text-sm text-gray-500">4 queens compete in back-to-back lip syncs. The last queen standing becomes Next Drag Superstar.</div>
                    `;
                    debug.innerText = "Crown Finale Announcement";
                    btn.innerHTML = "Vote Miss Congeniality";
                }
                else if (scenarioPhase === 1) {
                    renderMissCongenialityVoting();
                    return;
                }
                else if (scenarioPhase === 2) {
                    const matches = ep.crownRound1 || [];
                    const revealRound1Results = () => {
                        matches.forEach((m, matchIndex) => {
                            const updateCard = (name, isWinner) => {
                                const domKey = (`c1_${matchIndex}_${name}`).replace(/[^a-z0-9]+/gi, '_');
                                const img = document.getElementById(`crownImg_${domKey}`);
                                const card = document.getElementById(`crownCard_${domKey}`);
                                const badge = document.getElementById(`crownBadge_${domKey}`);
                                if (card) {
                                    const cardResultClass = isWinner
                                        ? 'border-pink-400 bg-pink-50 shadow-lg shadow-pink-200/60'
                                        : 'border-gray-200 bg-gray-50 opacity-60';
                                    card.className = `flex flex-col items-center gap-2 rounded-2xl border p-5 w-44 sm:w-56 min-w-0 transition ${cardResultClass}`;
                                }
                                if (badge) {
                                    const badgeClass = isWinner ? 'bg-pink-600 text-white' : 'bg-gray-200 text-gray-500';
                                    badge.textContent = isWinner ? 'Shantay' : 'Sashay';
                                    badge.className = `mt-2 rounded-full px-3 py-1 text-xs font-bold ${badgeClass}`;
                                    badge.classList.remove('hidden');
                                }
                                if (img) {
                                    img.className = `queen-img-lg${isWinner ? '' : ' grayscale opacity-70'}`;
                                }
                            };
                            updateCard(m.a, m.winner === m.a);
                            updateCard(m.b, m.winner === m.b);
                        });
                        btn.innerHTML = "Round 2";
                        btn.onclick = advanceScenario;
                    };
                    const match = matches[0] || null;
                    const song = match && match.song ? match.song : '';
                    stage.innerHTML = `
                        <div class="w-full text-center">
                            <div class="flex flex-col items-center gap-2">
                                <div class="mx-auto h-12 w-12 rounded-full bg-pink-100 flex items-center justify-center p-3">
                                    <img src="images/sword.svg" class="w-full h-full object-contain">
                                </div>
                                <h2 class="text-2xl font-bold text-gray-900 font-heading">Lip Sync For The Crown</h2>
                                ${song ? `<div class="text-sm text-gray-500">"${song}"</div>` : '<div class="text-sm text-gray-500"></div>'}
                            </div>
                            <div class="mt-8 flex items-center justify-center gap-6 sm:gap-10">
                                ${matches.map((m, matchIndex) => {
                                    const scoreA = (m && m.scoreA !== undefined && m.scoreA !== null) ? Number(m.scoreA).toFixed(1) : '-';
                                    const scoreB = (m && m.scoreB !== undefined && m.scoreB !== null) ? Number(m.scoreB).toFixed(1) : '-';
                                    const domKeyA = (`c1_${matchIndex}_${m.a}`).replace(/[^a-z0-9]+/gi, '_');
                                    const domKeyB = (`c1_${matchIndex}_${m.b}`).replace(/[^a-z0-9]+/gi, '_');
                                    const cardA = createQueenCardHtml({
                                        domKey: domKeyA,
                                        queenName: m.a,
                                        photoUrl: queensDb[m.a].photo,
                                        score: scoreA,
                                        cardId: `crownCard_${domKeyA}`,
                                        imgId: `crownImg_${domKeyA}`,
                                        badgeId: `crownBadge_${domKeyA}`,
                                        baseClasses: "border-red-200 bg-red-50/40"
                                    });
                                    const cardB = createQueenCardHtml({
                                        domKey: domKeyB,
                                        queenName: m.b,
                                        photoUrl: queensDb[m.b].photo,
                                        score: scoreB,
                                        cardId: `crownCard_${domKeyB}`,
                                        imgId: `crownImg_${domKeyB}`,
                                        badgeId: `crownBadge_${domKeyB}`,
                                        baseClasses: "border-red-200 bg-red-50/40"
                                    });
                                    return cardA + cardB;
                                }).join('')}
                            </div>
                        </div>
                    `;
                    debug.innerText = "Crown Finale — Round 1";
                    btn.innerHTML = "Results";
                    btn.onclick = revealRound1Results;
                }
                else if (scenarioPhase === 3) {
                    const matches = ep.crownRound2 || [];
                    const revealRound2Results = () => {
                        matches.forEach((m, matchIndex) => {
                            const updateCard = (name, isWinner) => {
                                const domKey = (`c2_${matchIndex}_${name}`).replace(/[^a-z0-9]+/gi, '_');
                                const img = document.getElementById(`crownImg_${domKey}`);
                                const card = document.getElementById(`crownCard_${domKey}`);
                                const badge = document.getElementById(`crownBadge_${domKey}`);
                                if (card) {
                                    const cardResultClass = isWinner
                                        ? 'border-pink-400 bg-pink-50 shadow-lg shadow-pink-200/60'
                                        : 'border-gray-200 bg-gray-50 opacity-60';
                                    card.className = `flex flex-col items-center gap-2 rounded-2xl border p-5 w-44 sm:w-56 min-w-0 transition ${cardResultClass}`;
                                }
                                if (badge) {
                                    const badgeClass = isWinner ? 'bg-pink-600 text-white' : 'bg-gray-200 text-gray-500';
                                    badge.textContent = isWinner ? 'Shantay' : 'Sashay';
                                    badge.className = `mt-2 rounded-full px-3 py-1 text-xs font-bold ${badgeClass}`;
                                    badge.classList.remove('hidden');
                                }
                                if (img) {
                                    img.className = `queen-img-lg${isWinner ? '' : ' grayscale opacity-70'}`;
                                }
                            };
                            updateCard(m.a, m.winner === m.a);
                            updateCard(m.b, m.winner === m.b);
                        });
                        btn.innerHTML = "Final Lip Sync";
                        btn.onclick = advanceScenario;
                    };
                    const match2 = matches[0] || null;
                    const song2 = match2 && match2.song ? match2.song : '';
                    stage.innerHTML = `
                        <div class="w-full text-center">
                            <div class="flex flex-col items-center gap-2">
                                <div class="mx-auto h-12 w-12 rounded-full bg-pink-100 flex items-center justify-center p-3">
                                    <img src="images/sword.svg" class="w-full h-full object-contain">
                                </div>
                                <h2 class="text-2xl font-bold text-gray-900 font-heading">Lip Sync For The Crown</h2>
                                ${song2 ? `<div class="text-sm text-gray-500">"${song2}"</div>` : '<div class="text-sm text-gray-500"></div>'}
                            </div>
                            <div class="mt-8 flex items-center justify-center gap-6 sm:gap-10">
                                ${matches.map((m, matchIndex) => {
                                    const scoreA = (m && m.scoreA !== undefined && m.scoreA !== null) ? Number(m.scoreA).toFixed(1) : '-';
                                    const scoreB = (m && m.scoreB !== undefined && m.scoreB !== null) ? Number(m.scoreB).toFixed(1) : '-';
                                    const domKeyA = (`c2_${matchIndex}_${m.a}`).replace(/[^a-z0-9]+/gi, '_');
                                    const domKeyB = (`c2_${matchIndex}_${m.b}`).replace(/[^a-z0-9]+/gi, '_');
                                    const cardA = createQueenCardHtml({
                                        domKey: domKeyA,
                                        queenName: m.a,
                                        photoUrl: queensDb[m.a].photo,
                                        score: scoreA,
                                        cardId: `crownCard_${domKeyA}`,
                                        imgId: `crownImg_${domKeyA}`,
                                        badgeId: `crownBadge_${domKeyA}`,
                                        baseClasses: "border-red-200 bg-red-50/40"
                                    });
                                    const cardB = createQueenCardHtml({
                                        domKey: domKeyB,
                                        queenName: m.b,
                                        photoUrl: queensDb[m.b].photo,
                                        score: scoreB,
                                        cardId: `crownCard_${domKeyB}`,
                                        imgId: `crownImg_${domKeyB}`,
                                        badgeId: `crownBadge_${domKeyB}`,
                                        baseClasses: "border-red-200 bg-red-50/40"
                                    });
                                    return cardA + cardB;
                                }).join('')}
                            </div>
                        </div>
                    `;
                    debug.innerText = "Crown Finale — Round 2";
                    btn.innerHTML = "Results";
                    btn.onclick = revealRound2Results;
                }
                else if (scenarioPhase === 4) {
                    const lipSyncScores = ep.finalLipSyncScores || [];
                    stage.innerHTML = `
                        <div class="w-full text-center">
                            <div class="flex flex-col items-center gap-2">
                                <div class="mx-auto h-12 w-12 rounded-full bg-yellow-100 flex items-center justify-center p-3 mb-2">
                                    <img src="images/finale-crown.svg" class="w-full h-full object-contain">
                                </div>
                                <h2 class="text-2xl font-bold text-gray-900 font-heading">Lip Sync For The Crown</h2>
                                <div class="text-sm text-gray-500">"${ep.lipSyncSong || ''}"</div>
                            </div>
                            <div class="mt-8 flex flex-wrap items-center justify-center gap-4 sm:gap-10">
                                ${lipSyncScores.map(ls => `
                                    <div class="flex flex-col items-center gap-2 rounded-2xl border border-amber-200 bg-amber-50 p-5 w-40 sm:w-56 transition">
                                        <img src="${queensDb[ls.name]?.photo || ''}" class="queen-img-lg" alt="">
                                        <span class="w-full text-center text-sm font-bold text-gray-900 leading-tight px-1 min-h-[2.5rem] max-h-[2.5rem] overflow-hidden">${ls.name}</span>
                                        <span class="text-xs text-gray-500 text-center">${ls.breakdown}</span>
                                        <span class="text-xl font-bold text-gray-900">${ls.score.toFixed(1)}</span>
                                    </div>
                                `).join('')}
                            </div>
                            <p class="mt-6 text-sm text-gray-500">The winner will be announced based on track record</p>
                        </div>
                    `;
                    debug.innerText = "Crown Finale — Final Lip Sync";
                    btn.innerHTML = "Crown The Winner";
                }
                else if (scenarioPhase === 5) {
                    renderFinale();
                    return;
                }
                return;
            }
            if (ep.isTournamentFinale) {
                if (scenarioPhase === 0) {
                    trackDiv.classList.add('hidden');
                    stage.innerHTML = `
                        <div class="mx-auto h-14 w-14 rounded-full bg-yellow-100 flex items-center justify-center p-3">
                            <img src="images/finale-crown.svg" class="w-full h-full object-contain">
                        </div>
                        <div class="mt-6 sc-kicker text-gray-400 uppercase">GRAND FINALE</div>
                        <div class="mt-2 sc-title font-bold text-transparent bg-clip-text bg-gradient-to-r from-yellow-500 to-orange-500">Lip Sync LaLaPaRuZa Smackdown</div>
                        <div class="mt-3 text-sm text-gray-500">The final 8 queens take the stage one last time, lip syncing for the crown and a place in the Drag Race Hall of Fame.</div>
                    `;
                    debug.innerText = "Tournament Finale Announcement";
                    btn.innerHTML = "Start Lip Sync LaLaPaRuZa";
                    btn.onclick = function() {
                        scenarioPhase = 2;
                        renderScenario();
                    };
                }
                else if (scenarioPhase === 2) {
                    const matches = ep.lalaparuzaRound1 || [];
                    const revealRound1Results = () => {
                        matches.forEach((m, matchIndex) => {
                            const updateCard = (name, isWinner) => {
                                const domKey = (`r1_${matchIndex}_${name}`).replace(/[^a-z0-9]+/gi, '_');
                                const img = document.getElementById(`lalImg_${domKey}`);
                                const card = document.getElementById(`lalCard_${domKey}`);
                                const badge = document.getElementById(`lalBadge_${domKey}`);
                                if (card) {
                                    const cardResultClass = isWinner
                                        ? 'border-pink-400 bg-pink-50 shadow-lg shadow-pink-200/60'
                                        : 'border-gray-200 bg-gray-50 opacity-60';
                                    card.className = `flex flex-col items-center gap-2 rounded-2xl border p-5 w-full min-w-0 transition ${cardResultClass}`;
                                }
                                if (badge) {
                                    const badgeClass = isWinner ? 'bg-pink-600 text-white' : 'bg-gray-200 text-gray-500';
                                    badge.textContent = isWinner ? 'Shantay' : 'Sashay';
                                    badge.className = `mt-2 rounded-full px-3 py-1 text-xs font-bold max-w-full text-center leading-tight whitespace-normal inline-flex items-center justify-center min-h-[22px] ${badgeClass}`;
                                    badge.classList.remove('hidden');
                                }
                                if (img) {
                                    img.className = `queen-img-lg${isWinner ? '' : ' grayscale opacity-70'}`;
                                }
                            };
                            updateCard(m.a, m.winner === m.a);
                            updateCard(m.b, m.winner === m.b);
                        });
                        btn.innerHTML = "Round 2";
                        btn.onclick = advanceScenario;
                    };
                    stage.innerHTML = `
                        <div class="w-full text-center">
                            <div class="mx-auto h-12 w-12 rounded-full bg-pink-100 flex items-center justify-center p-3 mb-2">
                                <img src="images/sword.svg" class="w-full h-full object-contain">
                            </div>
                            <h2 class="text-2xl font-black text-gray-800 mb-4">Lip Sync For The Crown</h2>
                            <p class="text-sm text-gray-500 mb-6">Round 1</p>
                            <div class="w-full grid grid-cols-1 md:grid-cols-2 gap-6 px-3 max-w-5xl mx-auto">
                                ${matches.map((m, matchIndex) => {
                                    const scoreA = (m && m.scoreA !== undefined && m.scoreA !== null) ? Number(m.scoreA).toFixed(1) : '-';
                                    const scoreB = (m && m.scoreB !== undefined && m.scoreB !== null) ? Number(m.scoreB).toFixed(1) : '-';
                                    const domKeyA = (`r1_${matchIndex}_${m.a}`).replace(/[^a-z0-9]+/gi, '_');
                                    const domKeyB = (`r1_${matchIndex}_${m.b}`).replace(/[^a-z0-9]+/gi, '_');
                                    const song = (m && m.song) ? m.song : '';
                                    return `
                                        <div class="w-full h-full rounded-2xl border border-gray-300 bg-white p-4 sm:p-5 shadow-sm">
                                            ${song ? `<div class="text-[14px] text-gray-500 text-center mt-1">"${song}"</div>` : ''}
                                            <div class="grid grid-cols-2 gap-4 sm:gap-6 mt-4">
                                                ${createQueenCardHtml({
                                                    domKey: domKeyA,
                                                    queenName: m.a,
                                                    photoUrl: queensDb[m.a].photo,
                                                    score: scoreA,
                                                    cardId: `lalCard_${domKeyA}`,
                                                    imgId: `lalImg_${domKeyA}`,
                                                    scoreId: `lalVal_${domKeyA}`,
                                                    badgeId: `lalBadge_${domKeyA}`,
                                                    scoreData: scoreA,
                                                    baseClasses: "border-red-200 bg-red-50/40",
                                                    widthClass: "w-full min-w-0"
                                                })}
                                                ${createQueenCardHtml({
                                                    domKey: domKeyB,
                                                    queenName: m.b,
                                                    photoUrl: queensDb[m.b].photo,
                                                    score: scoreB,
                                                    cardId: `lalCard_${domKeyB}`,
                                                    imgId: `lalImg_${domKeyB}`,
                                                    scoreId: `lalVal_${domKeyB}`,
                                                    badgeId: `lalBadge_${domKeyB}`,
                                                    scoreData: scoreB,
                                                    baseClasses: "border-red-200 bg-red-50/40",
                                                    widthClass: "w-full min-w-0"
                                                })}
                                            </div>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                    `;
                    debug.innerText = "Tournament Finale — Round 1";
                    btn.innerHTML = "Results";
                    btn.onclick = revealRound1Results;
                }
                else if (scenarioPhase === 3) {
                    const matches = ep.lalaparuzaRound2 || [];
                    const revealRound2Results = () => {
                        matches.forEach((m, matchIndex) => {
                            const updateCard = (name, isWinner) => {
                                const domKey = (`r2_${matchIndex}_${name}`).replace(/[^a-z0-9]+/gi, '_');
                                const img = document.getElementById(`lalImg_${domKey}`);
                                const card = document.getElementById(`lalCard_${domKey}`);
                                const badge = document.getElementById(`lalBadge_${domKey}`);
                                if (card) {
                                    const cardResultClass = isWinner
                                        ? 'border-pink-400 bg-pink-50 shadow-lg shadow-pink-200/60'
                                        : 'border-gray-200 bg-gray-50 opacity-60';
                                    card.className = `flex flex-col items-center gap-2 rounded-2xl border p-5 w-full min-w-0 transition ${cardResultClass}`;
                                }
                                if (badge) {
                                    const badgeClass = isWinner ? 'bg-pink-600 text-white' : 'bg-gray-200 text-gray-500';
                                    badge.textContent = isWinner ? 'Shantay' : 'Sashay';
                                    badge.className = `mt-2 rounded-full px-3 py-1 text-xs font-bold max-w-full text-center leading-tight whitespace-normal inline-flex items-center justify-center min-h-[22px] ${badgeClass}`;
                                    badge.classList.remove('hidden');
                                }
                                if (img) {
                                    img.className = `queen-img-lg${isWinner ? '' : ' grayscale opacity-70'}`;
                                }
                            };
                            updateCard(m.a, m.winner === m.a);
                            updateCard(m.b, m.winner === m.b);
                        });
                        btn.innerHTML = "Final Lip Sync";
                        btn.onclick = advanceScenario;
                    };
                    stage.innerHTML = `
                        <div class="w-full text-center">
                            <div class="mx-auto h-12 w-12 rounded-full bg-pink-100 flex items-center justify-center p-3 mb-2">
                                <img src="images/sword.svg" class="w-full h-full object-contain">
                            </div>
                            <h2 class="text-2xl font-black text-gray-800 mb-4">Lip Sync For The Crown</h2>
                            <p class="text-sm text-gray-500 mb-6">Round 2</p>
                            <div class="w-full grid grid-cols-1 md:grid-cols-2 gap-6 px-3 max-w-5xl mx-auto">
                                ${matches.map((m, matchIndex) => {
                                    const scoreA = (m && m.scoreA !== undefined && m.scoreA !== null) ? Number(m.scoreA).toFixed(1) : '-';
                                    const scoreB = (m && m.scoreB !== undefined && m.scoreB !== null) ? Number(m.scoreB).toFixed(1) : '-';
                                    const domKeyA = (`r2_${matchIndex}_${m.a}`).replace(/[^a-z0-9]+/gi, '_');
                                    const domKeyB = (`r2_${matchIndex}_${m.b}`).replace(/[^a-z0-9]+/gi, '_');
                                    const song = (m && m.song) ? m.song : '';
                                    return `
                                        <div class="w-full h-full rounded-2xl border border-gray-300 bg-white p-4 sm:p-5 shadow-sm">
                                            ${song ? `<div class="text-[14px] text-gray-500 text-center mt-1">"${song}"</div>` : ''}
                                            <div class="grid grid-cols-2 gap-4 sm:gap-6 mt-4">
                                                ${createQueenCardHtml({
                                                    domKey: domKeyA,
                                                    queenName: m.a,
                                                    photoUrl: queensDb[m.a].photo,
                                                    score: scoreA,
                                                    cardId: `lalCard_${domKeyA}`,
                                                    imgId: `lalImg_${domKeyA}`,
                                                    scoreId: `lalVal_${domKeyA}`,
                                                    badgeId: `lalBadge_${domKeyA}`,
                                                    scoreData: scoreA,
                                                    baseClasses: "border-red-200 bg-red-50/40",
                                                    widthClass: "w-full min-w-0"
                                                })}
                                                ${createQueenCardHtml({
                                                    domKey: domKeyB,
                                                    queenName: m.b,
                                                    photoUrl: queensDb[m.b].photo,
                                                    score: scoreB,
                                                    cardId: `lalCard_${domKeyB}`,
                                                    imgId: `lalImg_${domKeyB}`,
                                                    scoreId: `lalVal_${domKeyB}`,
                                                    badgeId: `lalBadge_${domKeyB}`,
                                                    scoreData: scoreB,
                                                    baseClasses: "border-red-200 bg-red-50/40",
                                                    widthClass: "w-full min-w-0"
                                                })}
                                            </div>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                    `;
                    debug.innerText = "Tournament Finale — Round 2";
                    btn.innerHTML = "Results";
                    btn.onclick = revealRound2Results;
                }
                else if (scenarioPhase === 4) {
                    const lipSyncScores = ep.finalLipSyncScores || [];
                    stage.innerHTML = `
                        <div class="w-full text-center">
                            <div class="flex flex-col items-center gap-2">
                                <div class="mx-auto h-12 w-12 rounded-full bg-yellow-100 flex items-center justify-center p-3 mb-2">
                                    <img src="images/finale-crown.svg" class="w-full h-full object-contain">
                                </div>
                                <h2 class="text-2xl font-bold text-gray-900 font-heading">Lip Sync For The Crown</h2>
                                <div class="text-sm text-gray-500">"${ep.lipSyncSong || ''}"</div>
                            </div>
                            <div class="mt-8 flex flex-wrap items-center justify-center gap-4 sm:gap-10">
                                ${lipSyncScores.map(ls => `
                                    <div class="flex flex-col items-center gap-2 rounded-2xl border border-amber-200 bg-amber-50 p-5 w-40 sm:w-56 transition">
                                        <img src="${queensDb[ls.name]?.photo || ''}" class="queen-img-lg" alt="">
                                        <span class="w-full text-center text-sm font-bold text-gray-900 leading-tight px-1 min-h-[2.5rem] max-h-[2.5rem] overflow-hidden">${ls.name}</span>
                                        <span class="text-xs text-gray-500 text-center">${ls.breakdown}</span>
                                        <span class="text-xl font-bold text-gray-900">${ls.score.toFixed(1)}</span>
                                    </div>
                                `).join('')}
                            </div>
                            <p class="mt-6 text-sm text-gray-500">The winner will be announced based on track record</p>
                        </div>
                    `;
                    debug.innerText = "Tournament Finale — Final Lip Sync";
                    btn.innerHTML = "Crown The Winner";
                }
                else if (scenarioPhase === 5) {
                    renderFinale();
                    return;
                }
                return;
            }
            if (scenarioPhase === 0) {
                trackDiv.classList.add('hidden');
                stage.innerHTML = `
                    <div class="mx-auto h-14 w-14 rounded-full bg-yellow-100 flex items-center justify-center p-3">
                        <img src="images/crown.svg" class="w-full h-full object-contain">
                    </div>
                    <div class="mt-6 sc-kicker text-gray-400 uppercase">GRAND FINALE</div>
                    <div class="mt-2 sc-title font-bold text-transparent bg-clip-text bg-gradient-to-r from-yellow-500 to-orange-500">Final Performance</div>
                    <div class="mt-3 text-sm text-gray-500">The final queens perform original songs before one last lip sync for the crown.</div>
                `;
                debug.innerText = "Finale Performance Announcement";
                btn.innerHTML = "Vote Miss Congeniality";
            }
            else if (scenarioPhase === 1) {
                renderMissCongenialityVoting();
                return;
            }
            else if (scenarioPhase === 2) {
                const perfScores = [...(ep.finalePerformanceScores || ep.scores || [])].sort((a, b) => (b.total || 0) - (a.total || 0));
                stage.innerHTML = `<h3 class="sc-section font-bold mb-4 w-full text-left px-4">Final Performances</h3>
                <div class="w-full grid grid-cols-1 md:grid-cols-2 gap-2 max-h-[300px] overflow-y-auto px-2">
                    ${perfScores.map(s => {
                        const passed = s.passed !== undefined ? s.passed : s.total >= 8;
                        const statusClass = passed ? "perf-good" : "perf-flop";
                        const desc = passed ? "Great performance!" : "Failed (< 8 points)";
                        return `
                        <div class="scenario-card ${statusClass} p-3 rounded-lg flex items-center gap-3">
                            <img src="${queensDb[s.name].photo}" class="queen-img-sm">
                            <div class="text-left flex-1">
                                <div class="font-bold text-sm">${s.name}</div>
                                <div class="text-xs text-gray-600">${desc}</div>
                            </div>
                            <div class="text-[9px] text-gray-400 font-mono text-right">${s.total.toFixed(1)}</div>
                        </div>
                    `;
                    }).join('')}
                </div>`;
                debug.innerText = "Final Performance Review";
                btn.innerHTML = "Reveal Finalists";
            }
            else if (scenarioPhase === 3) {
                const finalists = ep.finalLipSyncQueens || ep.finalists || [];
                const eliminated = ep.eliminatedInFinale || [];
                
                stage.innerHTML = `
                    <div class="w-full space-y-6">
                        <div class="p-4 bg-green-50 rounded-xl border border-green-200">
                            <h4 class="font-bold text-green-700 mb-3 text-lg">✨ FINAL LIP SYNC QUEENS ✨</h4>
                            <div class="flex justify-center gap-4 flex-wrap">
                                ${finalists.map(name => `
                                    <div class="flex flex-col items-center">
                                        <img src="${queensDb[name].photo}" class="queen-img-lg border-green-400 shadow-lg">
                                        <span class="text-sm font-bold text-green-900 mt-2">${name}</span>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        ${eliminated.length > 0 ? `
                        <div class="p-4 bg-orange-50 rounded-xl border border-orange-200">
                            <h4 class="font-bold text-orange-700 mb-2">Eliminated in Finale</h4>
                            <div class="flex justify-center gap-4 flex-wrap">
                                ${eliminated.map(name => `
                                    <div class="flex flex-col items-center opacity-60">
                                        <img src="${queensDb[name].photo}" class="queen-img-sm grayscale">
                                        <span class="text-xs font-bold text-orange-900 mt-1">${name}</span>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        ` : ''}
                    </div>
                `;
                debug.innerText = "Finalists Revealed";
                btn.innerHTML = "Final Lip Sync";
            }
            else if (scenarioPhase === 4) {
                const lipSyncScores = ep.finalLipSyncScores || [];
                stage.innerHTML = `
                    <div class="w-full text-center">
                        <div class="flex flex-col items-center gap-2">
                                <div class="mx-auto h-12 w-12 rounded-full bg-yellow-100 flex items-center justify-center p-3 mb-2">
                                    <img src="images/finale-crown.svg" class="w-full h-full object-contain">
                                </div>
                                <h2 class="text-2xl font-bold text-gray-900 font-heading">Lip Sync For The Crown</h2>
                                <div class="text-sm text-gray-500">"${ep.lipSyncSong || ''}"</div>
                            </div>
                        <div class="mt-8 flex flex-wrap items-center justify-center gap-4 sm:gap-10">
                            ${lipSyncScores.map(ls => `
                                <div class="flex flex-col items-center gap-2 rounded-2xl border border-amber-200 bg-amber-50 p-5 w-40 sm:w-56 transition">
                                    <img src="${queensDb[ls.name]?.photo || ''}" class="queen-img-lg" alt="">
                                    <span class="w-full text-center text-sm font-bold text-gray-900 leading-tight px-1 min-h-[2.5rem] max-h-[2.5rem] overflow-hidden">${ls.name}</span>
                                    <span class="text-xs text-gray-500 text-center">${ls.breakdown}</span>
                                    <span class="text-xl font-bold text-gray-900">${ls.score.toFixed(1)}</span>
                                </div>
                            `).join('')}
                        </div>
                        <p class="mt-6 text-sm text-gray-500">The winner will be announced based on track record</p>
                    </div>
                `;
                debug.innerText = "Final Lip Sync";
                btn.innerHTML = "Crown The Winner";
            }
            else if (scenarioPhase === 5) {
                renderFinale();
                return;
            }
            return;
        }

        const needsSemiReturnPick = !!(seasonData.isTournament && ep.isTournament && ep.tournamentStage === 'Semi-Finals' && ep.needsReturnPick);
        if (needsSemiReturnPick && scenarioPhase === 1) {
            const pool = (seasonData.tournamentState && Array.isArray(seasonData.tournamentState.eliminatedPool))
                ? seasonData.tournamentState.eliminatedPool
                : [];
            
            const prevEpIndex = currentEpIndex - 1;
            const maxEp = prevEpIndex >= 0 && seasonData.episodes[prevEpIndex] ? seasonData.episodes[prevEpIndex].episode : 0;
            const currentStatsArray = calculateQueenStats(seasonData, maxEp);
            const stats = {};
            currentStatsArray.forEach(s => { stats[s.name] = s; });

            const defaultPick = pool.length > 0
                ? [...pool].sort((a, b) => {
                    const ppeA = stats[a]?.ppe ?? -Infinity;
                    const ppeB = stats[b]?.ppe ?? -Infinity;
                    const tpA = stats[a]?.totalPoints ?? 0;
                    const tpB = stats[b]?.totalPoints ?? 0;
                    return (ppeB - ppeA) || (tpB - tpA) || String(a).localeCompare(String(b));
                })[0]
                : '';
            btn.classList.add('hidden');
            stage.innerHTML = `
                <div class="w-full text-center">
                    <h3 class="text-xl font-bold mb-2">Bring Back a Queen</h3>
                    <p class="text-sm text-gray-500 mb-5">Choose one eliminated queen to return.</p>
                    <div class="w-full max-w-md mx-auto px-3">
                        <div class="scenario-card perf-safe p-4 rounded-xl flex flex-col items-center gap-3 border border-gray-200 bg-white shadow-sm text-center">
                            <img
                                id="returnPickImg"
                                src="${defaultPick && queensDb[defaultPick] ? queensDb[defaultPick].photo : ''}"
                                class="queen-img-lg ${defaultPick ? '' : 'hidden'}"
                                alt=""
                            >
                            <div id="returnPickName" class="font-black text-lg text-gray-800 truncate w-full">${defaultPick || 'Select a queen…'}</div>
                            <span
                                id="returnPickPpe"
                                class="${defaultPick ? '' : 'hidden'} px-3 py-1 bg-pink-100 text-pink-700 rounded-full text-xs font-bold whitespace-nowrap"
                            >${defaultPick ? `${(stats[defaultPick]?.ppe ?? 0).toFixed(2)} PPE` : ''}</span>
                        </div>

                        <div class="mt-4 flex flex-col items-center gap-4">
                            <select
                                id="returnPickSelect"
                                class="w-full max-w-xs p-2 rounded-lg bg-white border border-gray-300 text-sm"
                                onchange="onReturnPickChange()"
                            >
                                ${pool.length === 0 ? `<option value="" selected>(No eliminated queens)</option>` : ''}
                                ${pool.map(name => {
                                    const safeVal = String(name).replace(/"/g, '&quot;');
                                    const selected = name === defaultPick ? 'selected' : '';
                                    return `<option value="${safeVal}" ${selected}>${name}</option>`;
                                }).join('')}
                            </select>

                            <button
                                id="returnPickBtn"
                                type="button"
                                class="${defaultPick ? 'px-4 py-2 rounded-xl bg-pink-600 hover:bg-pink-700 text-white font-bold text-sm' : 'px-4 py-2 rounded-xl bg-gray-200 text-gray-500 font-bold text-sm cursor-not-allowed'}"
                                onclick="confirmReturnPick()"
                                ${defaultPick ? '' : 'disabled'}
                            >Return Queen</button>
                        </div>
                    </div>
                </div>
            `;
            debug.innerText = "Return Queen";
            return;
        }
        const needsRegularReturnPick = !!(seasonData.returnState && ep.needsReturnPick);
        if (needsRegularReturnPick && scenarioPhase === 1) {
            const pool = (seasonData.returnState && Array.isArray(seasonData.returnState.eliminatedPool))
                ? seasonData.returnState.eliminatedPool
                : [];
            
            const prevEpIndex = currentEpIndex - 1;
            const maxEp = prevEpIndex >= 0 && seasonData.episodes[prevEpIndex] ? seasonData.episodes[prevEpIndex].episode : 0;
            const currentStatsArray = calculateQueenStats(seasonData, maxEp);
            const stats = {};
            currentStatsArray.forEach(s => { stats[s.name] = s; });

            const defaultPick = pool.length > 0
                ? [...pool].sort((a, b) => {
                    const ppeA = stats[a]?.ppe ?? -Infinity;
                    const ppeB = stats[b]?.ppe ?? -Infinity;
                    const tpA = stats[a]?.totalPoints ?? 0;
                    const tpB = stats[b]?.totalPoints ?? 0;
                    return (ppeB - ppeA) || (tpB - tpA) || String(a).localeCompare(String(b));
                })[0]
                : '';
            btn.classList.add('hidden');
            stage.innerHTML = `
                <div class="w-full text-center">
                    <h3 class="text-xl font-bold mb-2">Bring Back a Queen</h3>
                    <p class="text-sm text-gray-500 mb-5">Choose one eliminated queen to return.</p>
                    <div class="w-full max-w-md mx-auto px-3">
                        <div class="scenario-card perf-safe p-4 rounded-xl flex flex-col items-center gap-3 border border-gray-200 bg-white shadow-sm text-center">
                            <img
                                id="returnPickImg"
                                src="${defaultPick && queensDb[defaultPick] ? queensDb[defaultPick].photo : ''}"
                                class="queen-img-lg ${defaultPick ? '' : 'hidden'}"
                                alt=""
                            >
                            <div id="returnPickName" class="font-black text-lg text-gray-800 truncate w-full">${defaultPick || 'Select a queen…'}</div>
                            <span
                                id="returnPickPpe"
                                class="${defaultPick ? '' : 'hidden'} px-3 py-1 bg-pink-100 text-pink-700 rounded-full text-xs font-bold whitespace-nowrap"
                            >${defaultPick ? `${(stats[defaultPick]?.ppe ?? 0).toFixed(2)} PPE` : ''}</span>
                        </div>

                        <div class="mt-4 flex flex-col items-center gap-4">
                            <select
                                id="returnPickSelect"
                                class="w-full max-w-xs p-2 rounded-lg bg-white border border-gray-300 text-sm"
                                onchange="onReturnPickChange()"
                            >
                                ${pool.length === 0 ? `<option value="" selected>(No eliminated queens)</option>` : ''}
                                ${pool.map(name => {
                                    const safeVal = String(name).replace(/"/g, '&quot;');
                                    const selected = name === defaultPick ? 'selected' : '';
                                    return `<option value="${safeVal}" ${selected}>${name}</option>`;
                                }).join('')}
                            </select>

                            <button
                                id="returnPickBtn"
                                type="button"
                                class="${defaultPick ? 'px-4 py-2 rounded-xl bg-pink-600 hover:bg-pink-700 text-white font-bold text-sm' : 'px-4 py-2 rounded-xl bg-gray-200 text-gray-500 font-bold text-sm cursor-not-allowed'}"
                                onclick="confirmReturnPick()"
                                ${defaultPick ? '' : 'disabled'}
                            >Return Queen</button>
                        </div>
                    </div>
                </div>
            `;
            debug.innerText = "Return Queen";
            return;
        }
        if (scenarioPhase === 0) {
            trackDiv.classList.add('hidden');
            if (btn) {
                btn.classList.remove('hidden');
                btn.innerHTML = "START";
            }
            const runwayLine = (ep.hasRunway !== undefined ? ep.hasRunway : hasRunwayForChallenge(ep.challenge))
                ? `<div class="mt-2 sc-caption font-heading font-bold text-gray-400">☆ Runway ☆</div>`
                : '';
            stage.innerHTML = `
                <div class="mx-auto h-14 w-14 rounded-full bg-pink-100 flex items-center justify-center p-3">
                    <img src="images/Lipstick Streamline Core.svg" class="w-full h-full object-contain">
                </div>
                <div class="mt-6 sc-kicker text-gray-400 uppercase">MAXI CHALLENGE</div>
                <div class="mt-2 font-heading text-3xl sm:text-4xl font-bold text-[#ec4899]">${ep.challenge}</div>
                ${runwayLine}
                <div class="mt-3 text-sm text-gray-500">Racers, start your engines...</div>
            `;
            debug.innerText = "Challenge Announcement";
            if (btn) btn.innerHTML = "START";
        }
        else if (scenarioPhase === 1) {
            if (ep.challenge === 'Girl Groups' && ep.groups && !ep.groupsShown) {
                if (btn) {
                    btn.classList.remove('hidden');
                    btn.innerHTML = "Start Performances";
                    btn.onclick = () => {
                        ep.groupsShown = true;
                        renderScenario();
                    };
                }
                
                let groupsHtml = `<div class="grid grid-cols-1 md:grid-cols-2 gap-4 w-full max-w-5xl">`;
                
                ep.groups.forEach((group, idx) => {
                    groupsHtml += `
                        <div class="w-full rounded-2xl border border-gray-200/70 bg-white/80 shadow-sm overflow-hidden">
                            <div class="flex items-center justify-center px-4 py-3 border-b border-gray-100">
                                <div class="text-xs font-black text-gray-400 uppercase tracking-wider">Group ${idx + 1}</div>
                            </div>
                            <div class="p-3 grid grid-cols-1 sm:grid-cols-2 gap-2">
                                ${group.members.map(m => `
                                    <div class="scenario-card perf-safe p-2 rounded-xl flex items-center gap-2">
                                        <img src="${queensDb[m.name].photo}" class="queen-img-sm">
                                        <div class="text-left flex-1 min-w-0">
                                            <div class="font-bold text-sm truncate">${m.name}</div>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    `;
                });
                groupsHtml += `</div>`;

                stage.innerHTML = `
                    <div class="flex flex-col items-center w-full h-full animate-fade-in pt-4 overflow-y-auto">
                        <div class="w-full flex items-center justify-center max-w-5xl px-2">
                            <div class="sc-section font-heading font-bold text-gray-900 text-center">Groups</div>
                        </div>
                        <div class="mt-3 w-full flex justify-center">
                            ${groupsHtml}
                        </div>
                    </div>
                `;
                debug.innerText = "Groups Distribution";
                return;
            }

            if (btn) btn.classList.remove('hidden');
            const hasRunway = ep.hasRunway !== undefined ? ep.hasRunway : hasRunwayForChallenge(ep.challenge);
            const showRunway = hasRunway && ep.runwayShown;
            const perfScores = [...(ep.scores || [])].sort((a, b) => (b.challengeTotal || 0) - (a.challengeTotal || 0));
            const runwayScores = hasRunway
                ? [...(ep.scores || [])].sort((a, b) => (b.runwayTotal || 0) - (a.runwayTotal || 0))
                : [];
            const runwayTitle = ep.runway ? String(ep.runway).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/"/g, '&quot;') : '';
            stage.innerHTML = `
                <div class="w-full self-stretch flex flex-col items-stretch text-left">
                    <div class="w-full flex items-center justify-start gap-2 self-start">
                        <img src="images/mask.svg" class="w-5 h-5 object-contain">
                        <div class="sc-section font-heading font-bold text-gray-900 text-left">Performances</div>
                    </div>
                    <div class="mt-3 rounded-2xl border border-gray-200/70 bg-gray-50/40 overflow-hidden">
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-2 p-2 max-h-[320px] overflow-y-auto">
                            ${perfScores.map(s => `
                                <div class="scenario-card ${s.statusClass} p-3 rounded-xl flex items-center gap-3 min-h-[64px]">
                                    <img src="${queensDb[s.name].photo}" class="queen-img-sm">
                                    <div class="text-left flex-1 min-w-0">
                                        <div class="font-bold text-sm truncate">${s.name}</div>
                                        <div class="text-[11px] text-gray-600 leading-snug">${s.desc}</div>
                                    </div>
                                    <div class="text-[9px] text-gray-400 font-mono text-right whitespace-nowrap ml-2">${s.details}</div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                    ${showRunway ? `
                    <div class="mt-5">
                        <div class="w-full flex items-center justify-start gap-2 self-start">
                            <img src="images/stars.svg" class="w-5 h-5 object-contain">
                            <div class="sc-section font-heading font-bold text-gray-900 text-left">Runway</div>
                            ${runwayTitle ? `<span class="text-xs text-gray-400 truncate">"${runwayTitle}"</span>` : ''}
                        </div>
                        <div class="mt-3 rounded-2xl border border-gray-200/70 bg-gray-50/40 overflow-hidden">
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-2 p-2 max-h-[320px] overflow-y-auto">
                                ${runwayScores.map(s => `
                                    <div class="scenario-card ${s.runwayStatusClass || 'perf-safe'} p-3 rounded-xl flex items-center gap-3 min-h-[64px]">
                                        <img src="${queensDb[s.name].photo}" class="queen-img-sm">
                                        <div class="text-left flex-1 min-w-0">
                                            <div class="font-bold text-sm truncate">${s.name}</div>
                                            <div class="text-[11px] text-gray-600 leading-snug">${s.runwayDesc || 'Runway'}</div>
                                        </div>
                                        <div class="text-[9px] text-gray-400 font-mono text-right whitespace-nowrap ml-2">${s.runwayDetails || ''}</div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    </div>` : ''}
                </div>
            `;
            debug.innerText = "Performance Review";
            if (hasRunway && !ep.runwayShown) {
                btn.innerHTML = "Runway";
            } else {
                btn.innerHTML = "Call The Safe Queens";
            }
        }
        else if (scenarioPhase === 2) {
            const safes = ep.safe.map(s => s.name);
            if (safes.length === 0) {
                scenarioPhase++; 
                renderScenario(); 
                return;
            }
            stage.innerHTML = `
                <div class="w-full flex flex-col items-center gap-5 text-center">
                    <div class="flex flex-col items-center gap-2">
                        <h3 class="sc-section font-bold w-full text-center">You are Safe...</h3>
                        <div class="h-0.5 w-14 rounded-full bg-gray-200"></div>
                    </div>
                    <div class="w-full max-w-[880px] flex justify-center">
                        <div class="flex flex-wrap justify-center gap-x-8 gap-y-6">
                            ${safes.map(name => `
                                <div class="flex flex-col items-center w-32">
                                    <img src="${queensDb[name].photo}" class="queen-img-md grayscale opacity-80">
                                    <span class="mt-2 text-[12px] sm:text-[13px] font-semibold text-gray-800 text-center leading-snug truncate w-full">${name}</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                    <p class="text-[14px] text-gray-500">Please step to the back of the stage.</p>
                </div>
            `;
            debug.innerText = "Safe Declarations";
            btn.innerHTML = "Critiques";
        }
        else if (scenarioPhase === 3) {
            const isDoublePremiere = !!ep.isDoublePremiere;
            const high = ep.high || [];
            const highTeamRaw = ep.highTeam || [];
            const highTeam = highTeamRaw.length ? highTeamRaw : ((ep.challenge === 'Girl Groups' && ep.groups && ep.groups.length)
                ? (() => {
                    const sortedGroups = [...ep.groups].sort((a, b) => (b.avg || 0) - (a.avg || 0));
                    const winningGroup = sortedGroups[0];
                    if (!winningGroup || !winningGroup.members) return [];
                    const winnerNames = new Set((ep.winners || []).map(w => w.name || w));
                    return winningGroup.members.filter(m => !winnerNames.has(m.name || m));
                })()
                : []);
            let low = ep.low || [];
            let bottom = ep.bottom || [];
            let winners = ep.winners || [];
            let top2 = ep.top2 || [];
            let currentHigh = [...high];
            let currentHighTeam = [...highTeam];

            // Lucky Queen Twist: Visually restore original placements for critiques
            if (ep.luckyQueenTwistData && !ep.twistRevealed) {
                const saved = ep.luckyQueenTwistData.savedQueen;
                const rep = ep.luckyQueenTwistData.replacementQueen;
                const source = ep.luckyQueenTwistData.replacementSourceTier;

                // If replacement was HIGH/SAFE, move her back from bottom to her original tier for display
                if (bottom.find(b => (b.name || b) === rep)) {
                    bottom = bottom.filter(b => (b.name || b) !== rep);
                    if (source === 'low') {
                        if (!low.find(l => (l.name || l) === rep)) low.push({ name: rep });
                    } else if (source === 'high') {
                        if (!currentHigh.find(h => (h.name || h) === rep)) currentHigh.push({ name: rep });
                    } else if (source === 'highTeam') {
                        if (!currentHighTeam.find(h => (h.name || h) === rep)) currentHighTeam.push({ name: rep });
                    }
                    // if safe, she stays removed from bottom and will be safe by exclusion
                }

                // Move Saved Queen from Top tiers back to bottom section for display
                winners = winners.filter(w => (w.name || w) !== saved);
                top2 = top2.filter(t => (t.name || t) !== saved);
                currentHigh = currentHigh.filter(h => (h.name || h) !== saved);
                currentHighTeam = currentHighTeam.filter(h => (h.name || h) !== saved);
                
                // Ensure she is not already in low or bottom to avoid duplicates
                low = low.filter(l => (l.name || l) !== saved);
                bottom = bottom.filter(b => (b.name || b) !== saved);
                
                bottom.push({ name: saved });
            }

            const topsList = isDoublePremiere && top2 && top2.length
                ? [...top2, ...currentHigh, ...currentHighTeam]
                : [...winners, ...currentHigh, ...currentHighTeam];
            const hasBeaver = ep.isBeaverFormat && ep.beaverBottom3 && ep.beaverBottom3.length;
            let bottomsList;
            if (hasBeaver) {
                bottomsList = ep.beaverBottom3.map(name => {
                    const sObj = ep.scores.find(s => s.name === name) || { total: 0 };
                    return { name, total: sObj.total };
                });
            } else {
                bottomsList = [...low, ...bottom];
            }
            const noRealBottoms = isDoublePremiere && !hasBeaver && low.length === 0 && bottom.length === 0;
            const totalPointsText = (name) => {
                const sObj = (ep.scores || []).find(s => s.name === name);
                const tp = sObj ? sObj.total : 0;
                return (typeof tp === 'number' && isFinite(tp)) ? tp.toFixed(1) : '0.0';
            };
            stage.innerHTML = `
                <div class="w-full flex items-center justify-center">
                    <div class="w-full max-w-4xl">
                        <div class="text-center sc-label text-blue-600">THE TOPS</div>
                        <div class="mt-5 flex flex-wrap items-start justify-center gap-x-10 gap-y-7">
                            ${topsList.map(q => {
                                const qName = q.name || q;
                                return `
                                    <div class="flex flex-col items-center w-32">
                                        <div class="h-[92px] w-[92px] rounded-full p-[3px] bg-blue-200/60">
                                            <img src="${queensDb[qName].photo}" class="h-full w-full rounded-full object-cover border-2 border-white shadow-md">
                                        </div>
                                        <div class="mt-2 text-[12px] sm:text-[13px] font-bold text-gray-900 text-center leading-snug truncate w-full">${qName}</div>
                                        <div class="mt-1 text-[10px] font-bold text-blue-600">${totalPointsText(qName)}</div>
                                    </div>
                                `;
                            }).join('')}
                        </div>

                        <div class="mt-7 flex items-center gap-4">
                            <div class="h-px flex-1 bg-gray-200"></div>
                            <div class="text-[10px] font-black text-gray-400">VS</div>
                            <div class="h-px flex-1 bg-gray-200"></div>
                        </div>

                        <div class="mt-7 text-center sc-label text-rose-500">THE BOTTOMS</div>
                        <div class="mt-5 flex flex-wrap items-start justify-center gap-x-10 gap-y-7">
                            ${noRealBottoms
                                ? `<div class="text-[12px] font-semibold text-gray-500">No one is going home tonight.</div>`
                                : bottomsList.map(q => {
                                    const qName = q.name || q;
                                    return `
                                        <div class="flex flex-col items-center w-32">
                                            <div class="h-[92px] w-[92px] rounded-full p-[3px] bg-rose-200/60">
                                                <img src="${queensDb[qName].photo}" class="h-full w-full rounded-full object-cover border-2 border-white shadow-md">
                                            </div>
                                            <div class="mt-2 text-[12px] sm:text-[13px] font-bold text-gray-900 text-center leading-snug truncate w-full">${qName}</div>
                                            <div class="mt-1 text-[10px] font-bold text-rose-500">${totalPointsText(qName)}</div>
                                        </div>
                                    `;
                                }).join('')}
                        </div>
                        ${renderEpisodeBreakdown(ep)}
                    </div>
                </div>
            `;
            debug.innerText = "Judges Critiques";
            if (ep.isBeaverFormat) {
                btn.innerHTML = "Reveal The Winner";
            } else {
                btn.innerHTML = (ep.untucked && ep.untucked.length > 0) ? "Untucked" : "Reveal The Winner";
            }
        }
        else if (!ep.isBeaverFormat && scenarioPhase === 4 && ep.untucked && ep.untucked.length > 0) {
            const scenes = ep.untucked || [];
            stage.innerHTML = `
                <div class="w-full">
                    <div class="mx-auto h-12 w-12 rounded-full bg-pink-100 flex items-center justify-center p-3 mb-2">
                        <img src="images/chat.svg" class="w-full h-full object-contain">
                    </div>
                    <h3 class="sc-section font-bold mb-2 w-full text-center">Untucked</h3>
                    <p class="text-xs text-gray-500 mb-4 text-center sm:text-base ">Girl, if you're not watching Untucked, you're only getting half the story.</p>
                    <div class="space-y-3 max-h-[320px] overflow-y-auto text-left">
                        ${scenes.map(s => `
                            <div class="p-3 rounded-lg border-l-4 flex items-center gap-3 ${s.type === 'blame' ? 'border-red-400 bg-red-50' : s.type === 'shade' ? 'border-orange-400 bg-orange-50' : s.type === 'support' ? 'border-green-400 bg-green-50' : s.type === 'delulu' ? 'border-yellow-400 bg-yellow-50' : s.type === 'honest' ? 'border-teal-400 bg-teal-50' : s.type === 'strategy' ? 'border-gray-500 bg-gray-100' : 'border-pink-400 bg-pink-50'}">
                                <div class="flex items-center gap-2 flex-shrink-0">
                                    <img src="${queensDb[s.queen] ? queensDb[s.queen].photo : ''}" class="queen-img-sm border-2 border-white shadow" alt="">
                                    ${s.target ? `<img src="${queensDb[s.target] ? queensDb[s.target].photo : ''}" class="queen-img-sm border-2 border-white shadow" alt="">` : ''}
                                </div>
                                <p class="text-sm font-medium text-gray-800 flex-1 text-left">${s.text}</p>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
            debug.innerText = "Untucked";
            btn.innerHTML = "Reveal The Winner";
        }
        else if (ep.isBeaverFormat && scenarioPhase === 4) {
            const isDoublePremiere = !!ep.isDoublePremiere;
            const isPremiereTop2 = isDoublePremiere && ep.top2 && ep.top2.length;
            const winnersForScreen = isPremiereTop2 ? ep.top2 : ep.winners;
            const titleText = "Condragulations!";
            const winnerMessage = isPremiereTop2
                ? "you are the top 2 queens of this challenge"
                : "you are the winner of this challenge";
            const winnerNamesText = winnersForScreen.map(w => w.name).join(', ');
            const high = ep.high || [];
            const highTeamRaw = ep.highTeam || [];
            const highTeam = highTeamRaw.length ? highTeamRaw : ((ep.challenge === 'Girl Groups' && ep.groups && ep.groups.length)
                ? (() => {
                    const sortedGroups = [...ep.groups].sort((a, b) => (b.avg || 0) - (a.avg || 0));
                    const winningGroup = sortedGroups[0];
                    if (!winningGroup || !winningGroup.members) return [];
                    const winnerNames = new Set((ep.winners || []).map(w => w.name || w));
                    return winningGroup.members.filter(m => !winnerNames.has(m.name || m));
                })()
                : []);
            const highNamesText = high.map(h => h.name).join(', ');
            const highTeamNamesText = highTeam.map(h => h.name).join(', ');
            const bottomNames = (ep.beaverBottom3 && ep.beaverBottom3.length)
                ? ep.beaverBottom3
                : (ep.bottom || []).map(b => b.name || b);
            const bottomForScreen = bottomNames.slice(0, 3);
            const bottomNamesText = bottomForScreen.join(', ');
            const combinedWinnerNames = (highNamesText && !isDoublePremiere) ? `${winnerNamesText}, ${highNamesText}` : winnerNamesText;
            const renderCard = (qName, badge, badgeClass, borderClass, bgClass) => `
                <div class="relative flex flex-col items-center w-[150px] rounded-2xl border ${borderClass} ${bgClass} px-4 py-4 shadow-sm">
                    <div class="absolute -top-2 rounded-full ${badgeClass} px-2.5 py-1 text-[10px] font-black uppercase">${badge}</div>
                    <div class="queen-img-results-wrap rounded-full overflow-hidden">
                        <img src="${queensDb[qName].photo}" class="queen-img-results rounded-full">
                    </div>
                    <div class="mt-3 text-[13px] font-bold text-gray-900 text-center leading-snug truncate w-full">${qName}</div>
                </div>
            `;
            stage.innerHTML = `
                <div class="w-full flex justify-center">
                    <div class="w-full max-w-3xl text-center">
                        <div class="flex flex-col items-center">
                            <div class="flex flex-col items-center gap-0 text-gray-900">
                                <img src="images/crown.svg" class="w-6 h-6 object-contain">
                                <h3 class="sc-section font-bold">${titleText}</h3>
                            </div>
                            <div class="mt-2 h-[3px] w-12 rounded-full bg-amber-400"></div>
                        </div>

                        <div class="mt-6 text-[10px] font-black text-amber-500">CHALLENGE WINNER</div>
                        <div class="mt-4 flex flex-wrap items-start justify-center gap-4">
                            ${winnersForScreen.map(w => renderCard(w.name, isPremiereTop2 ? 'TOP 2' : 'WINNER', 'bg-amber-100 text-amber-800', 'border-amber-200', 'bg-amber-50')).join('')}
                        </div>
                        <p class="mt-2 text-[14px] text-gray-500">${combinedWinnerNames}, ${winnerMessage}.</p>

                        <div class="mt-6 flex items-center gap-4">
                            <div class="h-px flex-1 bg-gray-200"></div>
                            <div class="text-[9px] font-black text-gray-400">THE REST</div>
                            <div class="h-px flex-1 bg-gray-200"></div>
                        </div>

                        ${high.length ? `
                            <div class="mt-5">
                                <div class="text-[10px] font-black text-sky-600">HIGH</div>
                                <div class="mt-5 flex flex-wrap items-start justify-center gap-4">
                                    ${high.map(h => renderCard(h.name, 'HIGH', 'bg-sky-100 text-sky-700', 'border-sky-200', 'bg-sky-50')).join('')}
                                </div>
                                <p class="mt-2 text-[14px] text-gray-500">${highNamesText}, good job.</p>
                            </div>
                        ` : ''}

                        ${highTeam.length ? `
                            <div class="mt-5">
                                <div class="text-[10px] font-black text-teal-600">HIGH TEAM</div>
                                <div class="mt-5 flex flex-wrap items-start justify-center gap-4">
                                    ${highTeam.map(h => renderCard(h.name, 'HIGH TEAM', 'bg-teal-100 text-teal-700', 'border-teal-200', 'bg-teal-50')).join('')}
                                </div>
                                <p class="mt-2 text-[14px] text-gray-500">${highTeamNamesText}, good job as a team.</p>
                            </div>
                        ` : ''}

                        ${bottomForScreen.length ? `
                            <div class="mt-6">
                                <div class="flex items-center gap-4 text-[9px] font-black text-red-500">
                                    <div class="h-px flex-1 bg-red-200"></div>
                                    <span>X</span>
                                    <span>BOTTOM TWO</span>
                                    <span>X</span>
                                    <div class="h-px flex-1 bg-red-200"></div>
                                </div>
                                <div class="mt-5 flex flex-wrap items-start justify-center gap-4">
                                    ${bottomForScreen.map(name => renderCard(name, 'BOTTOM', 'bg-red-100 text-red-700', 'border-red-200', 'bg-red-50')).join('')}
                                </div>
                                <p class="mt-2 text-[14px] text-red-500">${bottomNamesText}, you are up for elimination.</p>
                            </div>
                        ` : ''}
                    </div>
                </div>
            `;
            debug.innerText = "Winner Announcement";
            if (ep.untucked && ep.untucked.length > 0) {
                btn.innerHTML = "Untucked";
            } else {
                btn.innerHTML = "Identify Bottom 2";
            }
        }
        else if (ep.isBeaverFormat && scenarioPhase === 5 && ep.untucked && ep.untucked.length > 0) {
            const scenes = ep.untucked || [];
            stage.innerHTML = `
                <div class="w-full">
                    <div class="mx-auto h-12 w-12 rounded-full bg-pink-100 flex items-center justify-center p-3 mb-2">
                        <img src="images/chat.svg" class="w-full h-full object-contain">
                    </div>
                    <h3 class="sc-section font-bold mb-2 w-full text-center">Untucked</h3>
                    <p class="text-xs text-gray-500 mb-4 text-center">Girl, if you're not watching Untucked, you're only getting half the story.</p>
                    <div class="space-y-3 max-h-[320px] overflow-y-auto text-left">
                        ${scenes.map(s => `
                            <div class="p-3 rounded-lg border-l-4 flex items-center gap-3 ${s.type === 'blame' ? 'border-red-400 bg-red-50' : s.type === 'shade' ? 'border-orange-400 bg-orange-50' : s.type === 'support' ? 'border-green-400 bg-green-50' : s.type === 'delulu' ? 'border-yellow-400 bg-yellow-50' : s.type === 'honest' ? 'border-teal-400 bg-teal-50' : s.type === 'strategy' ? 'border-gray-500 bg-gray-100' : 'border-pink-400 bg-pink-50'}">
                                <div class="flex items-center gap-2 flex-shrink-0">
                                    <img src="${queensDb[s.queen] ? queensDb[s.queen].photo : ''}" class="queen-img-sm border-2 border-white shadow" alt="">
                                    ${s.target ? `<img src="${queensDb[s.target] ? queensDb[s.target].photo : ''}" class="queen-img-sm border-2 border-white shadow" alt="">` : ''}
                                </div>
                                <p class="text-sm font-medium text-gray-800 flex-1 text-left">${s.text}</p>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
            debug.innerText = "Untucked";
            btn.innerHTML = "Identify Bottom 2";
        }
        else if (!ep.isBeaverFormat && (scenarioPhase === 4 || (scenarioPhase === 5 && ep.untucked && ep.untucked.length > 0))) {
            const isDoublePremiere = !!ep.isDoublePremiere;
            const isPremiereTop2 = isDoublePremiere && ep.top2 && ep.top2.length;
            const winnersForScreen = isPremiereTop2 ? ep.top2 : ep.winners;
            const titleText = "Condragulations!";
            const winnerMessage = isPremiereTop2
                ? "you are the top 2 queens of this challenge"
                : "you are the winner of this challenge";
            const winnerNamesText = winnersForScreen.map(w => w.name).join(', ');
            const high = ep.high || [];
            const highTeamRaw = ep.highTeam || [];
            const highTeam = highTeamRaw.length ? highTeamRaw : ((ep.challenge === 'Girl Groups' && ep.groups && ep.groups.length)
                ? (() => {
                    const sortedGroups = [...ep.groups].sort((a, b) => (b.avg || 0) - (a.avg || 0));
                    const winningGroup = sortedGroups[0];
                    if (!winningGroup || !winningGroup.members) return [];
                    const winnerNames = new Set((ep.winners || []).map(w => w.name || w));
                    return winningGroup.members.filter(m => !winnerNames.has(m.name || m));
                })()
                : []);
                let lowList = (ep.low || []).map(q => q.name || q);
                let bottomList = (ep.bottom || []).map(q => q.name || q);
                let winnersList = (winnersForScreen || []).map(q => q.name || q);

                if (ep.luckyQueenTwistData && !ep.twistRevealed) {
                    const saved = ep.luckyQueenTwistData.savedQueen;
                    const rep = ep.luckyQueenTwistData.replacementQueen;
                    const source = ep.luckyQueenTwistData.replacementSourceTier;

                    if (lowList.includes(saved)) {
                        lowList = lowList.filter(n => n !== saved);
                        if (!bottomList.includes(saved)) bottomList.push(saved);
                    }
                    
                    if (bottomList.includes(rep)) {
                        bottomList = bottomList.filter(n => n !== rep);
                        if (source === 'low') {
                            if (!lowList.includes(rep)) lowList.push(rep);
                        } else if (source === 'high') {
                            if (!high.find(h => h.name === rep)) high.push({ name: rep });
                        } else if (source === 'highTeam') {
                            if (!highTeam.find(h => h.name === rep)) highTeam.push({ name: rep });
                        } else if (source === 'safe') {
                            // Handled by default since it won't be in high/low lists
                        }
                    }
                }

                const lowNamesText = lowList.join(', ');
                const bottomNamesText = bottomList.join(', ');
                const highNamesText = high.map(h => h.name).join(', ');
                const highTeamNamesText = highTeam.map(h => h.name).join(', ');
                const combinedWinnerNames = (highNamesText && !isDoublePremiere) ? `${winnerNamesText}, ${highNamesText}` : winnerNamesText;
            const renderCard = (qName, badge, badgeClass, borderClass, bgClass) => `
                <div class="relative flex flex-col items-center w-[150px] rounded-2xl border ${borderClass} ${bgClass} px-4 py-4 shadow-sm">
                    <div class="absolute -top-2 rounded-full ${badgeClass} px-2.5 py-1 text-[10px] font-black uppercase">${badge}</div>
                    <div class="queen-img-results-wrap rounded-full overflow-hidden">
                        <img src="${queensDb[qName].photo}" class="queen-img-results rounded-full">
                    </div>
                    <div class="mt-3 text-[13px] font-bold text-gray-900 text-center leading-snug truncate w-full">${qName}</div>
                </div>
            `;
            const skipBottom2 = () => {
                scenarioPhase += 2;
                renderScenario();
            };
            stage.innerHTML = `
                <div class="w-full flex justify-center">
                    <div class="w-full max-w-3xl text-center">
                        <div class="flex flex-col items-center">
                            <div class="flex flex-col items-center gap-0 text-gray-900">
                                <img src="images/crown.svg" class="w-6 h-6 object-contain">
                                <h3 class="sc-section font-bold">${titleText}</h3>
                            </div>
                            <div class="mt-2 h-[3px] w-12 rounded-full bg-amber-400"></div>
                        </div>

                        <div class="mt-6 text-[10px] font-black text-amber-500">CHALLENGE WINNER</div>
                        <div class="mt-4 flex flex-wrap items-start justify-center gap-4">
                            ${winnersForScreen.map(w => renderCard(w.name, isPremiereTop2 ? 'TOP 2' : 'WINNER', 'bg-amber-100 text-amber-800', 'border-amber-200', 'bg-amber-50')).join('')}
                        </div>
                        <p class="mt-2 text-[14px] text-gray-500">${combinedWinnerNames}, ${winnerMessage}.</p>

                        <div class="mt-6 flex items-center gap-4">
                            <div class="h-px flex-1 bg-gray-200"></div>
                            <div class="text-[9px] font-black text-gray-400">THE REST</div>
                            <div class="h-px flex-1 bg-gray-200"></div>
                        </div>

                        ${high.length ? `
                            <div class="mt-5">
                                <div class="text-[10px] font-black text-sky-600">HIGH</div>
                                <div class="mt-5 flex flex-wrap items-start justify-center gap-4">
                                    ${high.map(h => renderCard(h.name, 'HIGH', 'bg-sky-100 text-sky-700', 'border-sky-200', 'bg-sky-50')).join('')}
                                </div>
                                <p class="mt-2 text-[14px] text-gray-500">${highNamesText}, good job.</p>
                            </div>
                        ` : ''}
                        ${highTeam.length ? `
                            <div class="mt-5">
                                <div class="text-[10px] font-black text-teal-600">HIGH TEAM</div>
                                <div class="mt-5 flex flex-wrap items-start justify-center gap-4">
                                    ${highTeam.map(h => renderCard(h.name, 'HIGH TEAM', 'bg-teal-100 text-teal-700', 'border-teal-200', 'bg-teal-50')).join('')}
                                </div>
                                <p class="mt-2 text-[14px] text-gray-500">${highTeamNamesText}, good job as a team.</p>
                            </div>
                        ` : ''}
                        ${lowList.length ? `
                            <div class="mt-5">
                                <div class="text-[10px] font-black text-orange-600">LOW</div>
                                <div class="mt-5 flex flex-wrap items-start justify-center gap-4">
                                    ${lowList.map(name => renderCard(name, 'LOW', 'bg-orange-100 text-orange-700', 'border-orange-200', 'bg-orange-50')).join('')}
                                </div>
                                <p class="mt-2 text-[14px] text-gray-500">${lowNamesText}, you are safe... barely.</p>
                            </div>
                        ` : ''}
                        ${bottomList.length ? `
                            <div class="mt-6">
                                <div class="flex items-center gap-4 text-[9px] font-black text-red-500">
                                    <div class="h-px flex-1 bg-red-200"></div>
                                    <span>X</span>
                                    <span>BOTTOM TWO</span>
                                    <span>X</span>
                                    <div class="h-px flex-1 bg-red-200"></div>
                                </div>
                                <div class="mt-5 flex flex-wrap items-start justify-center gap-4">
                                    ${bottomList.map(name => renderCard(name, 'BOTTOM', 'bg-red-100 text-red-700', 'border-red-200', 'bg-red-50')).join('')}
                                </div>
                                <p class="mt-2 text-[14px] text-red-500">${bottomNamesText}, you are up for elimination.</p>
                            </div>
                        ` : ''}
                    </div>
                </div>
            `;
            debug.innerText = "Winner Announcement";
            const isPremiereWin = isDoublePremiere && (!ep.bottom || ep.bottom.length === 0);
            btn.innerHTML = isPremiereWin ? "Lip Sync For The Win" : "Lip Sync For Your Life";
            btn.onclick = skipBottom2;
        }
        else if ((scenarioPhase === 5 && !(ep.untucked && ep.untucked.length > 0)) || (scenarioPhase === 6 && (ep.untucked && ep.untucked.length > 0))) {
            const isDoublePremiere = !!ep.isDoublePremiere;
            const isPremiereWinPhase = isDoublePremiere && (!ep.bottom || ep.bottom.length === 0);
            const skipForDoublePremiere = isPremiereWinPhase;
            if (skipForDoublePremiere) {
                scenarioPhase++;
                renderScenario();
                return;
            }
            if (ep.isBeaverFormat && ep.beaverBottom3 && ep.beaverBottom3.length && !isPremiereWinPhase) {
                const beaverNames = ep.beaverBottom3;
                const beaverSaved = (ep.beaverSavedForUI || ep.beaverSaved);
                const lipNames = beaverNames.filter(n => n !== beaverSaved);
                const winnerName = (ep.winners && ep.winners[0] && ep.winners[0].name) ? ep.winners[0].name : '';
                const revealBeaverSave = () => {
                    if (beaverSaved) {
                        beaverNames.forEach(name => {
                            const dk = (`${ep.episode}_${name}`).replace(/[^a-z0-9]+/gi, '_');
                            const c = document.getElementById(`beaverCard_${dk}`);
                            if (c) c.className = 'relative flex flex-col items-center w-[150px] rounded-2xl border border-red-500 bg-red-50 px-4 py-4 shadow-sm';
                        });
                        const domKey = (`${ep.episode}_${beaverSaved}`).replace(/[^a-z0-9]+/gi, '_');
                        const card = document.getElementById(`beaverCard_${domKey}`);
                        const badge = document.getElementById(`beaverBadge_${domKey}`);
                        if (card) card.className = 'relative flex flex-col items-center w-[150px] rounded-2xl border border-orange-400 bg-orange-50 px-4 py-4 shadow-sm';
                        if (badge) badge.classList.remove('hidden');
                        const reason = document.getElementById('beaverReason');
                        if (reason && reason.textContent && reason.textContent.trim().length) reason.classList.remove('hidden');
                    }
                    btn.innerHTML = "Lip Sync For Your Life";
                    btn.onclick = advanceScenario;
                };
                stage.innerHTML = `
                    <div class="w-full text-center">
                        <div class="mx-auto h-12 w-12 rounded-full bg-pink-100 flex items-center justify-center p-3 mb-2">
                            <img src="images/shield.svg" class="w-full h-full object-contain">
                        </div>
                        <h3 class="text-[20px] sm:text-[24px] font-bold mb-4 w-full text-center">Beaver Save</h3>
                        ${winnerName ? `
                            <div class="flex justify-center flex-wrap gap-3 sm:gap-4 mb-2">
                                <div class="relative flex flex-col items-center w-[150px] rounded-2xl border border-amber-200 bg-yellow-50 px-4 py-4 shadow-sm">
                                    <div class="absolute -top-2 rounded-full bg-amber-100 text-amber-800 px-2.5 py-1 text-[10px] font-black uppercase">WINNER</div>
                                    <div class="queen-img-results-wrap rounded-full overflow-hidden">
                                        <img src="${queensDb[winnerName].photo}" class="queen-img-results rounded-full">
                                    </div>
                                    <div class="mt-3 text-[13px] font-bold text-gray-900 text-center leading-snug truncate w-full">${winnerName}</div>
                                </div>
                            </div>
                            <p class="text-[14px] text-[#6B7280] font-regular mt-2">${winnerName}, heavy is the hand that holds the beaver.<br>Who do you wanna save?</p>
                        ` : ''}
                        <div class="mt-6">
                            <div class="flex justify-center flex-wrap gap-3 sm:gap-4">
                                ${beaverNames.map(name => {
                                    const domKey = (`${ep.episode}_${name}`).replace(/[^a-z0-9]+/gi, '_');
                                    return `
                                        <div id="beaverCard_${domKey}" class="relative flex flex-col items-center w-[150px] rounded-2xl border border-pink-300 bg-pink-50 px-4 py-4 shadow-sm">
                                            <div class="queen-img-results-wrap rounded-full overflow-hidden">
                                                <img src="${queensDb[name].photo}" class="queen-img-results rounded-full">
                                            </div>
                                            <div class="mt-3 text-[13px] font-bold text-gray-900 text-center leading-snug truncate w-full">${name}</div>
                                            <div id="beaverBadge_${domKey}" class="absolute -top-2 hidden rounded-full bg-orange-100 text-orange-700 px-2.5 py-1 text-[10px] font-black uppercase">BEAVER</div>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                            <p id="beaverReason" class="hidden text-[14px] text-[#6B7280] font-regular mt-2">${ep.beaverReason || ''}</p>
                        </div>
                    </div>
                `;
                debug.innerText = "Beaver Save";
                btn.innerHTML = "Reveal";
                btn.onclick = revealBeaverSave;
                return;
            }

            if (!isDoublePremiere && !ep.isBeaverFormat) {
                const winnersForScreen = ep.winners || [];
                const titleText = "Condragulations!";
                const winnerNamesText = winnersForScreen.map(w => w.name).join(', ');
                const winnerMessage = ep.isAllStars
                    ? "you're the top 2 queens of this week"
                    : "you're the winner of this week's maxi-challenge!";
                
                let high = ep.high || [];
                let highTeamRaw = ep.highTeam || [];
                let highTeam = highTeamRaw.length ? highTeamRaw : ((ep.challenge === 'Girl Groups' && ep.groups && ep.groups.length)
                    ? (() => {
                        const sortedGroups = [...ep.groups].sort((a, b) => (b.avg || 0) - (a.avg || 0));
                        const winningGroup = sortedGroups[0];
                        if (!winningGroup || !winningGroup.members) return [];
                        const winnerNames = new Set((ep.winners || []).map(w => w.name || w));
                        return winningGroup.members.filter(m => !winnerNames.has(m.name || m));
                    })()
                    : []);
                
                let lowList = (ep.low || []).map(q => q.name || q);
                let bottomList = (ep.bottom || []).map(q => q.name || q);

                // Lucky Queen Twist: Visually restore original placements for this screen
                if (ep.luckyQueenTwistData) {
                    const saved = ep.luckyQueenTwistData.savedQueen;
                    const rep = ep.luckyQueenTwistData.replacementQueen;
                    const source = ep.luckyQueenTwistData.replacementSourceTier;

                    // Move Saved Queen from LOW to BOTTOM
                    if (lowList.includes(saved)) {
                        lowList = lowList.filter(n => n !== saved);
                        if (!bottomList.includes(saved)) bottomList.push(saved);
                    }
                    
                    // Move Replacement Queen from BOTTOM to Source Tier
                    if (bottomList.includes(rep)) {
                        bottomList = bottomList.filter(n => n !== rep);
                        if (source === 'low') {
                            if (!lowList.includes(rep)) lowList.push(rep);
                        } else if (source === 'high') {
                            if (!high.find(h => h.name === rep)) high.push({ name: rep });
                        } else if (source === 'highTeam') {
                            if (!highTeam.find(h => h.name === rep)) highTeam.push({ name: rep });
                        } else if (source === 'safe') {
                            // If the source was SAFE, she just needs to be removed from bottomList
                        }
                    }
                }

                const highNamesText = high.map(h => h.name).join(', ');
                const highTeamNamesText = highTeam.map(h => h.name).join(', ');
                const lowNamesText = lowList.join(', ');
                const bottomNamesText = bottomList.join(', ');
                stage.innerHTML = `
                    <div class="text-center">
                        <div class="flex flex-col items-center mb-4 w-full">
                            <img src="images/crown.svg" class="w-6 h-6 object-contain mb-0">
                            <h3 class="text-xl font-bold w-full text-center">${titleText}</h3>
                        </div>
                        <div class="flex justify-center flex-wrap gap-3 sm:gap-4 mb-2">
                            ${winnersForScreen.map(w => `
                                <div class="flex flex-col items-center p-3 sm:p-4 rounded-xl bg-yellow-50 border-2 border-yellow-300">
                                    <img src="${queensDb[w.name].photo}" class="queen-img-results">
                                    <span class="font-bold mt-1 sm:mt-2 text-center leading-snug px-1 truncate w-28 sm:w-32">${w.name}</span>
                                    <span class="text-xs font-black text-yellow-700 mt-1 sm:mt-2">WIN</span>
                                </div>
                            `).join('')}
                        </div>
                        <p class="text-[16px] text-black font-regular mt-2">${winnerNamesText}${highNamesText ? ', ' + highNamesText : ''}, ${winnerMessage}</p>
                        ${high.length ? `
                            <div class="mt-4">
                                <div class="flex justify-center flex-wrap gap-3 sm:gap-4">
                                    ${high.map(h => `
                                        <div class="flex flex-col items-center p-3 sm:p-4 rounded-xl bg-blue-50 border-2 border-blue-200">
                                            <img src="${queensDb[h.name].photo}" class="queen-img-results">
                                            <span class="font-bold mt-1 sm:mt-2 text-center leading-snug px-1 truncate w-28 sm:w-32">${h.name}</span>
                                        </div>
                                    `).join('')}
                                </div>
                                <p class="text-[16px] text-black font-regular mt-2">${highNamesText}, good joob, you're safe</p>
                            </div>
                        ` : ''}
                        ${highTeam.length ? `
                            <div class="mt-4">
                                <div class="flex justify-center flex-wrap gap-3 sm:gap-4">
                                    ${highTeam.map(h => `
                                        <div class="flex flex-col items-center p-3 sm:p-4 rounded-xl bg-teal-50 border-2 border-teal-200">
                                            <img src="${queensDb[h.name].photo}" class="queen-img-results">
                                            <span class="font-bold mt-1 sm:mt-2 text-center leading-snug px-1 truncate w-28 sm:w-32">${h.name}</span>
                                        </div>
                                    `).join('')}
                                </div>
                                <p class="text-[16px] text-black font-regular mt-2">${highTeamNamesText}, good job as a team</p>
                            </div>
                        ` : ''}
                        ${lowList.length ? `
                            <div class="mt-6">
                                <div class="flex justify-center flex-wrap gap-3 sm:gap-4">
                                    ${lowList.map(name => `
                                        <div class="flex flex-col items-center p-3 sm:p-4 rounded-xl bg-pink-50 border-2 border-pink-300">
                                            <img src="${queensDb[name].photo}" class="queen-img-results">
                                            <span class="font-bold mt-1 sm:mt-2 text-center leading-snug px-1 truncate w-28 sm:w-32">${name}</span>
                                        </div>
                                    `).join('')}
                                </div>
                                <p class="text-[16px] text-black font-regular mt-2">${lowNamesText}, you're safe</p>
                            </div>
                        ` : ''}
                        ${bottomList.length ? `
                            <div class="mt-6">
                                <div class="flex justify-center flex-wrap gap-3 sm:gap-4">
                                    ${bottomList.map(name => `
                                        <div class="flex flex-col items-center p-3 sm:p-4 rounded-xl bg-red-50 border-2 border-red-500">
                                            <img src="${queensDb[name].photo}" class="queen-img-results">
                                            <span class="font-bold mt-1 sm:mt-2 text-center leading-snug px-1 truncate w-28 sm:w-32">${name}</span>
                                        </div>
                                    `).join('')}
                                </div>
                                <p class="text-[16px] text-black font-regular mt-2">${bottomNamesText}, I'm sorry, my dears, but you are up for elimination</p>
                            </div>
                        ` : ''}
                    </div>
                `;
                debug.innerText = "Bottom 2";
                btn.innerHTML = "Lip Sync For Your Life";
                return;
            }

            const isPremiereWin = isDoublePremiere && (!ep.bottom || ep.bottom.length === 0);
            const titleText = isPremiereWin ? "Good news, my dears" : "I'm Sorry My Dears";
            const messageText = isPremiereWin ? "You are safe. No one is going home tonight." : "You are up for elimination.";
            const sourceBottom = isPremiereWin ? (ep.low || []) : (ep.bottom || []);
            const containerClass = isPremiereWin && sourceBottom.length === 1
                ? "flex justify-center items-center px-4"
                : "flex justify-between items-center px-4";
            const first = sourceBottom[0];
            const second = sourceBottom[1];
            const vsBlock = !isPremiereWin && first && second ? `<span class="text-xl font-black text-red-500">VS</span>` : '';
            stage.innerHTML = isPremiereWin ? `
                <div class="w-full text-center">
                    <p class="text-sm text-gray-500 font-bold mb-4 uppercase">${titleText}</p>
                    ${(sourceBottom && sourceBottom.length) ? `
                        <div class="flex justify-center flex-wrap gap-3 sm:gap-4 mt-4">
                            ${sourceBottom.map(q => {
                                const name = q.name || q;
                                if (!name) return '';
                                return `
                                    <div class="flex flex-col items-center p-3 sm:p-4 rounded-xl bg-gray-100 border-2 border-gray-200">
                                        <img src="${queensDb[name].photo}" class="queen-img-results">
                                        <span class="font-bold mt-1 sm:mt-2 text-center leading-snug px-1 truncate w-28 sm:w-32">${name}</span>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    ` : ''}
                    <p class="text-[16px] text-black font-regular mt-4">${messageText}</p>
                </div>
            ` : `
                <div class="bg-red-900 text-white p-6 rounded-2xl w-full max-w-md shadow-inner">
                    <h2 class="text-2xl font-black mb-6 text-red-500 uppercase">${titleText}</h2>
                    <p class="mb-4 font-bold">${messageText}</p>
                    <div class="${containerClass}">
                        ${first ? `
                        <div class="flex flex-col items-center">
                            <img src="${queensDb[first.name].photo}" class="w-20 h-20 rounded-full border-4 border-red-500">
                            <span class="font-bold mt-2">${first.name}</span>
                        </div>` : ''}
                        ${vsBlock}
                        ${second ? `
                        <div class="flex flex-col items-center">
                            <img src="${queensDb[second.name].photo}" class="w-20 h-20 rounded-full border-4 border-red-500">
                            <span class="font-bold mt-2">${second.name}</span>
                        </div>` : ''}
                    </div>
                </div>
            `;
            debug.innerText = "Bottom 2";
            const isPremiereWin2 = isDoublePremiere && (!ep.bottom || ep.bottom.length === 0);
            btn.innerHTML = isPremiereWin2 ? "Lip Sync For The Win" : "Lip Sync For Your Life";
        }
        else if (((scenarioPhase === 6) && !(ep.untucked && ep.untucked.length > 0)) || ((scenarioPhase === 7) && (ep.untucked && ep.untucked.length > 0))) {
            const isPremiereWin3 = ep.isDoublePremiere && (!ep.bottom || ep.bottom.length === 0);
            if (isPremiereWin3) {
                const ls = ep.lipSyncTop2 || [];
                const winnerName = ep.lipSyncWinner;
                const revealPremiereResults = () => {
                    ls.forEach(q => {
                        const domKey = (`${ep.episode}_${q.name}`).replace(/[^a-z0-9]+/gi, '_');
                        const isWinner = q.name === winnerName;
                        const card = document.getElementById(`premiereCard_${domKey}`);
                        const val = document.getElementById(`premiereVal_${domKey}`);
                        const badge = document.getElementById(`premiereBadge_${domKey}`);
                        const cardResultClass = isWinner
                            ? 'border-yellow-300 bg-yellow-50 shadow-lg shadow-yellow-200/50'
                            : 'border-slate-200 bg-slate-50';
                        if (card) {
                            card.className = `flex flex-col items-center gap-2 rounded-2xl border p-5 w-44 sm:w-56 min-w-0 transition ${cardResultClass}`;
                        }
                        if (val) {
                            val.innerText = `Score: ${val.dataset.score}`;
                            val.className = 'text-xs text-gray-500';
                        }
                        if (badge) {
                            badge.innerText = isWinner ? 'Winner' : 'Safe';
                            badge.className = isWinner
                                ? 'mt-2 rounded-full px-3 py-1 text-xs font-bold bg-yellow-500 text-white'
                                : 'mt-2 rounded-full px-3 py-1 text-xs font-bold bg-slate-200 text-slate-700';
                            badge.classList.remove('hidden');
                        }
                    });
                    const results = document.getElementById('premiereResults');
                    if (results) results.classList.remove('hidden');
                    btn.innerHTML = "Show Track Record";
                    btn.onclick = advanceScenario;
                };
                stage.innerHTML = `
                    <div class="w-full text-center">
                        <div class="flex flex-col items-center gap-2">
                            <div class="text-3xl text-pink-500">✨</div>
                            <h2 class="text-2xl font-bold text-gray-900 font-heading">Lip Sync For The Win</h2>
                            <div class="text-sm text-gray-500">"${ep.lipSyncSong || ''}"</div>
                        </div>
                        <div class="mt-8 flex items-center justify-center gap-6 sm:gap-10">
                            ${ls.map(q => {
                                const domKey = (`${ep.episode}_${q.name}`).replace(/[^a-z0-9]+/gi, '_');
                                const scoreText = (q.score !== undefined && q.score !== null) ? q.score.toFixed(1) : '-';
                                return `
                                    <div id="premiereCard_${domKey}" class="flex flex-col items-center gap-2 rounded-2xl border border-pink-200 bg-pink-50/40 p-5 w-44 sm:w-56 min-w-0 transition">
                                        <img src="${queensDb[q.name].photo}" class="queen-img-lg" alt="">
                                        <span class="w-full text-center text-sm font-bold text-gray-900 leading-tight px-1 min-h-[2.5rem] max-h-[2.5rem] overflow-hidden sm:text-base">${q.name}</span>
                                        <span id="premiereVal_${domKey}" data-score="${scoreText}" class="text-xs text-gray-500">Score: ${scoreText}</span>
                                        <span id="premiereBadge_${domKey}" class="hidden"></span>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                        <div id="premiereResults" class="mt-6 text-sm text-gray-500 hidden">
                            No one is going home tonight. The rest of the queens are safe.
                        </div>
                    </div>
                `;
                debug.innerText = "Lip Sync For The Win";
                btn.innerHTML = "Results";
                btn.onclick = revealPremiereResults;
            } else {
                const isAllStarsPhase = seasonData.isAllStars && !(ep.isTournament && ep.tournamentStage === 'Semi-Finals');
                let queens = isAllStarsPhase ? ep.top2 : ep.bottom;
                
                let isTwistRevealPending = false;
                if (ep.luckyQueenTwistData && !ep.twistRevealed) {
                    isTwistRevealPending = true;
                    queens = ep.luckyQueenTwistData.originalBottom.map(q => ({
                        name: q.name,
                        score: q.score,
                        info: ''
                    }));
                }

                // Lip Sync Results Display (Elimination or All Stars Win)
                const revealEliminationResults = () => {
                    const eliminatedNames = Array.isArray(ep.eliminated) ? ep.eliminated : [ep.eliminated];
                    queens.forEach(q => {
                        const isWinner = isAllStarsPhase
                            ? (ep.isDoubleWin || ep.lipSyncWinner === q.name)
                            : (ep.eliminated !== q.name && !ep.isDoubleShantay && !(Array.isArray(ep.eliminated) && ep.eliminated.includes(q.name)));
                        const domKey = (`${ep.episode}_${q.name}`).replace(/[^a-z0-9]+/gi, '_');
                        const resultText = isAllStarsPhase
                            ? (ep.isDoubleWin ? 'WINNER' : (isWinner ? 'WINNER' : 'TOP 2'))
                            : (ep.isDoubleShantay ? 'SHANTAY' : (isWinner ? 'SHANTAY' : 'SASHAY'));
                        const isEliminated = !ep.isDoubleShantay && eliminatedNames.includes(q.name);
                        const cardResultClass = isAllStarsPhase
                            ? (resultText === 'WINNER' ? 'border-yellow-300 bg-yellow-50 shadow-lg shadow-yellow-200/50' : 'border-gray-200 bg-gray-50')
                            : (resultText === 'SHANTAY' ? 'border-pink-400 bg-pink-50 shadow-lg shadow-pink-200/60' : 'border-gray-200 bg-gray-50 opacity-60');
                        const badgeClass = isAllStarsPhase
                            ? (resultText === 'WINNER' ? 'bg-yellow-500 text-white' : 'bg-gray-200 text-gray-600')
                            : (resultText === 'SHANTAY' ? 'bg-pink-600 text-white' : 'bg-gray-200 text-gray-500');
                        const badgeText = isAllStarsPhase
                            ? (resultText === 'WINNER' ? 'Winner' : 'Safe')
                            : (resultText === 'SHANTAY' ? 'Shantay' : 'Sashay');
                        const badge = document.getElementById(`lipBadge_${domKey}`);
                        const img = document.getElementById(`lipImg_${domKey}`);
                        const card = document.getElementById(`lipCard_${domKey}`);
                        if (card) {
                            card.className = `flex flex-col items-center gap-2 rounded-2xl border p-5 w-44 sm:w-56 min-w-0 transition ${cardResultClass}`;
                        }
                        if (badge) {
                            badge.textContent = badgeText;
                            badge.className = `mt-2 rounded-full px-3 py-1 text-xs font-bold ${badgeClass}`;
                            badge.classList.remove('hidden');
                        }
                        if (img) {
                            img.className = `queen-img-lg${isEliminated ? ' grayscale opacity-70' : ''}`;
                        }
                    });
                    const msg = document.getElementById('lipMessage');
                    if (msg) {
                        if (!isAllStarsPhase && ep.isDoubleShantay) {
                            // Double Shantay Logic
                            msg.textContent = 'Shantay, you both stay.';
                        } else if (isAllStarsPhase && ep.isDoubleWin) {
                            // Double Win Logic
                            const names = queens.map(q => q.name || q).join(', ');
                            msg.innerHTML = `${names}, condragulations.<br>You are both winners, baby!`;
                        } else if (!isAllStarsPhase && eliminatedNames.length) {
                            // Standard Elimination Logic
                            if (eliminatedNames.length > 1) {
                                msg.textContent = "Neither of you survived that lip sync. <br> Sashay away... both of you.";
                            } else {
                                const elimName = eliminatedNames[0];
                                const getName = (item) => (item && typeof item === 'object' && item.name) ? item.name : item;
                                const winnerObj = queens.find(q => getName(q) !== elimName);
                                if (winnerObj) {
                                    msg.innerHTML = `${getName(winnerObj)}... shantay, you stay.<br>${elimName}... sashay away.`;
                                } else {
                                    msg.textContent = `${elimName}... sashay away.`;
                                }
                            }
                        } else if (isAllStarsPhase && ep.lipSyncWinner) {
                            msg.textContent = `${ep.lipSyncWinner}, you're winner, baby!`;
                        } else {
                            msg.textContent = '';
                        }
                        msg.classList.toggle('hidden', !msg.textContent);
                    }
                    btn.innerHTML = "Show Track Record";
                    btn.onclick = advanceScenario;
                };

                stage.innerHTML = `
                    <div class="w-full text-center">
                        <div class="flex flex-col items-center gap-2">
                            <div class="mx-auto h-12 w-12 rounded-full bg-pink-100 flex items-center justify-center p-3">
                                <img src="images/sword.svg" class="w-full h-full object-contain">
                            </div>
                            <h2 class="text-2xl font-bold text-gray-900 font-heading" style="font-family: 'Poppins', sans-serif;">Lip Sync For Your Life</h2>
                            <div class="text-sm text-gray-500">"${ep.lipSyncSong || ''}"</div>
                        </div>
                        <div class="mt-8 flex items-center justify-center gap-6 sm:gap-10">
                            ${queens.map(q => {
                                const isWinner = isAllStarsPhase 
                                    ? (ep.isDoubleWin || ep.lipSyncWinner === q.name)
                                    : (ep.eliminated !== q.name && !ep.isDoubleShantay);
                                const domKey = (`${ep.episode}_${q.name}`).replace(/[^a-z0-9]+/gi, '_');
                                const scoreText = (q.score !== undefined && q.score !== null) ? q.score.toFixed(1) : '-';
                                return createQueenCardHtml({
                                    domKey,
                                    queenName: q.name,
                                    photoUrl: queensDb[q.name].photo,
                                    score: scoreText,
                                    cardId: `lipCard_${domKey}`,
                                    imgId: `lipImg_${domKey}`,
                                    badgeId: `lipBadge_${domKey}`,
                                    baseClasses: "border-red-200 bg-red-50/40"
                                });
                            }).join('')}
                        </div>
                        <div id="lipMessage" class="mt-6 text-sm text-gray-500 hidden"></div>
                    </div>
                `;
                debug.innerText = "Elimination";
                
                if (isTwistRevealPending) {
                    btn.innerHTML = "Results";
                    
                    // We need a NEW button behavior for Lucky Queen reveal
                    // Skip Double Shantay/Elimination result and go straight to WAIT!
                    btn.onclick = () => {
                        const savedName = ep.luckyQueenTwistData.savedQueen;
                        const repName = ep.luckyQueenTwistData.replacementQueen;
                        
                        // Change Header
                        const header = stage.querySelector('h2');
                        if (header) header.innerText = "WAIT!";

                        // Update Cards
                        ep.luckyQueenTwistData.originalBottom.forEach(q => {
                            const domKey = (`${ep.episode}_${q.name}`).replace(/[^a-z0-9]+/gi, '_');
                            const card = document.getElementById(`lipCard_${domKey}`);
                            const badge = document.getElementById(`lipBadge_${domKey}`);
                            
                            if (q.name === savedName) {
                                // Lucky Queen Styles - Winner Look
                                if (card) card.className = "flex flex-col items-center gap-2 rounded-2xl border p-5 w-44 sm:w-56 min-w-0 transition border-yellow-300 bg-yellow-50 shadow-lg shadow-yellow-200/50";
                                if (badge) {
                                    badge.textContent = "Lucky";
                                    badge.className = "mt-2 rounded-full px-3 py-1 text-xs font-bold bg-yellow-500 text-white shadow-sm";
                                    badge.classList.remove('hidden');
                                }
                            } else {
                                // Other Bottom Queen - Bottom Two Look
                                if (badge) {
                                    badge.textContent = "Lipsync";
                                    badge.className = "mt-2 rounded-full px-3 py-1 text-xs font-bold bg-red-600 text-white shadow-sm";
                                    badge.classList.remove('hidden');
                                }
                            }
                        });

                        // Show Message (14px, No Animation)
                        const msg = document.getElementById('lipMessage');
                        if (msg) {
                            msg.innerHTML = `<div class="text-sm font-medium text-gray-500 mb-1">${savedName} pulls out the Lucky Queen Figurine! She is safe!</div>
                            <div class="text-sm font-medium text-gray-500">${repName}, you are taking her place in the bottom two!</div>`;
                            msg.className = "mt-6 text-center"; 
                            msg.classList.remove('hidden');
                        }

                        // Update Button
                        btn.innerHTML = "Let the music play!";
                        btn.onclick = () => {
                            ep.twistRevealed = true;
                            renderScenario();
                        };
                    };
                } else {
                    btn.innerHTML = "Results";
                    btn.onclick = revealEliminationResults;
                }
            }
        }
        else if ((scenarioPhase === 7 && !(ep.untucked && ep.untucked.length > 0)) || (scenarioPhase === 8 && (ep.untucked && ep.untucked.length > 0))) {
            renderTrackRecordTable(ep.episode);
            stage.innerHTML = `
                <div class="text-center">
                    <h2 class="text-xl font-bold mb-4">Episode ${ep.episode} Complete</h2>
                    <p class="text-gray-500 text-sm">Review the track record below.</p>
                </div>
            `;
            if (trackDiv) {
                trackDiv.classList.remove('hidden');
                stage.appendChild(trackDiv);
            }
            
            debug.innerText = "Summary";
            btn.innerHTML = "Start Next Episode →";
        }
    }

    function returnTournamentQueen(queenName) {
        if (!seasonData || !seasonData.tournamentState) return;
        if (currentEpIndex >= seasonData.episodes.length) return;

        const ep = seasonData.episodes[currentEpIndex];
        if (!ep || !ep.isTournament || ep.tournamentStage !== 'Semi-Finals' || !ep.needsReturnPick) return;

        const ts = seasonData.tournamentState;
        if (!Array.isArray(ts.eliminatedPool) || !ts.eliminatedPool.includes(queenName)) return;
        if (!Array.isArray(ts.currentCast)) return;

        const resolveTournamentChallenge = (name) => {
            if (challengeConfig && challengeConfig[name]) return name;
            const lower = String(name || '').toLowerCase();
            const keys = Array.isArray(ts.challengeKeys) ? ts.challengeKeys : Object.keys(challengeConfig || {});
            const found = keys.find(k => String(k).toLowerCase() === lower);
            return found || name;
        };
        const challenge = resolveTournamentChallenge(ep.challenge);
        const epNumber = ep.episode;
        const castWithReturn = [...ts.currentCast, queenName];
        const out = simulateTournamentRegularElimEpisode(castWithReturn, challenge, epNumber, ts.stats, ts.recentWins, seasonData.relationships, ts.relationshipTension);
        const epData = out.epData;
        epData.isTournament = true;
        epData.tournamentStage = 'Semi-Finals';
        epData.displayChallenge = ep.displayChallenge || `Semi-Finals — ${challenge}`;
        epData.returnedQueen = queenName;

        seasonData.episodes[currentEpIndex] = epData;
        ts.currentCast = out.updatedCast;
        ts.eliminatedPool = ts.eliminatedPool.filter(n => n !== queenName);

        if (!ts.postReturnGenerated) {
            const pickRandomUnusedChallenge = () => {
                const used = ts.usedChallenges instanceof Set ? ts.usedChallenges : new Set();
                const keys = Array.isArray(ts.challengeKeys) ? ts.challengeKeys : [];
                const pool = keys.filter(k => !used.has(k));
                const pickFrom = pool.length ? pool : keys;
                if (!pickFrom.length) return 'Challenge';
                return pickFrom[Math.floor(Math.random() * pickFrom.length)];
            };

            const semi2Challenge = resolveTournamentChallenge('Ball');
            if (ts.usedChallenges instanceof Set) ts.usedChallenges.add(semi2Challenge);
            const semi2EpNumber = ts.nextEpNumber || (epNumber + 1);
            const out2 = simulateTournamentRegularElimEpisode(ts.currentCast, semi2Challenge, semi2EpNumber, ts.stats, ts.recentWins, seasonData.relationships, ts.relationshipTension);
            const semi2Ep = out2.epData;
            semi2Ep.isTournament = true;
            semi2Ep.tournamentStage = 'Semi-Finals';
            semi2Ep.displayChallenge = `Semi-Finals — ${semi2Challenge}`;
            seasonData.episodes.push(semi2Ep);
            ts.currentCast = out2.updatedCast;

            const finaleEpNumber = semi2EpNumber + 1;
            const shuffle = (arr) => [...arr].map(x => ({ x, r: Math.random() })).sort((a, b) => a.r - b.r).map(o => o.x);
            const runLalaparuzaRound = (participants) => {
                const p = shuffle(participants);
                const matches = [];
                const winners = [];
                const losers = [];
                for (let i = 0; i < p.length; i += 2) {
                    const a = p[i];
                    const b = p[i + 1];
                    if (!b) {
                        winners.push(a);
                        continue;
                    }
                    const sa = calcLipSyncScore(a, 'lalaparuza', ts.stats);
                    const sb = calcLipSyncScore(b, 'lalaparuza', ts.stats);
                    const aWins = sa.score >= sb.score;
                    const winner = aWins ? a : b;
                    const loser = aWins ? b : a;
                    const song = (window.pickRandomLipSyncSong && typeof window.pickRandomLipSyncSong === 'function')
                        ? window.pickRandomLipSyncSong()
                        : '';
                    winners.push(winner);
                    losers.push(loser);
                    matches.push({
                        a, b,
                        scoreA: sa.score, breakdownA: sa.breakdown,
                        scoreB: sb.score, breakdownB: sb.breakdown,
                        winner, loser,
                        song
                    });
                }
                return { winners, losers, matches };
            };

            const finaleCast = [...ts.currentCast].slice(0, 8);
            const r1 = runLalaparuzaRound(finaleCast);
            const r2 = runLalaparuzaRound(r1.winners);
            const finalLipSyncQueens = [...r2.winners].slice(0, 2);
            const finalLipSyncScores = finalLipSyncQueens.map(q => calcLipSyncScore(q, 'finale', ts.stats));

            const scoreA = finalLipSyncScores.find(s => s.name === finalLipSyncQueens[0])?.score ?? 0;
            const scoreB = finalLipSyncScores.find(s => s.name === finalLipSyncQueens[1])?.score ?? 0;
            
            const ppeA = ts.stats[finalLipSyncQueens[0]] ? ts.stats[finalLipSyncQueens[0]].ppe : 0;
            const ppeB = ts.stats[finalLipSyncQueens[1]] ? ts.stats[finalLipSyncQueens[1]].ppe : 0;
            let winnerName = ppeA >= ppeB ? finalLipSyncQueens[0] : finalLipSyncQueens[1];
            const lost3 = finalLipSyncQueens.find(n => n !== winnerName) || null;
            const runnerUps = lost3 ? [lost3] : [];
            const lostRound2 = [...r2.losers];
            const lostRound1 = [...r1.losers];
            const eliminatedInFinale = [...lostRound2, ...lostRound1];

            seasonData.episodes.push({
                episode: finaleEpNumber,
                challenge: "Grand Finale — Lip Sync LalapaRuza Smackdown",
                lipSyncSong: (window.pickRandomLipSyncSong && typeof window.pickRandomLipSyncSong === 'function') ? window.pickRandomLipSyncSong() : '',
                displayChallenge: "Grand Finale — Lip Sync LalapaRuza Smackdown",
                scores: [],
                winners: [{ name: winnerName, total: 100 }],
                top2: [],
                high: [],
                safe: [],
                low: [],
                bottom: [],
                remainingCount: finaleCast.length,
                isAllStars: true,
                isFinale: true,
                isTournament: true,
                isTournamentFinale: true,
                finalists: finalLipSyncQueens,
                finaleCast,
                lalaparuzaRound1: r1.matches,
                lalaparuzaRound2: r2.matches,
                finalLipSyncQueens,
                finalLipSyncScores: [...finalLipSyncScores].sort((a, b) => b.score - a.score),
                runnerUps,
                winner: winnerName,
                eliminatedInFinale,
                lostRound1,
                lostRound2,
                lostRound3: lost3 ? [lost3] : []
            });

            seasonData.finale = finaleCast;
            seasonData.winner = winnerName;
            ts.nextEpNumber = finaleEpNumber + 1;
            ts.postReturnGenerated = true;
        }

        renderScenario();
    }

    function returnAllStarsQueen(queenName) {
        if (!seasonData || !seasonData.returnState) return;
        const state = seasonData.returnState;
        const placeholderIndex = seasonData.episodes.findIndex(e => e && e.needsReturnPick);
        if (placeholderIndex < 0) return;
        const placeholder = seasonData.episodes[placeholderIndex];
        if (!placeholder) return;

        const episodes = seasonData.episodes.slice(0, placeholderIndex);
        const stats = state.stats;
        const relationships = state.relationships || {};
        const relationshipTension = state.relationshipTension || {};
        const recentWins = state.recentWins || {};
        const challengeUsedCount = state.challengeUsedCount || {};
        const opener = state.opener || 'Random';
        const finaleLimit = state.finaleLimit;
        const finaleFormat = state.finaleFormat;
        const MAX_DOUBLE_WINS = 3;
        let doubleWinCount = state.doubleWinCount || 0;

        let currentCast = [...state.currentCast];
        if (queenName && !currentCast.includes(queenName)) currentCast.push(queenName);

        let epNum = placeholder.episode;
        const chal = placeholder.challenge;
        const hasRunway = placeholder.hasRunway !== undefined ? placeholder.hasRunway : hasRunwayForChallenge(chal);

        const scores = currentCast.map(q => {
            const queen = queensDb[q];
            const challengeStats = challengeConfig[chal];
            const base = challengeStats.reduce((acc, s) => acc + queen[s], 0) / challengeStats.length;
            const challengeTotal = base;

            const randomForChallenge = Math.random() * 5 - 2.5;
            const randomForRunway = hasRunway ? (Math.random() * 5 - 2.5) : 0;
            const randomTotal = 0;

            const challengeWithRandom = challengeTotal + randomForChallenge;

            let desc = "Safe", statusClass = "perf-safe";
            if (challengeWithRandom > 12) { desc = "SLAYED!"; statusClass = "perf-slay"; }
            else if (challengeWithRandom > 8) { desc = "Great job"; statusClass = "perf-good"; }
            else if (challengeWithRandom > 6) { desc = "Okay"; statusClass = "perf-safe"; }
            else if (challengeWithRandom > 4) { desc = "Struggled"; statusClass = "perf-bad"; }
            else { desc = "FLOP"; statusClass = "perf-flop"; }

            let runwayTotal = 0;
            let runwayDesc = "";
            let runwayStatusClass = "";
            let runwayWithRandom = 0;

            if (hasRunway) {
                const fashionBase = queen.fashion;
                runwayTotal = fashionBase;
                runwayWithRandom = runwayTotal + randomForRunway;
                
                if (runwayWithRandom > 12) { runwayDesc = "SLAYED!"; runwayStatusClass = "perf-slay"; }
                else if (runwayWithRandom > 8) { runwayDesc = "Great job"; runwayStatusClass = "perf-good"; }
                else if (runwayWithRandom > 6) { runwayDesc = "Okay"; runwayStatusClass = "perf-safe"; }
                else if (runwayWithRandom > 4) { runwayDesc = "Struggled"; runwayStatusClass = "perf-bad"; }
                else { runwayDesc = "FLOP"; runwayStatusClass = "perf-flop"; }
            }

            const challengeWeighted = hasRunway ? challengeWithRandom * 0.8 : challengeWithRandom;
            const runwayWeighted = hasRunway ? runwayWithRandom * 0.2 : 0;
            const totalBase = challengeWeighted + runwayWeighted;

            const lastPlacement = stats && stats[q] ? stats[q].lastPlacement : null;
            let winModifier = 0;
            {
                const consWins = (stats && stats[q]) ? (stats[q].consecutiveWins || 0) : 0;
                const consHighs = (stats && stats[q]) ? (stats[q].consecutiveHighs || 0) : 0;
                if (consWins > 0) {
                    winModifier = -1.25 - ((consWins - 1) * 0.5);
                } else if (consHighs > 0) {
                    winModifier = -0.5 - ((consHighs - 1) * 0.25);
                }
            }
            const total = totalBase + randomTotal + winModifier;
            return { 
                name: q, 
                total, 
                totalBase,
                challengeTotal: challengeWithRandom, 
                runwayTotal: runwayWithRandom, 
                challengeWeighted,
                runwayWeighted,
                randomTotal,
                winModifier,
                desc, 
                statusClass, 
                runwayDesc, 
                runwayStatusClass, 
                details: `(${challengeWithRandom.toFixed(1)})`,
                runwayDetails: hasRunway ? `(${runwayWithRandom.toFixed(1)})` : '' 
            };
        }).sort((a, b) => b.total - a.total);

        const top2 = scores.slice(0, Math.min(2, scores.length)).map(t => ({
            ...t,
            score: (typeof t.score === 'number' && isFinite(t.score)) ? t.score : t.total
        }));
        const top2Names = new Set(top2.map(t => t.name));
        const nonTop2 = scores.filter(s => !top2Names.has(s.name));
        const bottomCount = currentCast.length <= 5 ? 2 : (Math.random() < 0.25 && scores.length >= 5 ? 3 : 2);
        const bottom = nonTop2.slice(-bottomCount);

        const others = scores.filter(s => !top2.find(w => w.name === s.name) && !bottom.find(b => b.name === s.name));
        const high = others.slice(0, 2);
        const low = others.length > 2 ? [others[others.length - 1]] : [];
        const safe = others.filter(s => !high.find(h => h.name === s.name) && !low.find(l => l.name === s.name));
        const highTeam = [];

        const untucked = generateUntucked(top2, bottom, high, safe, low, stats, relationships, relationshipTension);
        const lipstickChoices = chooseLipsticks(top2, bottom, stats, relationships, untucked.influences);

        const ls1 = calcLipSyncScore(top2[0]?.name, 'allstars_top2', stats);
        const ls2 = calcLipSyncScore(top2[1]?.name, 'allstars_top2', stats);
        const lipSyncTop2 = [ls1, ls2];

        let isDoubleWin = false;
        let lipSyncWinner = null;
        let eliminated = [];
        let loserTop2 = null;
        let sameLipstick = false;

        let elimReasons = null;
        lipSyncWinner = ls1.score >= ls2.score ? top2[0].name : top2[1].name;
        const chosen = lipstickChoices[lipSyncWinner];
        eliminated = chosen ? [chosen] : [];
        loserTop2 = top2.find(w => w.name !== lipSyncWinner).name;
        sameLipstick = loserTop2 && chosen ? (lipstickChoices[loserTop2] === chosen) : false;
        if (chosen) {
            const personality = getPersonalityForQueen(lipSyncWinner);
            const winReason = getAllStarsElimReason(lipSyncWinner, chosen, personality, stats, relationships);
            elimReasons = {};
            elimReasons[chosen] = winReason;
        }

        eliminated.forEach(eName => {
            currentCast = currentCast.filter(q => q !== eName);
        });

        scores.forEach(s => {
            const name = s.name;
            const st = stats[name];
            const isTop2 = top2.some(w => w.name === name);
            let points = 0;
            let placement = null;
            if (isTop2) {
                if (isDoubleWin) { st.wins++; points = 5; placement = 'WIN'; }
                else if (name === lipSyncWinner) { st.wins++; points = 5; placement = 'WIN'; }
                else { st.wins++; points = GAME_CONSTANTS.POINTS.ALLSTARS_LIPSYNC_LOSER; placement = 'HIGH'; }
            }
            else if (high.find(h => h.name === name)) { st.highs++; points = 4; placement = 'HIGH'; }
            else if (safe.find(x => x.name === name)) { st.safe++; points = 3; placement = 'SAFE'; }
            else if (low.find(l => l.name === name)) { st.lows++; points = 2; placement = 'LOW'; }
            else if (bottom.find(b => b.name === name)) { 
                st.bottoms++; 
                points = eliminated.includes(name) ? 0 : 1; 
                placement = eliminated.includes(name) ? 'ELIM' : 'BTM';
            }
            st.totalPoints += points;
            st.episodesCount++;
            st.ppe = st.totalPoints / st.episodesCount;
            if (placement === 'WIN' || isTop2) {
                st.consecutiveWins = (st.consecutiveWins || 0) + 1;
                st.consecutiveHighs = 0;
            } else if (placement === 'HIGH') {
                st.consecutiveHighs = (st.consecutiveHighs || 0) + 1;
                st.consecutiveWins = 0;
            } else {
                st.consecutiveWins = 0;
                st.consecutiveHighs = 0;
            }
            st.lastPlacement = placement;
        });

        episodes.push({
            episode: epNum,
            challenge: chal,
            scores,
            winners: top2,
            high, safe, low,
            bottom,
            top2,
            lipSyncTop2,
            lipstickChoices,
            lipSyncWinner: isDoubleWin ? "DOUBLE WIN" : lipSyncWinner,
            lipSyncLoser: loserTop2,
            eliminated: eliminated.length === 1 ? eliminated[0] : eliminated,
            elimReasons: elimReasons,
            untucked: untucked.scenes,
            revealLoserLipstick: !isDoubleWin && !sameLipstick && !!(loserTop2 && lipstickChoices[loserTop2]),
            loserLipstick: (!isDoubleWin && loserTop2) ? (lipstickChoices[loserTop2] || null) : null,
            sameLipstick,
            remainingCount: currentCast.length,
            isAllStars: true,
            isFinale: false,
            isDoubleWin,
            isPremiere: false,
            returnedQueen: queenName
        });

        if (eliminated.length) {
            const keyElim = getRelationshipKey(lipSyncWinner, eliminated);
            if (!relationshipTension[keyElim]) relationshipTension[keyElim] = 0;
            relationshipTension[keyElim] = Math.min(1, relationshipTension[keyElim] + 0.25);
        }
        epNum++;

        while (currentCast.length > finaleLimit) {
            const isPremiereEpisode = false;
            const isLastCompetitiveEp = currentCast.length === finaleLimit + 1;
            const chal = pickChallengeForEpisode(epNum, challengeUsedCount, opener, isLastCompetitiveEp, finaleLimit, state.castAtStart.length);
            const hasRunway = hasRunwayForChallenge(chal);
            const scores = currentCast.map(q => {
                const queen = queensDb[q];
                const challengeStats = challengeConfig[chal];
                const base = challengeStats.reduce((acc, s) => acc + queen[s], 0) / challengeStats.length;
                const challengeTotal = base;

                const randomForChallenge = Math.random() * 5 - 2.5;
                const randomForRunway = hasRunway ? (Math.random() * 5 - 2.5) : 0;
                const randomTotal = 0;

                const challengeWithRandom = challengeTotal + randomForChallenge;

                let desc = "Safe", statusClass = "perf-safe";
                if (challengeWithRandom > 12) { desc = "SLAYED!"; statusClass = "perf-slay"; }
                else if (challengeWithRandom > 8) { desc = "Great job"; statusClass = "perf-good"; }
                else if (challengeWithRandom > 6) { desc = "Okay"; statusClass = "perf-safe"; }
                else if (challengeWithRandom > 4) { desc = "Struggled"; statusClass = "perf-bad"; }
                else { desc = "FLOP"; statusClass = "perf-flop"; }

                let runwayTotal = 0;
                let runwayDesc = "";
                let runwayStatusClass = "";
                let runwayWithRandom = 0;
                let runwayDetails = "";
                if (hasRunway) {
                    const fashionBase = queen.fashion;
                    runwayTotal = fashionBase;
                    runwayWithRandom = runwayTotal + randomForRunway;

                    if (runwayWithRandom > 12) { runwayDesc = "SLAYED!"; runwayStatusClass = "perf-slay"; }
                    else if (runwayWithRandom > 8) { runwayDesc = "Great job"; runwayStatusClass = "perf-good"; }
                    else if (runwayWithRandom > 6) { runwayDesc = "Okay"; runwayStatusClass = "perf-safe"; }
                    else if (runwayWithRandom > 4) { runwayDesc = "Struggled"; runwayStatusClass = "perf-bad"; }
                    else { runwayDesc = "FLOP"; runwayStatusClass = "perf-flop"; }
                    runwayDetails = `(${runwayWithRandom.toFixed(1)})`;
                }

                const challengeWeighted = hasRunway ? challengeWithRandom * 0.8 : challengeWithRandom;
                const runwayWeighted = hasRunway ? runwayWithRandom * 0.2 : 0;
                const totalBase = challengeWeighted + runwayWeighted;

                const lastPlacement = stats && stats[q] ? stats[q].lastPlacement : null;
                let winModifier = 0;
                {
                    const consWins = (stats && stats[q]) ? (stats[q].consecutiveWins || 0) : 0;
                    const consHighs = (stats && stats[q]) ? (stats[q].consecutiveHighs || 0) : 0;
                    if (consWins > 0) {
                        winModifier = -1.25 - ((consWins - 1) * 0.5);
                    } else if (consHighs > 0) {
                        winModifier = -0.5 - ((consHighs - 1) * 0.25);
                    }
                }
                const total = totalBase + randomTotal + winModifier;
                return { 
                    name: q, 
                    total, 
                    totalBase,
                    challengeTotal: challengeWithRandom, 
                    runwayTotal: runwayWithRandom, 
                    challengeWeighted,
                    runwayWeighted,
                    randomTotal,
                    winModifier,
                    desc, 
                    statusClass, 
                    runwayDesc, 
                    runwayStatusClass, 
                    details: `(${challengeWithRandom.toFixed(1)})`,
                runwayDetails: hasRunway ? `(${runwayWithRandom.toFixed(1)})` : '' 
                };
            }).sort((a, b) => b.total - a.total);

            const top2 = scores.slice(0, Math.min(2, scores.length)).map(t => ({
                ...t,
                score: (typeof t.score === 'number' && isFinite(t.score)) ? t.score : t.total
            }));
            const top2Names = new Set(top2.map(t => t.name));
            const nonTop2 = scores.filter(s => !top2Names.has(s.name));
            const bottomCount = currentCast.length <= 5 ? 2 : (Math.random() < 0.25 && scores.length >= 5 ? 3 : 2);
            const bottom = nonTop2.slice(-bottomCount);

            const others = scores.filter(s => !top2.find(w => w.name === s.name) && !bottom.find(b => b.name === s.name));
            const high = others.slice(0, 2);
            const low = others.length > 2 ? [others[others.length - 1]] : [];
            const safe = others.filter(s => !high.find(h => h.name === s.name) && !low.find(l => l.name === s.name));

            const untucked = generateUntucked(top2, bottom, high, safe, low, stats, relationships, relationshipTension);
            const lipstickChoices = isPremiereEpisode ? {} : chooseLipsticks(top2, bottom, stats, relationships, untucked.influences);

            const ls1 = calcLipSyncScore(top2[0]?.name, 'allstars_top2', stats);
            const ls2 = calcLipSyncScore(top2[1]?.name, 'allstars_top2', stats);
            const lipSyncTop2 = [ls1, ls2];

            let isDoubleWin = !isPremiereEpisode && Math.abs(ls1.score - ls2.score) < 0.5 && Math.random() < 0.08 && doubleWinCount < MAX_DOUBLE_WINS;
            let lipSyncWinner = null;
            let eliminated = [];
            let loserTop2 = null;
            let sameLipstick = false;
            if (isDoubleWin) doubleWinCount++;

            let elimReasons = null;
            if (isPremiereEpisode) {
                lipSyncWinner = ls1.score >= ls2.score ? top2[0].name : top2[1].name;
                loserTop2 = top2.find(w => w.name !== lipSyncWinner).name;
                eliminated = [];
            } else if (isDoubleWin) {
                const choice1 = lipstickChoices[top2[0].name];
                const choice2 = lipstickChoices[top2[1].name];
                if (choice1 === choice2) {
                    eliminated = [choice1];
                    sameLipstick = true;
                } else {
                    eliminated = [choice1, choice2];
                    sameLipstick = false;
                }
                elimReasons = {};
                if (choice1) {
                    const personality1 = getPersonalityForQueen(top2[0].name);
                    const reason1 = getAllStarsElimReason(top2[0].name, choice1, personality1, stats, relationships);
                    if (sameLipstick && choice2) {
                        const personality2 = getPersonalityForQueen(top2[1].name);
                        const reason2 = getAllStarsElimReason(top2[1].name, choice2, personality2, stats, relationships);
                        elimReasons[choice1] = [reason1, reason2];
                    } else {
                        elimReasons[choice1] = reason1;
                    }
                }
                if (choice2 && choice2 !== choice1) {
                    const personality2 = getPersonalityForQueen(top2[1].name);
                    elimReasons[choice2] = getAllStarsElimReason(top2[1].name, choice2, personality2, stats, relationships);
                }
            } else {
                lipSyncWinner = ls1.score >= ls2.score ? top2[0].name : top2[1].name;
                const chosen = lipstickChoices[lipSyncWinner];
                eliminated = chosen ? [chosen] : [];
                loserTop2 = top2.find(w => w.name !== lipSyncWinner).name;
                sameLipstick = loserTop2 && chosen ? (lipstickChoices[loserTop2] === chosen) : false;
                if (chosen) {
                    const personality = getPersonalityForQueen(lipSyncWinner);
                    const winReason = getAllStarsElimReason(lipSyncWinner, chosen, personality, stats, relationships);
                    elimReasons = {};
                    elimReasons[chosen] = winReason;
                }
            }

            if (!isPremiereEpisode) {
                eliminated.forEach(eName => {
                    currentCast = currentCast.filter(q => q !== eName);
                });
            }

            scores.forEach(s => {
                const name = s.name;
                const st = stats[name];
                let points = 0;
                let placement = null;
                if (top2.find(w => w.name === name)) {
                    if (isDoubleWin) { st.wins++; points = 5; placement = 'WIN'; }
                    else if (name === lipSyncWinner) { st.wins++; points = 5; placement = 'WIN'; }
                    else { points = GAME_CONSTANTS.POINTS.ALLSTARS_LIPSYNC_LOSER; placement = 'HIGH'; }
                }
                else if (high.find(h => h.name === name)) { st.highs++; points = 4; placement = 'HIGH'; }
                else if (safe.find(x => x.name === name)) { st.safe++; points = 3; placement = 'SAFE'; }
                else if (low.find(l => l.name === name)) { st.lows++; points = 2; placement = 'LOW'; }
                else if (bottom.find(b => b.name === name)) { 
                    st.bottoms++; 
                    points = eliminated.includes(name) ? 0 : 1; 
                    placement = eliminated.includes(name) ? 'ELIM' : 'BTM';
                }
                st.totalPoints += points;
                st.episodesCount++;
                st.ppe = st.totalPoints / st.episodesCount;
                st.lastPlacement = placement;
            });

            episodes.push({
                episode: epNum,
                challenge: chal,
                scores,
                winners: top2,
                high, safe, low,
                bottom,
                top2,
                lipSyncTop2,
                lipstickChoices,
                lipSyncWinner: isDoubleWin ? "DOUBLE WIN" : lipSyncWinner,
                lipSyncLoser: loserTop2,
                eliminated: eliminated.length === 1 ? eliminated[0] : eliminated,
                elimReasons: elimReasons,
                untucked: untucked.scenes,
                revealLoserLipstick: !isPremiereEpisode && !isDoubleWin && !sameLipstick && !!(loserTop2 && lipstickChoices[loserTop2]),
                loserLipstick: (!isPremiereEpisode && !isDoubleWin && loserTop2) ? (lipstickChoices[loserTop2] || null) : null,
                sameLipstick,
                remainingCount: currentCast.length,
                isAllStars: true,
                isFinale: false,
                isDoubleWin,
                isPremiere: isPremiereEpisode
            });

            if (!isPremiereEpisode && eliminated.length) {
                const keyElim = getRelationshipKey(lipSyncWinner, eliminated);
                if (!relationshipTension[keyElim]) relationshipTension[keyElim] = 0;
                relationshipTension[keyElim] = Math.min(1, relationshipTension[keyElim] + 0.25);
            }
            epNum++;
        }

        const sortedByPPE = [...currentCast].sort((a, b) => stats[b].ppe - stats[a].ppe);
        const withWins = sortedByPPE.filter(q => stats[q].wins > 0);
        let winnerName = withWins.length > 0 ? withWins[0] : sortedByPPE[0];
        let finaleEpisodePayload;

        if (finaleLimit === 4 && finaleFormat === 'crown') {
            const shuffled = [...currentCast].map(x => ({ x, r: Math.random() })).sort((a, b) => a.r - b.r).map(o => o.x);
            const pair1 = [shuffled[0], shuffled[1]];
            const pair2 = [shuffled[2], shuffled[3]];
            const runMatch = (a, b) => {
                const sa = calcLipSyncScore(a, 'lalaparuza', stats);
                const sb = calcLipSyncScore(b, 'lalaparuza', stats);
                const aWins = sa.score >= sb.score;
                const winner = aWins ? a : b;
                const loser = aWins ? b : a;
                const song = (window.pickRandomLipSyncSong && typeof window.pickRandomLipSyncSong === 'function')
                    ? window.pickRandomLipSyncSong()
                    : '';
                return {
                    a, b,
                    scoreA: sa.score, breakdownA: sa.breakdown,
                    scoreB: sb.score, breakdownB: sb.breakdown,
                    winner, loser,
                    song
                };
            };
            const m1 = runMatch(pair1[0], pair1[1]);
            const m2 = runMatch(pair2[0], pair2[1]);
            const finalLipSyncQueens = [m1.winner, m2.winner];
            const finalScores = finalLipSyncQueens.map(q => calcLipSyncScore(q, 'finale', stats));
            const finalSorted = [...finalScores].sort((a, b) => b.score - a.score);
            if (finalSorted.length > 0) {
                const topScoreDiff = finalSorted.length > 1 ? Math.abs(finalSorted[0].score - finalSorted[1].score) : 0;
                
                // --- MODIFIED LOGIC: Always prefer PPE ---
                // Only use lip sync score if PPE is extremely close (or same)
                
                const q1 = finalSorted[0].name;
                const q2 = finalSorted[1] ? finalSorted[1].name : null;
                
                if (q2) {
                    const ppe1 = stats[q1] ? stats[q1].ppe : 0;
                    const ppe2 = stats[q2] ? stats[q2].ppe : 0;
                    
                    if (ppe1 > ppe2) winnerName = q1;
                    else if (ppe2 > ppe1) winnerName = q2;
                    else winnerName = finalSorted[0].name; // PPE tie -> lip sync score
                } else {
                    winnerName = q1;
                }
            }
            const lostRound1 = [m1.loser].filter(Boolean);
            const lostRound2 = [m2.loser].filter(Boolean);
            const lostRound3 = finalLipSyncQueens.filter(q => q !== winnerName);
            const runnerUps = finalLipSyncQueens.filter(q => q !== winnerName);
            const eliminatedInFinale = [...lostRound2, ...lostRound1];
            finaleEpisodePayload = {
                episode: epNum,
                challenge: "Grand Finale — Lip Sync For The Crown",
                scores: [],
                winners: [{ name: winnerName, total: 100 }],
                top2: [],
                bottom: [],
                remainingCount: currentCast.length,
                isAllStars: true,
                isFinale: true,
                isCrownFinale: true,
                finalists: currentCast,
                crownRound1: [m1],
                crownRound2: [m2],
                finalLipSyncQueens,
                finalLipSyncScores: finalSorted,
                eliminatedInFinale,
                lostRound1,
                lostRound2,
                lostRound3,
                runnerUps,
                winner: winnerName
            };
        } else if (finaleLimit >= 3) {
            const finalePerformanceScores = currentCast.map(q => {
                const queen = queensDb[q];
                const performanceScore = queen.performance;
                const lipsyncScore = queen.lipsync;
                const luck = Math.random() * 7;
                const total = (performanceScore + lipsyncScore) / 2 + luck;
                return {
                    name: q,
                    total: total,
                    performanceScore: performanceScore,
                    lipsyncScore: lipsyncScore,
                    luck: luck,
                    passed: total >= 8
                };
            }).sort((a, b) => b.total - a.total);

            let finalLipSyncQueens = [];
            if (finaleLimit === 3) {
                const eligibleQueens = sortedByPPE.filter(q => {
                    const perfScore = finalePerformanceScores.find(s => s.name === q);
                    return perfScore && perfScore.passed && stats[q].wins > 0;
                });
                if (eligibleQueens.length === 0) {
                    finalLipSyncQueens = sortedByPPE.slice(0, 2).filter(q => stats[q].wins > 0);
                } else if (eligibleQueens.length >= 3) {
                    const diff = stats[eligibleQueens[1]].ppe - stats[eligibleQueens[2]].ppe;
                    finalLipSyncQueens = diff <= 0.1 ? eligibleQueens.slice(0, 3) : eligibleQueens.slice(0, 2);
                } else {
                    finalLipSyncQueens = eligibleQueens.length >= 2 ? eligibleQueens : sortedByPPE.slice(0, 2).filter(q => stats[q].wins > 0);
                }
            } else if (finaleLimit === 4) {
                const eligibleQueens = sortedByPPE.filter(q => {
                    const perfScore = finalePerformanceScores.find(s => s.name === q);
                    return perfScore && perfScore.passed && stats[q].wins > 0;
                });
                if (eligibleQueens.length === 0) {
                    finalLipSyncQueens = sortedByPPE.slice(0, 2).filter(q => stats[q].wins > 0);
                } else if (eligibleQueens.length >= 4) {
                    const diff34 = stats[eligibleQueens[2]].ppe - stats[eligibleQueens[3]].ppe;
                    if (diff34 <= 0.1) {
                        finalLipSyncQueens = eligibleQueens.slice(0, 4);
                    } else {
                        const diff23 = stats[eligibleQueens[1]].ppe - stats[eligibleQueens[2]].ppe;
                        finalLipSyncQueens = diff23 <= 0.3 ? eligibleQueens.slice(0, 3) : eligibleQueens.slice(0, 2);
                    }
                } else {
                    finalLipSyncQueens = eligibleQueens.length >= 2 ? eligibleQueens : sortedByPPE.slice(0, 2).filter(q => stats[q].wins > 0);
                }
            }
            if (finalLipSyncQueens.length < 2) {
                const withWins = sortedByPPE.filter(q => stats[q].wins > 0).slice(0, 2);
                finalLipSyncQueens = withWins.length >= 2 ? withWins : sortedByPPE.slice(0, 2);
            }

            const finalLipSyncScores = finalLipSyncQueens.map(q => calcLipSyncScore(q, 'finale', stats)).sort((a, b) => b.score - a.score);

            const eliminatedInFinale = currentCast.filter(q => !finalLipSyncQueens.includes(q));
            const runnerUps = finalLipSyncQueens.filter(q => q !== winnerName);

            finaleEpisodePayload = {
                episode: epNum,
                challenge: "Grand Finale Performance",
                scores: finalePerformanceScores,
                winners: [{ name: winnerName, total: 100 }],
                top2: [],
                bottom: [],
                remainingCount: currentCast.length,
                isAllStars: true,
                isFinale: true,
                finalists: finalLipSyncQueens,
                finalePerformanceScores: finalePerformanceScores,
                finalLipSyncQueens: finalLipSyncQueens,
                finalLipSyncScores: finalLipSyncScores,
                eliminatedInFinale: eliminatedInFinale,
                runnerUps: runnerUps,
                winner: winnerName
            };
        } else {
            finaleEpisodePayload = {
                episode: epNum,
                challenge: "Grand Finale",
                scores: [],
                winners: [{ name: winnerName, total: 100 }],
                top2: [],
                bottom: [],
                remainingCount: currentCast.length,
                isAllStars: true,
                isFinale: true,
                finalists: currentCast,
                winner: winnerName,
                runnerUps: currentCast.filter(q => q !== winnerName)
            };
        }

        episodes.push(finaleEpisodePayload);

        seasonData = {
            episodes,
            finale: currentCast,
            winner: winnerName,
            queenStats: stats,
            castQueens: state.castAtStart,
            relationships,
            isAllStars: true,
            finaleLimit: finaleLimit
        };
        seasonData.returnState = null;
        currentEpIndex = placeholderIndex;
        scenarioPhase = 1;
        renderScenario();
    }

    function returnRegularQueen(queenName) {
        if (!seasonData || !seasonData.returnState) return;
        const state = seasonData.returnState;
        const placeholderIndex = seasonData.episodes.findIndex(e => e && e.needsReturnPick);
        if (placeholderIndex < 0) return;
        const placeholder = seasonData.episodes[placeholderIndex];
        if (!placeholder) return;

        const episodes = seasonData.episodes.slice(0, placeholderIndex);
        const stats = state.stats;
        const relationships = state.relationships || {};
        const relationshipTension = state.relationshipTension;
        const recentWins = state.recentWins || {};
        const challengeUsedCount = state.challengeUsedCount || {};
        const opener = state.opener || 'Random';
        const finaleLimit = state.finaleLimit;
        const finaleFormat = state.finaleFormat;
        const isBeaverFormat = state.isBeaverFormat;
        let doubleShantayUsed = !!state.doubleShantayUsed;
        let luckyQueenSave = null;

        let currentCast = [...state.currentCast];
        if (queenName && !currentCast.includes(queenName)) currentCast.push(queenName);

        let epNum = placeholder.episode;
        const chal = placeholder.challenge;
        const hasRunway = placeholder.hasRunway !== undefined ? placeholder.hasRunway : hasRunwayForChallenge(chal);

        const scores = currentCast.map(q => {
            const queen = queensDb[q];
            const challengeStats = challengeConfig[chal];
            const base = challengeStats.reduce((acc, s) => acc + queen[s], 0) / challengeStats.length;
            const challengeTotal = base;

            const randomForChallenge = Math.random() * 5 - 2.5;
            const randomForRunway = hasRunway ? (Math.random() * 5 - 2.5) : 0;
            const randomTotal = 0;

            const challengeWithRandom = challengeTotal + randomForChallenge;

            let desc = "Safe";
            let statusClass = "perf-safe";
            if (challengeWithRandom > 12) { desc = "SLAYED!"; statusClass = "perf-slay"; }
            else if (challengeWithRandom > 8) { desc = "Great job"; statusClass = "perf-good"; }
            else if (challengeWithRandom > 6) { desc = "Okay"; statusClass = "perf-safe"; }
            else if (challengeWithRandom > 4) { desc = "Struggled"; statusClass = "perf-bad"; }
            else { desc = "FLOP"; statusClass = "perf-flop"; }

            let runwayTotal = 0;
            let runwayDesc = "";
            let runwayStatusClass = "";
            let runwayWithRandom = 0;
            
            if (hasRunway) {
                const fashionBase = queen.fashion;
                runwayTotal = fashionBase;
                runwayWithRandom = runwayTotal + randomForRunway;
                
                if (runwayWithRandom > 12) { runwayDesc = "SLAYED!"; runwayStatusClass = "perf-slay"; }
                else if (runwayWithRandom > 8) { runwayDesc = "Great job"; runwayStatusClass = "perf-good"; }
                else if (runwayWithRandom > 6) { runwayDesc = "Okay"; runwayStatusClass = "perf-safe"; }
                else if (runwayWithRandom > 4) { runwayDesc = "Struggled"; runwayStatusClass = "perf-bad"; }
                else { runwayDesc = "FLOP"; runwayStatusClass = "perf-flop"; }
            }

            const challengeWeighted = hasRunway ? challengeWithRandom * 0.8 : challengeWithRandom;
            const runwayWeighted = hasRunway ? runwayWithRandom * 0.2 : 0;
            const totalBase = challengeWeighted + runwayWeighted;
            
            const lastPlacement = stats && stats[q] ? stats[q].lastPlacement : null;
            let winModifier = 0;
            {
                const consWins = (stats && stats[q]) ? (stats[q].consecutiveWins || 0) : 0;
                const consHighs = (stats && stats[q]) ? (stats[q].consecutiveHighs || 0) : 0;
                if (consWins > 0) {
                    winModifier = -1.25 - ((consWins - 1) * 0.5);
                } else if (consHighs > 0) {
                    winModifier = -0.5 - ((consHighs - 1) * 0.25);
                }
            }
            const total = totalBase + randomTotal + winModifier;

            return { 
                name: q, 
                total, 
                totalBase,
                challengeTotal: challengeWithRandom, 
                runwayTotal: runwayWithRandom, 
                challengeWeighted,
                runwayWeighted,
                randomTotal,
                winModifier,
                desc, 
                statusClass, 
                runwayDesc, 
                runwayStatusClass, 
                details: `(${challengeWithRandom.toFixed(1)})`,
                runwayDetails: hasRunway ? `(${runwayWithRandom.toFixed(1)})` : ''
            };
        }).sort((a,b) => b.total - a.total);

        const isDouble = false;
        const winners = scores.slice(0, 1);
        const winnerNames = new Set(winners.map(w => w.name));
        const nonWinners = scores.filter(s => !winnerNames.has(s.name));

        const btm = [nonWinners[nonWinners.length - 1], nonWinners[nonWinners.length - 2]].filter(Boolean);
        
        const others = nonWinners.filter(s => !btm.find(b => b.name === s.name));
        const high = others.slice(0, 2);
        const low = others.length > 2 ? [others[others.length-1]] : [];
        const safe = others.filter(s => !high.find(h => h.name === s.name) && !low.find(l => l.name === s.name));
        const highTeam = [];

        let beaverSaved = null;
        let beaverSavedForUI = null;
        let beaverBottom3 = null;
        let beaverReason = null;
        if (isBeaverFormat && currentCast.length > finaleLimit) {
            const nonWinners = scores.filter(s => !winners.some(w => w.name === s.name));
            if (nonWinners.length >= 3) {
                beaverBottom3 = nonWinners.slice(-3);
                const saverName = winners[0].name;
                const personality = getPersonalityForQueen(saverName);
                const isFirstEpisode = epNum === 1;
                const beaverPick = beaverBottom3.reduce((best, s) => {
                    if (!best) return s;
                    const bestScore = getBeaverSaveScore(best, saverName, personality, stats, relationships || {}, isFirstEpisode);
                    const curScore = getBeaverSaveScore(s, saverName, personality, stats, relationships || {}, isFirstEpisode);
                    return curScore > bestScore ? s : best;
                }, null);
                beaverSaved = beaverPick ? beaverPick.name : beaverBottom3[0].name;
                beaverSavedForUI = beaverSaved;
                beaverReason = getBeaverSaveReason(saverName, beaverSaved, personality, stats, relationships || {});
                const lipSyncBottom = beaverBottom3.filter(s => s.name !== beaverSaved);
                if (lipSyncBottom.length === 2) {
                    btm[0] = lipSyncBottom[0];
                    btm[1] = lipSyncBottom[1];
                }
            }
        }

        if (beaverBottom3 && beaverBottom3.length) {
            const bottomNames = new Set(beaverBottom3.map(s => s.name));
            const filterNonBottom = arr => arr.filter(x => !bottomNames.has(x.name));
            if (high.length) {
                const newHigh = filterNonBottom(high);
                high.splice(0, high.length, ...newHigh);
            }
            if (safe.length) {
                const newSafe = filterNonBottom(safe);
                safe.splice(0, safe.length, ...newSafe);
            }
            low.length = 0;
        }

        let untuckedScenes = [];
        if (relationshipTension) {
            const untucked = generateUntucked(winners, btm, high, safe, low, stats, relationships, relationshipTension);
            untuckedScenes = untucked.scenes || [];
        }

        const ls1 = calcLipSyncScore(btm[0].name, 'btm2', stats);
        const ls2 = calcLipSyncScore(btm[1].name, 'btm2', stats);
        
        let elim = ls1.score < ls2.score ? btm[0].name : btm[1].name;
        const otherBtm = btm[0].name === elim ? btm[1].name : btm[0].name;
        if (stats[elim].ppe >= stats[otherBtm].ppe + RIGGORY_PPE_THRESHOLD) {
            elim = otherBtm;
        }
        let isDoubleShantay = false;
        const scoreDiff = Math.abs(ls1.score - ls2.score);
        const rollShantay = Math.random();
        if (scoreDiff < 1 && rollShantay > 0.65 && currentCast.length > finaleLimit + 2 && !doubleShantayUsed) {
            elim = null; isDoubleShantay = true; doubleShantayUsed = true;
        }
        if (elim) currentCast = currentCast.filter(q => q !== elim);

        const isBeaverEpisode = isBeaverFormat && beaverSaved;

        scores.forEach(s => {
            const name = s.name;
            const st = stats[name];
            let points = 0;
            let placement = null;

            const isBeaverQueen = isBeaverEpisode && name === beaverSaved;

            if (winners.find(w => w.name === name)) { st.wins++; points = 5; placement = 'WIN'; } 
            else if (high.find(h => h.name === name)) { st.highs++; points = 4; placement = 'HIGH'; }
            else if (safe.find(x => x.name === name)) { st.safe++; points = 3; placement = 'SAFE'; }
            else if (low.find(l => l.name === name)) { st.lows++; points = 2; placement = 'LOW'; }
            else if (btm.find(b => b.name === name) || isBeaverQueen) {
                st.bottoms++;
                if (elim === name) { points = 0; placement = 'ELIM'; }
                else if (isBeaverQueen) { points = 2; placement = 'BTM'; }
                else { points = 1; placement = 'BTM'; }
            }
            st.totalPoints += points;
            st.episodesCount++;
            st.ppe = st.totalPoints / st.episodesCount;
            if (placement === 'WIN') {
                st.consecutiveWins = (st.consecutiveWins || 0) + 1;
                st.consecutiveHighs = 0;
            } else if (placement === 'HIGH') {
                st.consecutiveHighs = (st.consecutiveHighs || 0) + 1;
                st.consecutiveWins = 0;
            } else {
                st.consecutiveWins = 0;
                st.consecutiveHighs = 0;
            }
            st.lastPlacement = placement;
        });

        const epData = {
            episode: epNum,
            challenge: chal,
            scores: scores,
            winners, isDouble, isDoubleShantay,
            high, highTeam, safe, low,
            bottom: [{ name: btm[0].name, score: ls1.score, info: ls1.breakdown }, { name: btm[1].name, score: ls2.score, info: ls2.breakdown }],
            eliminated: elim,
            remainingCount: currentCast.length,
            isFinale: false,
            hasRunway,
            isBeaverFormat,
            beaverSaved,
            beaverSavedForUI,
            beaverReason,
            beaverBottom3: beaverBottom3 ? beaverBottom3.map(s => s.name) : null,
            returnedQueen: queenName
        };
        if (untuckedScenes.length > 0) epData.untucked = untuckedScenes;
        episodes.push(epData);
        epNum++;

        while (currentCast.length > finaleLimit) {
            let luckyQueenSave = null;
            const isLastCompetitiveEp = currentCast.length === finaleLimit + 1;
            const chal = pickChallengeForEpisode(epNum, challengeUsedCount, opener, isLastCompetitiveEp, finaleLimit, state.castAtStart.length);
            const hasRunway = hasRunwayForChallenge(chal);

            const scores = currentCast.map(q => {
                const queen = queensDb[q];
                const challengeStats = challengeConfig[chal];
                const base = challengeStats.reduce((acc, s) => acc + queen[s], 0) / challengeStats.length;
                const challengeTotal = base;

                const randomForChallenge = Math.random() * 5 - 2.5;
                const randomForRunway = hasRunway ? (Math.random() * 5 - 2.5) : 0;
                const randomTotal = 0;

                const challengeWithRandom = challengeTotal + randomForChallenge;

                let desc = "Safe";
                let statusClass = "perf-safe";
                if (challengeWithRandom > 12) { desc = "SLAYED!"; statusClass = "perf-slay"; }
                else if (challengeWithRandom > 8) { desc = "Great job"; statusClass = "perf-good"; }
                else if (challengeWithRandom > 6) { desc = "Okay"; statusClass = "perf-safe"; }
                else if (challengeWithRandom > 4) { desc = "Struggled"; statusClass = "perf-bad"; }
                else { desc = "FLOP"; statusClass = "perf-flop"; }

                let runwayTotal = 0;
                let runwayDesc = "";
                let runwayStatusClass = "";
                let runwayWithRandom = 0;
                let runwayDetails = "";

                if (hasRunway) {
                    const fashionBase = queen.fashion;
                    runwayTotal = fashionBase;
                    runwayWithRandom = runwayTotal + randomForRunway;

                    if (runwayWithRandom > 12) { runwayDesc = "SLAYED!"; runwayStatusClass = "perf-slay"; }
                    else if (runwayWithRandom > 8) { runwayDesc = "Great job"; runwayStatusClass = "perf-good"; }
                    else if (runwayWithRandom > 6) { runwayDesc = "Okay"; runwayStatusClass = "perf-safe"; }
                    else if (runwayWithRandom > 4) { runwayDesc = "Struggled"; runwayStatusClass = "perf-bad"; }
                    else { runwayDesc = "FLOP"; runwayStatusClass = "perf-flop"; }
                    runwayDetails = `(${runwayWithRandom.toFixed(1)})`;
                }

                const challengeWeighted = hasRunway ? challengeWithRandom * 0.8 : challengeWithRandom;
                const runwayWeighted = hasRunway ? runwayWithRandom * 0.2 : 0;
                const totalBase = challengeWeighted + runwayWeighted;

                const lastPlacement = stats && stats[q] ? stats[q].lastPlacement : null;
                let winModifier = 0;
                {
                    const consWins = (stats && stats[q]) ? (stats[q].consecutiveWins || 0) : 0;
                    const consHighs = (stats && stats[q]) ? (stats[q].consecutiveHighs || 0) : 0;
                    if (consWins > 0) {
                        winModifier = -1.25 - ((consWins - 1) * 0.5);
                    } else if (consHighs > 0) {
                        winModifier = -0.5 - ((consHighs - 1) * 0.25);
                    }
                }
                const total = totalBase + randomTotal + winModifier;

                return { 
                    name: q, 
                    total, 
                    totalBase,
                    challengeTotal: challengeWithRandom, 
                    runwayTotal: runwayWithRandom, 
                    challengeWeighted,
                    runwayWeighted,
                    randomTotal,
                    winModifier,
                    desc, 
                    statusClass, 
                    runwayDesc, 
                    runwayStatusClass, 
                    details: `(${challengeWithRandom.toFixed(1)})`,
                    runwayDetails: hasRunway ? `(${runwayWithRandom.toFixed(1)})` : '' 
                };
            }).sort((a,b) => b.total - a.total);

            let winningTeam = null;
            let losingTeam = null;
            let teamAssignments = {};

            if (chal === 'Girl Groups' && !isAllStars && currentCast.length >= 4) {
                let numGroups = 2;
                if (currentCast.length >= 12) numGroups = 4;
                else if (currentCast.length >= 9) numGroups = 3;
                
                const shuffledQueens = [...scores]; 
                for (let i = shuffledQueens.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffledQueens[i], shuffledQueens[j]] = [shuffledQueens[j], shuffledQueens[i]];
                }

                const groups = [];
                for(let i=0; i<numGroups; i++) groups.push([]);
                
                shuffledQueens.forEach((q, index) => {
                    groups[index % numGroups].push(q);
                });

                const groupScores = groups.map((group, idx) => {
                    const sum = group.reduce((acc, q) => acc + q.challengeTotal, 0); 
                    const avg = sum / group.length;
                    return { id: idx, avg, members: group };
                });

                groupScores.sort((a, b) => b.avg - a.avg);
                winningTeam = groupScores[0];
                losingTeam = groupScores[groupScores.length - 1]; 
                winningTeam.members.forEach(m => teamAssignments[m.name] = 'WIN_TEAM');
            }

            const isDouble = Math.abs(scores[0].total - scores[1].total) < 0.25 && Math.random() < 0.05;
            let winners = isDouble ? scores.slice(0, 2) : scores.slice(0, 1);
            
            if (winningTeam) {
                const sortedWinners = [...winningTeam.members].sort((a, b) => b.total - a.total);
                winners = [sortedWinners[0]]; 
            }

            const winnerNames = new Set(winners.map(w => w.name));
            
           
            let high = [], safe = [], low = [], btm = [], highTeam = [];

            if (winningTeam) {

                const actualWinnerName = winners[0].name;
                winningTeam.members.forEach(m => {
                    if (m.name !== actualWinnerName) {
                        highTeam.push(m);
                    }
                });
                
                if (highTeam.length === 0 && winningTeam.members.length > 1) {
                    winningTeam.members.slice(1).forEach(m => highTeam.push(m));
                }
                const losingMembers = [...losingTeam.members].sort((a, b) => a.total - b.total); 
                btm = [losingMembers[0], losingMembers[1]]; 
                for (let i = 2; i < losingMembers.length; i++) {
                    low.push(losingMembers[i]);
                }
                scores.forEach(s => {
                    const name = s.name;
                    if (!winnerNames.has(name) && !high.find(h => h.name === name) && !highTeam.find(ht => ht.name === name) && !btm.find(b => b.name === name) && !low.find(l => l.name === name)) {
                        safe.push(s);
                    }
                });

            } else {
                const nonWinners = scores.filter(s => !winnerNames.has(s.name));
                btm = [nonWinners[nonWinners.length - 1], nonWinners[nonWinners.length - 2]].filter(Boolean);
                const remainingForSafe = nonWinners.filter(s => !btm.find(b => b.name === s.name));
                const highCount = Math.max(2, Math.floor(currentCast.length * 0.25));
                high = remainingForSafe.slice(0, highCount);
                
                const lowCount = Math.max(1, Math.floor(currentCast.length * 0.15));
                low = remainingForSafe.slice(remainingForSafe.length - lowCount);
                
                safe = remainingForSafe.filter(s => !high.includes(s) && !low.includes(s));
            }
            



            let beaverSaved = null;
            let beaverBottom3 = null;
            let beaverReason = null;
            if (isBeaverFormat && currentCast.length > finaleLimit) {
                const nonWinners = scores.filter(s => !winners.some(w => w.name === s.name));
                
                let potentialBottom3 = nonWinners;
                if (winningTeam && losingTeam && losingTeam.members.length >= 3) {
                    potentialBottom3 = [...losingTeam.members].sort((a,b) => b.total - a.total);
                }

                if (potentialBottom3.length >= 3) {
                    beaverBottom3 = potentialBottom3.slice(-3);
                    const saverName = winners[0].name;
                    const personality = getPersonalityForQueen(saverName);
                    const isFirstEpisode = epNum === 1;
                    const beaverPick = beaverBottom3.reduce((best, s) => {
                        if (!best) return s;
                        const bestScore = getBeaverSaveScore(best, saverName, personality, stats, relationships || {}, isFirstEpisode);
                        const curScore = getBeaverSaveScore(s, saverName, personality, stats, relationships || {}, isFirstEpisode);
                        return curScore > bestScore ? s : best;
                    }, null);
                    beaverSaved = beaverPick ? beaverPick.name : beaverBottom3[0].name;
                    beaverReason = getBeaverSaveReason(saverName, beaverSaved, personality, stats, relationships || {});
                    const lipSyncBottom = beaverBottom3.filter(s => s.name !== beaverSaved);
                    if (lipSyncBottom.length === 2) {
                        btm[0] = lipSyncBottom[0];
                        btm[1] = lipSyncBottom[1];
                    }
                }
            }

            if (beaverBottom3 && beaverBottom3.length) {
                const bottomNames = new Set(beaverBottom3.map(s => s.name));
                const filterNonBottom = arr => arr.filter(x => !bottomNames.has(x.name));
                if (high.length) {
                    const newHigh = filterNonBottom(high);
                    high.splice(0, high.length, ...newHigh);
                }
                if (safe.length) {
                    const newSafe = filterNonBottom(safe);
                    safe.splice(0, safe.length, ...newSafe);
                }
                low.length = 0;
            }

            let untuckedScenes = [];
            if (relationshipTension) {
                const combinedHigh = [...high, ...highTeam];
                const untucked = generateUntucked(winners, btm, combinedHigh, safe, low, stats, relationships, relationshipTension);
                untuckedScenes = untucked.scenes || [];
            }

            const ls1 = calcLipSyncScore(btm[0].name, 'btm2', stats);
            const ls2 = calcLipSyncScore(btm[1].name, 'btm2', stats);
            
            let elim = ls1.score < ls2.score ? btm[0].name : btm[1].name;
            const otherBtm = btm[0].name === elim ? btm[1].name : btm[0].name;
            if (stats[elim].ppe >= stats[otherBtm].ppe + RIGGORY_PPE_THRESHOLD) {
                elim = otherBtm;
            }

            let isDoubleSashay = false;
            if (ls1.score < 4 && ls2.score < 4 && Math.random() < 0.03 && currentCast.length > finaleLimit + 2) {
                elim = [btm[0].name, btm[1].name];
                isDoubleSashay = true;
            }

            let isDoubleShantay = false;
            const scoreDiff = Math.abs(ls1.score - ls2.score);
            const rollShantay = Math.random();
            if (!isDoubleSashay && scoreDiff < 1 && rollShantay > 0.65 && currentCast.length > finaleLimit + 2 && !doubleShantayUsed) {
                elim = null; isDoubleShantay = true; doubleShantayUsed = true;
            }
            if (elim) {
                if (Array.isArray(elim)) {
                    currentCast = currentCast.filter(q => !elim.includes(q));
                } else {
                    currentCast = currentCast.filter(q => q !== elim);
                }
            }

            const isBeaverEpisode = isBeaverFormat && beaverSaved;

            scores.forEach(s => {
                const name = s.name;
                const st = stats[name];
                let points = 0;
                let placement = null;

                const isBeaverQueen = isBeaverEpisode && name === beaverSaved;

                if (winners.find(w => w.name === name)) { st.wins++; points = 5; placement = 'WIN'; } 
                else if (high.find(h => h.name === name)) { st.highs++; points = 4; placement = 'HIGH'; }
                else if (highTeam.find(ht => ht.name === name)) { st.highs++; points = 4; placement = 'HIGH TEAM'; }
                else if (safe.find(x => x.name === name)) { st.safe++; points = 3; placement = 'SAFE'; }
                else if (low.find(l => l.name === name)) { st.lows++; points = 2; placement = 'LOW'; }
                else if (btm.find(b => b.name === name) || isBeaverQueen) {
                    st.bottoms++;
                    const isEliminated = Array.isArray(elim) ? elim.includes(name) : elim === name;
                    if (isEliminated) { points = 0; placement = 'ELIM'; }
                    else if (isBeaverQueen) { points = 2; placement = 'BTM'; }
                    else { points = 1; placement = 'BTM'; }
                }
                st.totalPoints += points;
                st.episodesCount++;
                st.ppe = st.totalPoints / st.episodesCount;
                st.lastPlacement = placement;

                if (placement === 'WIN') {
                    st.consecutiveWins = (st.consecutiveWins || 0) + 1;
                    st.consecutiveHighs = 0;
                } else if (placement === 'HIGH' || placement === 'HIGH TEAM') {
                    st.consecutiveHighs = (st.consecutiveHighs || 0) + 1;
                    st.consecutiveWins = 0;
                } else {
                    st.consecutiveWins = 0;
                    st.consecutiveHighs = 0;
                }
            });

            const epData = {
                episode: epNum,
                challenge: chal,
                scores: scores,
                winners, isDouble, isDoubleShantay, isDoubleSashay,
                high, highTeam, safe, low,
                bottom: [{ name: btm[0].name, score: ls1.score, info: ls1.breakdown }, { name: btm[1].name, score: ls2.score, info: ls2.breakdown }],
                eliminated: elim,
                remainingCount: currentCast.length,
                isFinale: false,
                hasRunway,
                isBeaverFormat,
                beaverSaved,
                beaverReason,
                beaverBottom3: beaverBottom3 ? beaverBottom3.map(s => s.name) : null,
                luckyQueenSave
            };
            if (untuckedScenes.length > 0) epData.untucked = untuckedScenes;
            episodes.push(epData);
            epNum++;
        }

        const finalePerformanceScores = currentCast.map(q => {
            const queen = queensDb[q];
            const performanceScore = queen.performance;
            const lipsyncScore = queen.lipsync;
            const luck = Math.random() * 7;
            const total = (performanceScore + lipsyncScore) / 2 + luck;
            
            return {
                name: q,
                total: total,
                performanceScore: performanceScore,
                lipsyncScore: lipsyncScore,
                luck: luck,
                passed: total >= 8
            };
        }).sort((a, b) => b.total - a.total);

        const sortedByPPE = [...currentCast].sort((a, b) => stats[b].ppe - stats[a].ppe);
        const withWins = sortedByPPE.filter(q => stats[q].wins > 0);
        let winnerName = withWins.length > 0 ? withWins[0] : sortedByPPE[0];

        if (finaleLimit === 4 && finaleFormat === 'crown') {
            const shuffled = [...currentCast].map(x => ({ x, r: Math.random() })).sort((a, b) => a.r - b.r).map(o => o.x);
            const pair1 = [shuffled[0], shuffled[1]];
            const pair2 = [shuffled[2], shuffled[3]];
            const runMatch = (a, b) => {
                const sa = calcLipSyncScore(a, 'lalaparuza', stats);
                const sb = calcLipSyncScore(b, 'lalaparuza', stats);
                const aWins = sa.score >= sb.score;
                const winner = aWins ? a : b;
                const loser = aWins ? b : a;
                const song = (window.pickRandomLipSyncSong && typeof window.pickRandomLipSyncSong === 'function')
                    ? window.pickRandomLipSyncSong()
                    : '';
                return {
                    a, b,
                    scoreA: sa.score, breakdownA: sa.breakdown,
                    scoreB: sb.score, breakdownB: sb.breakdown,
                    winner, loser,
                    song
                };
            };
            const m1 = runMatch(pair1[0], pair1[1]);
            const m2 = runMatch(pair2[0], pair2[1]);
            const finalLipSyncQueens = [m1.winner, m2.winner];
            const finalScores = finalLipSyncQueens.map(q => calcLipSyncScore(q, 'finale', stats));
            const finalSorted = [...finalScores].sort((a, b) => b.score - a.score);
            if (finalSorted.length > 0) {
                const topScoreDiff = finalSorted.length > 1 ? Math.abs(finalSorted[0].score - finalSorted[1].score) : 0;
                if (topScoreDiff < 0.01 && finalSorted.length > 1) {
                    const ppeA = stats[finalSorted[0].name] ? stats[finalSorted[0].name].ppe : 0;
                    const ppeB = stats[finalSorted[1].name] ? stats[finalSorted[1].name].ppe : 0;
                    winnerName = ppeA >= ppeB ? finalSorted[0].name : finalSorted[1].name;
                } else {
                    winnerName = finalSorted[0].name;
                }
            }
            const lostRound1 = [m1.loser].filter(Boolean);
            const lostRound2 = [m2.loser].filter(Boolean);
            const lostRound3 = finalLipSyncQueens.filter(q => q !== winnerName);
            const runnerUps = finalLipSyncQueens.filter(q => q !== winnerName);
            const eliminatedInFinale = [...lostRound2, ...lostRound1];
            episodes.push({
                episode: epNum,
                challenge: "Grand Finale — Lip Sync For The Crown",
                scores: [],
                winners: [{ name: winnerName, total: 100 }],
                top2: [],
                bottom: [],
                remainingCount: currentCast.length,
                isAllStars: false,
                isFinale: true,
                isCrownFinale: true,
                finalists: currentCast,
                crownRound1: [m1],
                crownRound2: [m2],
                finalLipSyncQueens,
                finalLipSyncScores: finalSorted,
                eliminatedInFinale,
                lostRound1,
                lostRound2,
                lostRound3,
                runnerUps,
                winner: winnerName
            });
        } else {
            const finalePerformanceScores = currentCast.map(q => {
                const queen = queensDb[q];
                const performanceScore = queen.performance;
                const lipsyncScore = queen.lipsync;
                const luck = Math.random() * 7;
                const total = (performanceScore + lipsyncScore) / 2 + luck;
                return {
                    name: q,
                    total: total,
                    performanceScore: performanceScore,
                    lipsyncScore: lipsyncScore,
                    luck: luck,
                    passed: total >= 8
                };
            }).sort((a, b) => b.total - a.total);

            let finalLipSyncQueens = [];
            if (finaleLimit === 3) {
                const eligibleQueens = sortedByPPE.filter(q => {
                    const perfScore = finalePerformanceScores.find(s => s.name === q);
                    return perfScore && perfScore.passed && stats[q].wins > 0;
                });
                if (eligibleQueens.length === 0) {
                    finalLipSyncQueens = sortedByPPE.slice(0, 2).filter(q => stats[q].wins > 0);
                } else if (eligibleQueens.length >= 3) {
                    const diff = stats[eligibleQueens[1]].ppe - stats[eligibleQueens[2]].ppe;
                    finalLipSyncQueens = diff <= 0.1 ? eligibleQueens.slice(0, 3) : eligibleQueens.slice(0, 2);
                } else {
                    finalLipSyncQueens = eligibleQueens.length >= 2 ? eligibleQueens : sortedByPPE.slice(0, 2).filter(q => stats[q].wins > 0);
                }
            } else if (finaleLimit === 4) {
                const eligibleQueens = sortedByPPE.filter(q => {
                    const perfScore = finalePerformanceScores.find(s => s.name === q);
                    return perfScore && perfScore.passed && stats[q].wins > 0;
                });
                if (eligibleQueens.length === 0) {
                    finalLipSyncQueens = sortedByPPE.slice(0, 2).filter(q => stats[q].wins > 0);
                } else if (eligibleQueens.length >= 4) {
                    const diff34 = stats[eligibleQueens[2]].ppe - stats[eligibleQueens[3]].ppe;
                    if (diff34 <= 0.1) {
                        finalLipSyncQueens = eligibleQueens.slice(0, 4);
                    } else {
                        const diff23 = stats[eligibleQueens[1]].ppe - stats[eligibleQueens[2]].ppe;
                        finalLipSyncQueens = diff23 <= 0.3 ? eligibleQueens.slice(0, 3) : eligibleQueens.slice(0, 2);
                    }
                } else {
                    finalLipSyncQueens = eligibleQueens.length >= 2 ? eligibleQueens : sortedByPPE.slice(0, 2).filter(q => stats[q].wins > 0);
                }
            }
            if (finalLipSyncQueens.length < 2) {
                const withWins = sortedByPPE.filter(q => stats[q].wins > 0).slice(0, 2);
                finalLipSyncQueens = withWins.length >= 2 ? withWins : sortedByPPE.slice(0, 2);
            }

            const finalLipSyncScores = finalLipSyncQueens.map(q => calcLipSyncScore(q, 'finale', stats)).sort((a, b) => b.score - a.score);
            const eliminatedInFinale = currentCast.filter(q => !finalLipSyncQueens.includes(q));
            const runnerUps = finalLipSyncQueens.filter(q => q !== winnerName);

            episodes.push({
                episode: epNum,
                challenge: "Grand Finale Performance",
                scores: finalePerformanceScores,
                winners: [{ name: winnerName, total: 100 }],
                top2: [],
                bottom: [],
                remainingCount: currentCast.length,
                isAllStars: false,
                isFinale: true,
                finalists: finalLipSyncQueens,
                finalePerformanceScores: finalePerformanceScores,
                finalLipSyncQueens: finalLipSyncQueens,
                finalLipSyncScores: finalLipSyncScores,
                eliminatedInFinale: eliminatedInFinale,
                runnerUps: runnerUps,
                winner: winnerName
            });
        }

        seasonData = { episodes, finale: currentCast, winner: winnerName, queenStats: stats, castQueens: state.castAtStart, finaleLimit: finaleLimit, relationships };
        seasonData.returnState = null;
        currentEpIndex = placeholderIndex;
        scenarioPhase = 1;
        renderScenario();
    }

    function onReturnPickChange() {
        const sel = document.getElementById('returnPickSelect');
        const btn = document.getElementById('returnPickBtn');
        const img = document.getElementById('returnPickImg');
        const nameEl = document.getElementById('returnPickName');
        const ppeEl = document.getElementById('returnPickPpe');
        if (!sel) return;
        const name = sel.value;
        if (nameEl) {
            nameEl.textContent = name || 'Select a queen…';
        }
        if (ppeEl) {
            if (name) {
                const prevEpIndex = currentEpIndex - 1;
                const maxEp = prevEpIndex >= 0 && seasonData.episodes[prevEpIndex] ? seasonData.episodes[prevEpIndex].episode : 0;
                const currentStatsArray = calculateQueenStats(seasonData, maxEp);
                const stats = {};
                currentStatsArray.forEach(s => { stats[s.name] = s; });
                const st = stats[name] || null;
                ppeEl.textContent = `${((st && typeof st.ppe === 'number') ? st.ppe : 0).toFixed(2)} PPE`;
                ppeEl.classList.remove('hidden');
            } else {
                ppeEl.textContent = '';
                ppeEl.classList.add('hidden');
            }
        }
        if (img) {
            if (name && queensDb[name] && queensDb[name].photo) {
                img.src = queensDb[name].photo;
                img.classList.remove('hidden');
            } else {
                img.src = '';
                img.classList.add('hidden');
            }
        }
        if (btn) {
            const enabled = !!name;
            btn.disabled = !enabled;
            btn.className = enabled
                ? 'px-4 py-2 rounded-xl bg-pink-600 hover:bg-pink-700 text-white font-bold text-sm'
                : 'px-4 py-2 rounded-xl bg-gray-200 text-gray-500 font-bold text-sm cursor-not-allowed';
        }
    }

    function confirmReturnPick() {
        const sel = document.getElementById('returnPickSelect');
        if (!sel) return;
        const name = sel.value;
        if (!name) return;
        if (seasonData && seasonData.returnState) {
            if (seasonData.isAllStars) {
                returnAllStarsQueen(name);
            } else {
                returnRegularQueen(name);
            }
            return;
        }
        returnTournamentQueen(name);
    }

    function advanceScenario() {
        if (currentEpIndex >= seasonData.episodes.length) return;

        const ep = seasonData.episodes[currentEpIndex];

        if (!ep.isFinale) {
            const hasRunway = ep.hasRunway !== undefined ? ep.hasRunway : hasRunwayForChallenge(ep.challenge);
            if (hasRunway && scenarioPhase === 1 && !ep.runwayShown) {
                ep.runwayShown = true;
                renderScenario();
                return;
            }
        }

        let maxPhase;
        if (seasonData.isAllStars && ep.isAllStars && !ep.isFinale) maxPhase = 8;
        else if (seasonData.isAllStars && ep.isFinale && ep.isTournamentFinale) maxPhase = 5;
        else if (seasonData.isAllStars && ep.isFinale) maxPhase = (ep.finalLipSyncQueens && ep.finalLipSyncQueens.length >= 2) ? 5 : 0;
        else if (ep.isFinale) maxPhase = 5;
        else maxPhase = (ep.untucked && ep.untucked.length > 0) ? 8 : 7;

        if (scenarioPhase < maxPhase) {
            scenarioPhase++;
            renderScenario();
        } else {
            scenarioPhase = 0;
            currentEpIndex++;
            renderScenario();
        }
    }

    function renderTrackRecordScreen() {
        const stage = document.getElementById('stageContent');
        stage.innerHTML = '';
        
        const container = document.getElementById('trackRecordContainer');
        container.classList.remove('hidden');
        container.classList.remove('mt-6');
        stage.appendChild(container);
        
        document.getElementById('debugInfo').innerText = "Season Summary";
        
        const nextBtn = document.getElementById('nextBtn');
        nextBtn.classList.remove('hidden');
        nextBtn.innerText = "Restart Simulator";
        nextBtn.onclick = function() {
            location.reload();
        };
    }

    function calculateMissCongeniality() {
        if (seasonData.isTournament) return null;
        if (seasonData.missCongeniality) return seasonData.missCongeniality;

        const cast = seasonData.castQueens;
        const rels = seasonData.relationships || (window.state && window.state.relationships) || {};
        
        if (!cast || cast.length === 0) return null;
        const eliminatedSet = new Set();
        seasonData.episodes.forEach(ep => {
            if (ep.isFinale) return;
            if (ep.returnedQueen) eliminatedSet.delete(ep.returnedQueen);
            if (Array.isArray(ep.eliminated)) ep.eliminated.forEach(q => eliminatedSet.add(q));
            else if (ep.eliminated) eliminatedSet.add(ep.eliminated);
            if (Array.isArray(ep.bracketEliminated)) ep.bracketEliminated.forEach(q => eliminatedSet.add(q));
        });

        const votes = {};
        cast.forEach(q => votes[q] = 0);
        const votingRecord = [];

        const relValues = {
            'drag_family': 5,
            'great': 4,
            'good': 3,
            'neutral': 2,
            'bad': 1,
            'chop': 0
        };

        cast.forEach(voter => {
            let bestScore = -1;
            let candidates = [];

            cast.forEach(candidate => {
                if (voter === candidate) return;
                if (!eliminatedSet.has(candidate)) return; 
                
                const key = [voter, candidate].sort().join('|');
                const rel = rels[key] || 'neutral';
                const score = relValues[rel] || 2;

                if (score > bestScore) {
                    bestScore = score;
                    candidates = [candidate];
                } else if (score === bestScore) {
                    candidates.push(candidate);
                }
            });

            if (candidates.length > 0) {
                const choice = candidates[Math.floor(Math.random() * candidates.length)];
                votes[choice] = (votes[choice] || 0) + 1;
                votingRecord.push({ voter, choice });
            }
        });

        let winners = [];
        let maxVotes = -1;
        
        for (const q in votes) {
            if (votes[q] > maxVotes) {
                maxVotes = votes[q];
                winners = [q];
            } else if (votes[q] === maxVotes) {
                winners.push(q);
            }
        }
        
        const winner = winners.length > 0 ? winners[Math.floor(Math.random() * winners.length)] : null;
        
        seasonData.missCongeniality = winner;
        seasonData.missCongenialityVotes = votingRecord;
        return winner;
    }

    function renderMissCongenialityVoting() {
        const stage = document.getElementById('stageContent');
        const debug = document.getElementById('debugInfo');
        const btn = document.getElementById('nextBtn');
        
        calculateMissCongeniality();
        const votes = seasonData.missCongenialityVotes || [];
        
        const votesHtml = votes.map((v, i) => `
            <div class="flex items-center gap-2 sm:gap-3 rounded-xl border border-cyan-200 bg-cyan-50 px-3 py-3 sm:px-4 mb-2">
                <div class="flex min-w-0 flex-1 items-center gap-2">
                    <div class="h-9 w-9 min-h-9 min-w-9 flex-shrink-0 aspect-square rounded-full overflow-hidden border-2 border-cyan-200">
                        <img src="${queensDb[v.voter].photo}" class="h-full w-full object-cover">
                    </div>
                    <span class="text-sm font-semibold text-gray-900 truncate">${v.voter}</span>
                </div>
                <div class="text-cyan-500 text-sm w-4 sm:w-6 text-center flex-shrink-0">→</div>
                <div class="flex min-w-0 flex-1 items-center justify-end gap-2">
                    <span class="text-sm font-semibold text-gray-900 truncate text-right">${v.choice}</span>
                    <div class="h-9 w-9 min-h-9 min-w-9 flex-shrink-0 aspect-square rounded-full overflow-hidden border-2 border-cyan-200">
                        <img src="${queensDb[v.choice].photo}" class="h-full w-full object-cover">
                    </div>
                </div>
            </div>
        `).join('');

        stage.innerHTML = `
            <div class="w-full h-full flex flex-col items-center pt-2">
                <div class="mx-auto h-12 w-12 rounded-full bg-cyan-100 flex items-center justify-center p-3 mb-2">
                    <img src="images/miss-c.svg" class="w-full h-full object-contain">
                </div>
                <h3 class="sc-section font-bold mb-2 w-full text-center">Miss Congeniality</h3>
                <p class="text-[14px] text-gray-500 mb-4 text-center">The queens cast their votes based on relationships</p>
                
                <div class="w-full max-w-xl px-4 pb-20 custom-scrollbar">
                    ${votesHtml}
                </div>
            </div>
        `;
        
        debug.innerText = "Miss Congeniality Voting";
        btn.innerHTML = "Continue";
        btn.onclick = function() {
            advanceScenario();
        };
    }

    function renderFinale() {
        const stage = document.getElementById('stageContent');
        const winner = seasonData.winner;
        const wStats = seasonData.queenStats[winner];
        const finaleEp = seasonData.episodes.find(e => e.isFinale);
        const runnerUps = finaleEp ? (finaleEp.runnerUps || []) : [];

        const mc = seasonData.isTournament ? null : (calculateMissCongeniality(), seasonData.missCongeniality);

        document.getElementById('trackRecordContainer').classList.add('hidden');
        renderTrackRecordTable(99); 
        
        const nextBtn = document.getElementById('nextBtn');
        nextBtn.classList.remove('hidden');
        nextBtn.innerText = "Show Track Record";
        nextBtn.onclick = renderTrackRecordScreen;

        document.getElementById('debugInfo').innerText = "Season Finale";

        stage.innerHTML = `
            <div class="flex flex-col items-center">
                <h1 class="text-sm font-bold text-gray-400 uppercase mb-4">The Winner Is</h1>
                <div class="relative">
                    <div class="absolute -inset-2 bg-gradient-to-r from-yellow-300 via-orange-400 to-yellow-300 rounded-full blur-lg opacity-75 animate-pulse"></div>
                    <img src="${queensDb[winner].photo}" class="relative w-48 h-48 rounded-full border-4 border-white shadow-2xl object-cover">
                </div>
                <h2 class="text-5xl font-black text-gray-800 mt-6 mb-2">${winner}</h2>
                
                <div class="flex gap-2 text-xs font-bold mt-2">
                    <span class="px-3 py-1 bg-blue-100 text-blue-700 rounded-full">🏆 ${wStats.wins} WINS</span>
                    <span class="px-3 py-1 bg-pink-100 text-pink-700 rounded-full">💀 ${wStats.bottoms} BTMS</span>
                    <span class="px-3 py-1 bg-purple-100 text-purple-700 rounded-full">📊 ${wStats.ppe.toFixed(2)} PPE</span>
                </div>
                
                ${runnerUps.length > 0 ? `
                <div class="mt-8 pt-6 border-t border-gray-200 w-full max-w-md">
                    <h3 class="text-xs font-bold text-gray-400 uppercase mb-3">Runner-Ups</h3>
                    <div class="flex justify-center gap-4 flex-wrap">
                        ${runnerUps.map(name => `
                            <div class="flex flex-col items-center">
                                <div class="relative group transition-transform hover:scale-105">
                                     <div class="absolute -inset-1 bg-gray-300 rounded-full blur opacity-50"></div>
                                     <img src="${queensDb[name].photo}" class="relative w-20 h-20 rounded-full border-4 border-gray-300 shadow-md object-cover">
                                </div>
                                <span class="text-xs font-bold text-gray-600 mt-2">${name}</span>
                            </div>
                        `).join('')}
                    </div>
                </div>
                ` : ''}

                ${mc ? `
                <div class="mt-8 pt-6 border-t border-gray-200 w-full max-w-md flex flex-col items-center">
                    <h3 class="text-xs font-bold text-gray-400 uppercase mb-6">Special Awards</h3>
                    <div class="flex flex-col items-center">
                        <div class="relative group cursor-pointer transition-transform hover:scale-105">
                             <div class="absolute -inset-1 bg-cyan-200 rounded-full blur opacity-50"></div>
                             <img src="${queensDb[mc].photo}" class="relative w-20 h-20 rounded-full border-4 border-[#00ffff] shadow-lg object-cover">
                             <div class="absolute -bottom-2 -right-4 bg-[#00ffff] text-black text-[10px] font-black leading-none px-2 py-1 rounded border border-black transform rotate-12 shadow-sm text-center z-10">
                                MISS<br>CON
                             </div>
                        </div>
                        <span class="text-sm font-bold text-gray-800 mt-3">${mc}</span>
                    </div>
                </div>
                ` : ''}
            </div>
        `;
    }

    function calculateQueenStats(currentSeasonData, maxEpisode) {
        const visibleEpisodes = currentSeasonData.episodes.filter(e => e.episode <= maxEpisode);
        const isNameMatch = (entry, name) => {
            if (!entry) return false;
            const entryName = entry.name || entry;
            return entryName === name;
        };
        const isBottomName = (ep, name) => Array.isArray(ep.bottom) && ep.bottom.some(b => isNameMatch(b, name));
        const isElimName = (ep, name) => {
            if (!ep) return false;
            if (Array.isArray(ep.eliminated)) return ep.eliminated.some(e => isNameMatch(e, name));
            return isNameMatch(ep.eliminated, name);
        };
        
        const tableData = currentSeasonData.castQueens.map(q => {
            let currentPoints = 0;
            let episodesParticipated = 0;
            let isEliminatedAlready = false;
            let elimEpisode = null;

            visibleEpisodes.forEach(ep => {
                if (ep.isFinale) return;

                if (ep.returnedQueen === q) {
                    isEliminatedAlready = false;
                    elimEpisode = null;
                }

                const isBracketElim = Array.isArray(ep.bracketEliminated) && ep.bracketEliminated.includes(q);
                if (isBracketElim) {
                    const isWin = (ep.isAllStars && ep.isDoubleWin && ep.top2 && ep.top2.find(t => t.name === q))
                        || (ep.isAllStars && ep.lipSyncWinner === q);
                    const isTop2 = (ep.isAllStars && ep.lipSyncLoser === q);
                    if (isWin) currentPoints += 2.5;
                    else if (isTop2) currentPoints += 2.25;
                    else currentPoints += 0;
                    episodesParticipated++;
                    isEliminatedAlready = true;
                    if (elimEpisode === null) elimEpisode = ep.episode;
                    return;
                }

                // FORCE BOTTOM CHECK FIRST
                if (isBottomName(ep, q)) {
                    const isElim = isElimName(ep, q);
                    if (isElim) {
                        currentPoints += 0;
                        episodesParticipated++;
                        isEliminatedAlready = true;
                        if (elimEpisode === null) elimEpisode = ep.episode;
                    } else {
                        currentPoints += 1;
                        episodesParticipated++;
                    }
                    return; // Stop processing this episode for this queen
                }

                if (ep.isAllStars && ep.top2 && (ep.lipSyncWinner || ep.isDoubleWin)) {
                    if (ep.isDoubleWin && ep.top2.find(t => t.name === q)) { currentPoints += 5; episodesParticipated++; }
                    else if (ep.lipSyncWinner === q) { currentPoints += 5; episodesParticipated++; }
                    else if (ep.lipSyncLoser === q) { currentPoints += 4.5; episodesParticipated++; }
                    else if (ep.high.find(h => h.name === q)) { currentPoints += 4; episodesParticipated++; }
                    else if (ep.highTeam && ep.highTeam.find(h => h.name === q)) { currentPoints += 4; episodesParticipated++; }
                    else if (ep.safe.find(s => s.name === q)) { currentPoints += 3; episodesParticipated++; }
                    else if (ep.low.find(l => l.name === q)) { currentPoints += 2; episodesParticipated++; }
                }
                else if (!ep.isAllStars && ep.isDoublePremiere && ep.top2 && ep.lipSyncWinner) {
                     if (ep.lipSyncWinner === q) { currentPoints += 5; episodesParticipated++; }
                    else if (ep.top2.find(t => t.name === q)) { currentPoints += 4.5; episodesParticipated++; }
                    else if (ep.high.find(h => h.name === q)) { currentPoints += 4; episodesParticipated++; }
                    else if (ep.highTeam && ep.highTeam.find(h => h.name === q)) { currentPoints += 4; episodesParticipated++; }
                    else if (ep.safe.find(s => s.name === q)) { currentPoints += 3; episodesParticipated++; }
                    else if (ep.low.find(l => l.name === q)) { currentPoints += 2; episodesParticipated++; }
                }
                else if (ep.winners.find(w => w.name === q)) { currentPoints += 5; episodesParticipated++; }
                else if (ep.high.find(h => h.name === q)) { currentPoints += 4; episodesParticipated++; }
                else if (ep.highTeam && ep.highTeam.find(h => h.name === q)) { currentPoints += 4; episodesParticipated++; }
                else if (ep.safe.find(s => s.name === q)) { currentPoints += 3; episodesParticipated++; }
                else if (ep.low.find(l => l.name === q)) { currentPoints += 2; episodesParticipated++; }
                else if (ep.isBeaverFormat && ep.beaverSaved === q) {
                    const isElim = ep.eliminated === q;
                    if (isElim) {
                        currentPoints += 0;
                        episodesParticipated++;
                        isEliminatedAlready = true;
                        if (elimEpisode === null) elimEpisode = ep.episode;
                    } else {
                        currentPoints += 2;
                        episodesParticipated++;
                    }
                }
            });

            const ppe = episodesParticipated > 0 ? (currentPoints / episodesParticipated) : 0;
            
            return {
                name: q,
                ppe: ppe,
                totalPoints: currentPoints,
                isEliminated: isEliminatedAlready,
                elimEpisode: elimEpisode
            };
        });

        const visibleRegular = visibleEpisodes.filter(e => !e.isFinale);
        const lastVisibleIsFinale = visibleEpisodes.length && visibleEpisodes[visibleEpisodes.length - 1].isFinale;
        const refEp = visibleRegular.length ? visibleRegular[visibleRegular.length - 1] : null;

        function getPlacementRankInEpisode(ep, queenName) {
            if (!ep || ep.isFinale) return 99;
            if (Array.isArray(ep.bracketEliminated) && ep.bracketEliminated.includes(queenName)) return 5;
            if (ep.isAllStars && ep.isDoubleWin && ep.top2.find(t => t.name === queenName)) return 0;
            if (ep.isAllStars && ep.lipSyncWinner === queenName) return 0;
            if (ep.isAllStars && ep.lipSyncLoser === queenName) return 0.5;
            if (ep.winners.find(w => w.name === queenName)) return 0;
            if (!ep.isAllStars && ep.isDoublePremiere && ep.top2 && ep.top2.find(t => t.name === queenName)) return 0.5;
            if (isBottomName(ep, queenName)) {
                const isElim = isElimName(ep, queenName);
                return isElim ? 5 : 4;
            }
            if (ep.high.find(h => h.name === queenName)) return 1;
            if (ep.highTeam && ep.highTeam.find(h => h.name === queenName)) return 1;
            if (ep.safe.find(s => s.name === queenName)) return 2;
            if (ep.low.find(l => l.name === queenName)) return 3;
            if (ep.isBeaverFormat && ep.beaverSaved === queenName) return 3;
            return 99; 
        }

        tableData.sort((a, b) => {
            const aName = a.name;
            const bName = b.name;
            const aElimEp = a.elimEpisode === null ? Infinity : a.elimEpisode;
            const bElimEp = b.elimEpisode === null ? Infinity : b.elimEpisode;

            if (lastVisibleIsFinale) {
                const finaleEpisode = currentSeasonData.episodes.find(e => e.isFinale);
                
                if (finaleEpisode && finaleEpisode.isCrownFinale) {
                    const lost1 = new Set(Array.isArray(finaleEpisode.lostRound1) ? finaleEpisode.lostRound1 : []);
                    const lost2 = new Set(Array.isArray(finaleEpisode.lostRound2) ? finaleEpisode.lostRound2 : []);
                    const lost3 = new Set(Array.isArray(finaleEpisode.lostRound3) ? finaleEpisode.lostRound3 : []);
                    
                    const aIsWinner = currentSeasonData.winner === aName;
                    const bIsWinner = currentSeasonData.winner === bName;
                    const aIsLost3 = !aIsWinner && lost3.has(aName);
                    const bIsLost3 = !bIsWinner && lost3.has(bName);
                    const aIsLost2 = !aIsWinner && !aIsLost3 && lost2.has(aName);
                    const bIsLost2 = !bIsWinner && !bIsLost3 && lost2.has(bName);
                    const aIsLost1 = !aIsWinner && !aIsLost3 && !aIsLost2 && lost1.has(aName);
                    const bIsLost1 = !bIsWinner && !bIsLost3 && !bIsLost2 && lost1.has(bName);
                    
                    let aCat = aIsWinner ? 0 : (aIsLost3 ? 1 : (aIsLost2 ? 2 : (aIsLost1 ? 3 : 4)));
                    let bCat = bIsWinner ? 0 : (bIsLost3 ? 1 : (bIsLost2 ? 2 : (bIsLost1 ? 3 : 4)));
                    
                    if (aCat !== bCat) return aCat - bCat;
                    if (aCat === 4 && aElimEp !== bElimEp) return bElimEp - aElimEp;
                    return b.ppe - a.ppe;
                }

                if (finaleEpisode && finaleEpisode.isTournamentFinale && (finaleEpisode.lostRound1 || finaleEpisode.lostRound2 || finaleEpisode.lostRound3)) {
                     const lost1 = new Set(Array.isArray(finaleEpisode.lostRound1) ? finaleEpisode.lostRound1 : []);
                    const lost2 = new Set(Array.isArray(finaleEpisode.lostRound2) ? finaleEpisode.lostRound2 : []);
                    const lost3 = new Set(Array.isArray(finaleEpisode.lostRound3) ? finaleEpisode.lostRound3 : []);
                    const aIsWinner = currentSeasonData.winner === aName;
                    const bIsWinner = currentSeasonData.winner === bName;
                    const aIsLost3 = !aIsWinner && lost3.has(aName);
                    const bIsLost3 = !bIsWinner && lost3.has(bName);
                    const aIsLost2 = !aIsWinner && !aIsLost3 && lost2.has(aName);
                    const bIsLost2 = !bIsWinner && !bIsLost3 && lost2.has(bName);
                    const aIsLost1 = !aIsWinner && !aIsLost3 && !aIsLost2 && lost1.has(aName);
                    const bIsLost1 = !bIsWinner && !bIsLost3 && !bIsLost2 && lost1.has(bName);
                    let aCat = aIsWinner ? 0 : (aIsLost3 ? 1 : (aIsLost2 ? 2 : (aIsLost1 ? 3 : 4)));
                    let bCat = bIsWinner ? 0 : (bIsLost3 ? 1 : (bIsLost2 ? 2 : (bIsLost1 ? 3 : 4)));
                    if (aCat !== bCat) return aCat - bCat;
                    if (aCat === 4 && aElimEp !== bElimEp) return bElimEp - aElimEp;
                    return b.ppe - a.ppe;
                }

                const aIsWinner = currentSeasonData.winner === aName;
                const bIsWinner = currentSeasonData.winner === bName;
                const isAS = currentSeasonData.isAllStars && finaleEpisode && finaleEpisode.finalists;
                const aIsRunnerUp = !aIsWinner && (isAS ? finaleEpisode.finalists.includes(aName) : (finaleEpisode && finaleEpisode.finalLipSyncQueens && finaleEpisode.finalLipSyncQueens.includes(aName))) && aElimEp === Infinity;
                const bIsRunnerUp = !bIsWinner && (isAS ? finaleEpisode.finalists.includes(bName) : (finaleEpisode && finaleEpisode.finalLipSyncQueens && finaleEpisode.finalLipSyncQueens.includes(bName))) && bElimEp === Infinity;
                const aElimInFinale = finaleEpisode && finaleEpisode.eliminatedInFinale && finaleEpisode.eliminatedInFinale.includes(aName);
                const bElimInFinale = finaleEpisode && finaleEpisode.eliminatedInFinale && finaleEpisode.eliminatedInFinale.includes(bName);
                let aCat = aIsWinner ? 0 : (aIsRunnerUp ? 1 : (aElimInFinale ? 2 : 3));
                let bCat = bIsWinner ? 0 : (bIsRunnerUp ? 1 : (bElimInFinale ? 2 : 3));
                if (aCat !== bCat) return aCat - bCat;
                if (aCat === 3 && aElimEp !== bElimEp) return bElimEp - aElimEp;
                return b.ppe - a.ppe;
            }

            const aRank = getPlacementRankInEpisode(refEp, aName);
            const bRank = getPlacementRankInEpisode(refEp, bName);
            if (aRank !== bRank) return aRank - bRank;
            if (aRank === 99 && bRank === 99) return bElimEp - aElimEp; 
            return b.ppe - a.ppe;
        });

        return tableData;
    }


    function calculateQueenStats(currentSeasonData, maxEpisode) {
        const visibleEpisodes = currentSeasonData.episodes.filter(e => e.episode <= maxEpisode);
        
        const tableData = currentSeasonData.castQueens.map(q => {
            let currentPoints = 0;
            let episodesParticipated = 0;
            let isEliminatedAlready = false;
            let elimEpisode = null;

            visibleEpisodes.forEach(ep => {
                if (ep.isFinale) return;

                if (ep.returnedQueen === q) {
                    isEliminatedAlready = false;
                    elimEpisode = null;
                }

                const isBracketElim = Array.isArray(ep.bracketEliminated) && ep.bracketEliminated.includes(q);
                if (isBracketElim) {
                    const isWin = (ep.isAllStars && ep.isDoubleWin && ep.top2 && ep.top2.find(t => t.name === q))
                        || (ep.isAllStars && ep.lipSyncWinner === q);
                    const isTop2 = (ep.isAllStars && ep.lipSyncLoser === q);
                    if (isWin) currentPoints += 2.5;
                    else if (isTop2) currentPoints += 2.25;
                    else currentPoints += 0;
                    episodesParticipated++;
                    isEliminatedAlready = true;
                    if (elimEpisode === null) elimEpisode = ep.episode;
                    return;
                }

                if (isBottomName(ep, q)) {
                    const isElim = isElimName(ep, q);
                    if (isElim) {
                        currentPoints += GAME_CONSTANTS.POINTS.ELIM;
                        episodesParticipated++;
                        isEliminatedAlready = true;
                        if (elimEpisode === null) elimEpisode = ep.episode;
                    } else {
                        currentPoints += GAME_CONSTANTS.POINTS.BTM;
                        episodesParticipated++;
                    }
                    return;
                }

                if (ep.isAllStars && ep.top2 && (ep.lipSyncWinner || ep.isDoubleWin)) {
                    const inBottom = ep.bottom.find(b => b.name === q);
                    if (inBottom) {
                        const isElim = Array.isArray(ep.eliminated) ? ep.eliminated.includes(q) : ep.eliminated === q;
                        if (isElim) {
                            currentPoints += GAME_CONSTANTS.POINTS.ELIM;
                            episodesParticipated++;
                            isEliminatedAlready = true;
                            if (elimEpisode === null) elimEpisode = ep.episode;
                        } else {
                            currentPoints += GAME_CONSTANTS.POINTS.BTM;
                            episodesParticipated++;
                        }
                        return;
                    }
                    if (ep.isDoubleWin && ep.top2.find(t => t.name === q)) { currentPoints += GAME_CONSTANTS.POINTS.WIN; episodesParticipated++; }
                    else if (ep.lipSyncWinner === q) { currentPoints += GAME_CONSTANTS.POINTS.WIN; episodesParticipated++; }
                    else if (ep.lipSyncLoser === q) { currentPoints += GAME_CONSTANTS.POINTS.TOP2; episodesParticipated++; }
                    else if (ep.high.find(h => h.name === q)) { currentPoints += GAME_CONSTANTS.POINTS.HIGH; episodesParticipated++; }
                    else if (ep.highTeam && ep.highTeam.find(h => h.name === q)) { currentPoints += GAME_CONSTANTS.POINTS.HIGH; episodesParticipated++; }
                    else if (ep.safe.find(s => s.name === q)) { currentPoints += GAME_CONSTANTS.POINTS.SAFE; episodesParticipated++; }
                    else if (ep.low.find(l => l.name === q)) { currentPoints += GAME_CONSTANTS.POINTS.LOW; episodesParticipated++; }
                }
                else if (!ep.isAllStars && ep.isDoublePremiere && ep.top2 && ep.lipSyncWinner) {
                    const inBottom = ep.bottom.find(b => b.name === q);
                    if (inBottom) {
                        const isElim = Array.isArray(ep.eliminated) ? ep.eliminated.includes(q) : ep.eliminated === q;
                        if (isElim) {
                            currentPoints += GAME_CONSTANTS.POINTS.ELIM;
                            episodesParticipated++;
                            isEliminatedAlready = true;
                            if (elimEpisode === null) elimEpisode = ep.episode;
                        } else {
                            currentPoints += GAME_CONSTANTS.POINTS.BTM;
                            episodesParticipated++;
                        }
                        return;
                    }
                     if (ep.lipSyncWinner === q) { currentPoints += GAME_CONSTANTS.POINTS.WIN; episodesParticipated++; }
                    else if (ep.top2.find(t => t.name === q)) { currentPoints += GAME_CONSTANTS.POINTS.TOP2; episodesParticipated++; }
                    else if (ep.high.find(h => h.name === q)) { currentPoints += GAME_CONSTANTS.POINTS.HIGH; episodesParticipated++; }
                    else if (ep.highTeam && ep.highTeam.find(h => h.name === q)) { currentPoints += GAME_CONSTANTS.POINTS.HIGH; episodesParticipated++; }
                    else if (ep.safe.find(s => s.name === q)) { currentPoints += GAME_CONSTANTS.POINTS.SAFE; episodesParticipated++; }
                    else if (ep.low.find(l => l.name === q)) { currentPoints += GAME_CONSTANTS.POINTS.LOW; episodesParticipated++; }
                }
                else if (ep.winners.find(w => w.name === q)) { currentPoints += GAME_CONSTANTS.POINTS.WIN; episodesParticipated++; }
                else if (ep.high.find(h => h.name === q)) { currentPoints += GAME_CONSTANTS.POINTS.HIGH; episodesParticipated++; }
                else if (ep.highTeam && ep.highTeam.find(h => h.name === q)) { currentPoints += GAME_CONSTANTS.POINTS.HIGH; episodesParticipated++; }
                else if (ep.safe.find(s => s.name === q)) { currentPoints += GAME_CONSTANTS.POINTS.SAFE; episodesParticipated++; }
                else if (ep.low.find(l => l.name === q)) { currentPoints += GAME_CONSTANTS.POINTS.LOW; episodesParticipated++; }
                else if (ep.isBeaverFormat && ep.beaverSaved === q) {
                    const isElim = isElimName(ep, q);
                    if (isElim) {
                        currentPoints += GAME_CONSTANTS.POINTS.ELIM;
                        episodesParticipated++;
                        isEliminatedAlready = true;
                        if (elimEpisode === null) elimEpisode = ep.episode;
                    } else {
                        currentPoints += GAME_CONSTANTS.POINTS.LOW;
                        episodesParticipated++;
                    }
                }
            });

            const ppe = episodesParticipated > 0 ? (currentPoints / episodesParticipated) : 0;
            
            return {
                name: q,
                ppe: ppe,
                totalPoints: currentPoints,
                isEliminated: isEliminatedAlready,
                elimEpisode: elimEpisode
            };
        });


        const visibleRegular = visibleEpisodes.filter(e => !e.isFinale);
        const lastVisibleIsFinale = visibleEpisodes.length && visibleEpisodes[visibleEpisodes.length - 1].isFinale;
        const refEp = visibleRegular.length ? visibleRegular[visibleRegular.length - 1] : null;

        function getPlacementRankInEpisode(ep, queenName) {
            if (!ep || ep.isFinale) return 99;
            if (Array.isArray(ep.bracketEliminated) && ep.bracketEliminated.includes(queenName)) return 5;
            if (ep.isAllStars && ep.isDoubleWin && ep.top2.find(t => t.name === queenName)) return 0;
            if (ep.isAllStars && ep.lipSyncWinner === queenName) return 0;
            if (ep.isAllStars && ep.lipSyncLoser === queenName) return 0.5;
            if (ep.winners.find(w => w.name === queenName)) return 0;
            if (!ep.isAllStars && ep.isDoublePremiere && ep.top2 && ep.top2.find(t => t.name === queenName)) return 0.5;
            if (isBottomName(ep, queenName)) {
                const isElim = isElimName(ep, queenName);
                return isElim ? 5 : 4;
            }
            if (ep.high.find(h => h.name === queenName)) return 1;
            if (ep.highTeam && ep.highTeam.find(h => h.name === queenName)) return 1;
            if (ep.safe.find(s => s.name === queenName)) return 2;
            if (ep.low.find(l => l.name === queenName)) return 3;
            if (ep.isBeaverFormat && ep.beaverSaved === queenName) return 3;
            return 99; 
        }

        tableData.sort((a, b) => {
            const aName = a.name;
            const bName = b.name;
            const aElimEp = a.elimEpisode === null ? Infinity : a.elimEpisode;
            const bElimEp = b.elimEpisode === null ? Infinity : b.elimEpisode;

            if (lastVisibleIsFinale) {
                const finaleEpisode = currentSeasonData.episodes.find(e => e.isFinale);
                

                if (finaleEpisode && (finaleEpisode.isCrownFinale || (finaleEpisode.isTournamentFinale && (finaleEpisode.lostRound1 || finaleEpisode.lostRound2 || finaleEpisode.lostRound3)))) {
                    const lost1 = new Set(Array.isArray(finaleEpisode.lostRound1) ? finaleEpisode.lostRound1 : []);
                    const lost2 = new Set(Array.isArray(finaleEpisode.lostRound2) ? finaleEpisode.lostRound2 : []);
                    const lost3 = new Set(Array.isArray(finaleEpisode.lostRound3) ? finaleEpisode.lostRound3 : []);
                    
                    const aIsWinner = currentSeasonData.winner === aName;
                    const bIsWinner = currentSeasonData.winner === bName;
                    const aIsLost3 = !aIsWinner && lost3.has(aName);
                    const bIsLost3 = !bIsWinner && lost3.has(bName);
                    const aIsLost2 = !aIsWinner && !aIsLost3 && lost2.has(aName);
                    const bIsLost2 = !bIsWinner && !bIsLost3 && lost2.has(bName);
                    const aIsLost1 = !aIsWinner && !aIsLost3 && !aIsLost2 && lost1.has(aName);
                    const bIsLost1 = !bIsWinner && !bIsLost3 && !bIsLost2 && lost1.has(bName);
                    
                    let aCat = aIsWinner ? 0 : (aIsLost3 ? 1 : (aIsLost2 ? 2 : (aIsLost1 ? 3 : 4)));
                    let bCat = bIsWinner ? 0 : (bIsLost3 ? 1 : (bIsLost2 ? 2 : (bIsLost1 ? 3 : 4)));
                    
                    if (aCat !== bCat) return aCat - bCat;
                    if (aCat === 4 && aElimEp !== bElimEp) return bElimEp - aElimEp;
                    return b.ppe - a.ppe;
                }

                const aIsWinner = currentSeasonData.winner === aName;
                const bIsWinner = currentSeasonData.winner === bName;
                const isAS = currentSeasonData.isAllStars && finaleEpisode && finaleEpisode.finalists;
                const aIsRunnerUp = !aIsWinner && (isAS ? finaleEpisode.finalists.includes(aName) : (finaleEpisode && finaleEpisode.finalLipSyncQueens && finaleEpisode.finalLipSyncQueens.includes(aName))) && aElimEp === Infinity;
                const bIsRunnerUp = !bIsWinner && (isAS ? finaleEpisode.finalists.includes(bName) : (finaleEpisode && finaleEpisode.finalLipSyncQueens && finaleEpisode.finalLipSyncQueens.includes(bName))) && bElimEp === Infinity;
                const aElimInFinale = finaleEpisode && finaleEpisode.eliminatedInFinale && finaleEpisode.eliminatedInFinale.includes(aName);
                const bElimInFinale = finaleEpisode && finaleEpisode.eliminatedInFinale && finaleEpisode.eliminatedInFinale.includes(bName);
                let aCat = aIsWinner ? 0 : (aIsRunnerUp ? 1 : (aElimInFinale ? 2 : 3));
                let bCat = bIsWinner ? 0 : (bIsRunnerUp ? 1 : (bElimInFinale ? 2 : 3));
                if (aCat !== bCat) return aCat - bCat;
                if (aCat === 3 && aElimEp !== bElimEp) return bElimEp - aElimEp;
                return b.ppe - a.ppe;
            }

            const aRank = getPlacementRankInEpisode(refEp, aName);
            const bRank = getPlacementRankInEpisode(refEp, bName);
            if (aRank !== bRank) return aRank - bRank;
            if (aRank === 99 && bRank === 99) return bElimEp - aElimEp; 
            return b.ppe - a.ppe;
        });

        return tableData;
    }

    function calculateQueenStats(currentSeasonData, maxEpisode) {
        const visibleEpisodes = currentSeasonData.episodes.filter(e => e.episode <= maxEpisode);
        
        const tableData = currentSeasonData.castQueens.map(q => {
            let currentPoints = 0;
            let episodesParticipated = 0;
            let isEliminatedAlready = false;
            let elimEpisode = null;

            visibleEpisodes.forEach(ep => {
                if (ep.isFinale) return;

                if (ep.returnedQueen === q) {
                    isEliminatedAlready = false;
                    elimEpisode = null;
                }

                const isBracketElim = Array.isArray(ep.bracketEliminated) && ep.bracketEliminated.includes(q);
                if (isBracketElim) {
                    const isWin = (ep.isAllStars && ep.isDoubleWin && ep.top2 && ep.top2.find(t => t.name === q))
                        || (ep.isAllStars && ep.lipSyncWinner === q);
                    const isTop2 = (ep.isAllStars && ep.lipSyncLoser === q);
                    if (isWin) currentPoints += 2.5;
                    else if (isTop2) currentPoints += 2.25;
                    else currentPoints += 0;
                    episodesParticipated++;
                    isEliminatedAlready = true;
                    if (elimEpisode === null) elimEpisode = ep.episode;
                    return;
                }

                if (ep.isAllStars && ep.top2 && (ep.lipSyncWinner || ep.isDoubleWin)) {
                    const inBottom = ep.bottom.find(b => b.name === q);
                    if (inBottom) {
                        const isElim = Array.isArray(ep.eliminated) ? ep.eliminated.includes(q) : ep.eliminated === q;
                        if (isElim) {
                            currentPoints += GAME_CONSTANTS.POINTS.ELIM;
                            episodesParticipated++;
                            isEliminatedAlready = true;
                            if (elimEpisode === null) elimEpisode = ep.episode;
                        } else {
                            currentPoints += GAME_CONSTANTS.POINTS.BTM;
                            episodesParticipated++;
                        }
                        return;
                    }
                    if (ep.isDoubleWin && ep.top2.find(t => t.name === q)) { currentPoints += GAME_CONSTANTS.POINTS.WIN; episodesParticipated++; }
                    else if (ep.lipSyncWinner === q) { currentPoints += GAME_CONSTANTS.POINTS.WIN; episodesParticipated++; }
                    else if (ep.lipSyncLoser === q) { currentPoints += GAME_CONSTANTS.POINTS.TOP2; episodesParticipated++; }
                    else if (ep.high.find(h => h.name === q)) { currentPoints += GAME_CONSTANTS.POINTS.HIGH; episodesParticipated++; }
                    else if (ep.highTeam && ep.highTeam.find(h => h.name === q)) { currentPoints += GAME_CONSTANTS.POINTS.HIGH; episodesParticipated++; }
                    else if (ep.safe.find(s => s.name === q)) { currentPoints += GAME_CONSTANTS.POINTS.SAFE; episodesParticipated++; }
                    else if (ep.low.find(l => l.name === q)) { currentPoints += GAME_CONSTANTS.POINTS.LOW; episodesParticipated++; }
                }
                else if (!ep.isAllStars && ep.isDoublePremiere && ep.top2 && ep.lipSyncWinner) {
                    const inBottom = ep.bottom.find(b => b.name === q);
                    if (inBottom) {
                        const isElim = Array.isArray(ep.eliminated) ? ep.eliminated.includes(q) : ep.eliminated === q;
                        if (isElim) {
                            currentPoints += GAME_CONSTANTS.POINTS.ELIM;
                            episodesParticipated++;
                            isEliminatedAlready = true;
                            if (elimEpisode === null) elimEpisode = ep.episode;
                        } else {
                            currentPoints += GAME_CONSTANTS.POINTS.BTM;
                            episodesParticipated++;
                        }
                        return;
                    }
                     if (ep.lipSyncWinner === q) { currentPoints += GAME_CONSTANTS.POINTS.WIN; episodesParticipated++; }
                    else if (ep.top2.find(t => t.name === q)) { currentPoints += GAME_CONSTANTS.POINTS.TOP2; episodesParticipated++; }
                    else if (ep.high.find(h => h.name === q)) { currentPoints += GAME_CONSTANTS.POINTS.HIGH; episodesParticipated++; }
                    else if (ep.highTeam && ep.highTeam.find(h => h.name === q)) { currentPoints += GAME_CONSTANTS.POINTS.HIGH; episodesParticipated++; }
                    else if (ep.safe.find(s => s.name === q)) { currentPoints += GAME_CONSTANTS.POINTS.SAFE; episodesParticipated++; }
                    else if (ep.low.find(l => l.name === q)) { currentPoints += GAME_CONSTANTS.POINTS.LOW; episodesParticipated++; }
                }
                else if (ep.winners.find(w => w.name === q)) { currentPoints += GAME_CONSTANTS.POINTS.WIN; episodesParticipated++; }
                else if (ep.bottom.find(b => b.name === q)) {
                    const isElim = Array.isArray(ep.eliminated) ? ep.eliminated.includes(q) : ep.eliminated === q;
                    if (isElim) {
                        currentPoints += GAME_CONSTANTS.POINTS.ELIM;
                        episodesParticipated++;
                        isEliminatedAlready = true;
                        if (elimEpisode === null) elimEpisode = ep.episode;
                    } else {
                        currentPoints += GAME_CONSTANTS.POINTS.BTM;
                        episodesParticipated++;
                    }
                }
                else if (ep.high.find(h => h.name === q)) { currentPoints += GAME_CONSTANTS.POINTS.HIGH; episodesParticipated++; }
                else if (ep.highTeam && ep.highTeam.find(h => h.name === q)) { currentPoints += GAME_CONSTANTS.POINTS.HIGH; episodesParticipated++; }
                else if (ep.safe.find(s => s.name === q)) { currentPoints += GAME_CONSTANTS.POINTS.SAFE; episodesParticipated++; }
                else if (ep.low.find(l => l.name === q)) { currentPoints += GAME_CONSTANTS.POINTS.LOW; episodesParticipated++; }
                else if (ep.isBeaverFormat && ep.beaverSaved === q) {
                    const isElim = Array.isArray(ep.eliminated) ? ep.eliminated.includes(q) : ep.eliminated === q;
                    if (isElim) {
                        currentPoints += GAME_CONSTANTS.POINTS.ELIM;
                        episodesParticipated++;
                        isEliminatedAlready = true;
                        if (elimEpisode === null) elimEpisode = ep.episode;
                    } else {
                        currentPoints += GAME_CONSTANTS.POINTS.LOW;
                        episodesParticipated++;
                    }
                }
            });

            const ppe = episodesParticipated > 0 ? (currentPoints / episodesParticipated) : 0;
            
            return {
                name: q,
                ppe: ppe,
                totalPoints: currentPoints,
                isEliminated: isEliminatedAlready,
                elimEpisode: elimEpisode
            };
        });

        const visibleRegular = visibleEpisodes.filter(e => !e.isFinale);
        const lastVisibleIsFinale = visibleEpisodes.length && visibleEpisodes[visibleEpisodes.length - 1].isFinale;
        const refEp = visibleRegular.length ? visibleRegular[visibleRegular.length - 1] : null;

        function getPlacementRankInEpisode(ep, queenName) {
            if (!ep || ep.isFinale) return 99;
            if (Array.isArray(ep.bracketEliminated) && ep.bracketEliminated.includes(queenName)) return 5;
            if (ep.isAllStars && ep.isDoubleWin && ep.top2.find(t => t.name === queenName)) return 0;
            if (ep.isAllStars && ep.lipSyncWinner === queenName) return 0;
            if (ep.isAllStars && ep.lipSyncLoser === queenName) return 0.5;
            if (ep.winners.find(w => w.name === queenName)) return 0;
            if (!ep.isAllStars && ep.isDoublePremiere && ep.top2 && ep.top2.find(t => t.name === queenName)) return 0.5;
            if (ep.high.find(h => h.name === queenName)) return 1;
            if (ep.highTeam && ep.highTeam.find(h => h.name === queenName)) return 1;
            if (ep.safe.find(s => s.name === queenName)) return 2;
            if (ep.low.find(l => l.name === queenName)) return 3;
            if (ep.bottom.find(b => b.name === queenName)) {
                return ep.eliminated === queenName ? 5 : 4; 
            }
            if (ep.isBeaverFormat && ep.beaverSaved === queenName) return 3;
            return 99; 
        }

        tableData.sort((a, b) => {
            const aName = a.name;
            const bName = b.name;
            const aElimEp = a.elimEpisode === null ? Infinity : a.elimEpisode;
            const bElimEp = b.elimEpisode === null ? Infinity : b.elimEpisode;

            if (lastVisibleIsFinale) {
                const finaleEpisode = currentSeasonData.episodes.find(e => e.isFinale);
                
                if (finaleEpisode && (finaleEpisode.isCrownFinale || (finaleEpisode.isTournamentFinale && (finaleEpisode.lostRound1 || finaleEpisode.lostRound2 || finaleEpisode.lostRound3)))) {
                    const lost1 = new Set(Array.isArray(finaleEpisode.lostRound1) ? finaleEpisode.lostRound1 : []);
                    const lost2 = new Set(Array.isArray(finaleEpisode.lostRound2) ? finaleEpisode.lostRound2 : []);
                    const lost3 = new Set(Array.isArray(finaleEpisode.lostRound3) ? finaleEpisode.lostRound3 : []);
                    
                    const aIsWinner = currentSeasonData.winner === aName;
                    const bIsWinner = currentSeasonData.winner === bName;
                    const aIsLost3 = !aIsWinner && lost3.has(aName);
                    const bIsLost3 = !bIsWinner && lost3.has(bName);
                    const aIsLost2 = !aIsWinner && !aIsLost3 && lost2.has(aName);
                    const bIsLost2 = !bIsWinner && !bIsLost3 && lost2.has(bName);
                    const aIsLost1 = !aIsWinner && !aIsLost3 && !aIsLost2 && lost1.has(aName);
                    const bIsLost1 = !bIsWinner && !bIsLost3 && !bIsLost2 && lost1.has(bName);
                    
                    let aCat = aIsWinner ? 0 : (aIsLost3 ? 1 : (aIsLost2 ? 2 : (aIsLost1 ? 3 : 4)));
                    let bCat = bIsWinner ? 0 : (bIsLost3 ? 1 : (bIsLost2 ? 2 : (bIsLost1 ? 3 : 4)));
                    
                    if (aCat !== bCat) return aCat - bCat;
                    if (aCat === 4 && aElimEp !== bElimEp) return bElimEp - aElimEp;
                    return b.ppe - a.ppe;
                }

                const aIsWinner = currentSeasonData.winner === aName;
                const bIsWinner = currentSeasonData.winner === bName;
                const isAS = currentSeasonData.isAllStars && finaleEpisode && finaleEpisode.finalists;
                const aIsRunnerUp = !aIsWinner && (isAS ? finaleEpisode.finalists.includes(aName) : (finaleEpisode && finaleEpisode.finalLipSyncQueens && finaleEpisode.finalLipSyncQueens.includes(aName))) && aElimEp === Infinity;
                const bIsRunnerUp = !bIsWinner && (isAS ? finaleEpisode.finalists.includes(bName) : (finaleEpisode && finaleEpisode.finalLipSyncQueens && finaleEpisode.finalLipSyncQueens.includes(bName))) && bElimEp === Infinity;
                const aElimInFinale = finaleEpisode && finaleEpisode.eliminatedInFinale && finaleEpisode.eliminatedInFinale.includes(aName);
                const bElimInFinale = finaleEpisode && finaleEpisode.eliminatedInFinale && finaleEpisode.eliminatedInFinale.includes(bName);
                let aCat = aIsWinner ? 0 : (aIsRunnerUp ? 1 : (aElimInFinale ? 2 : 3));
                let bCat = bIsWinner ? 0 : (bIsRunnerUp ? 1 : (bElimInFinale ? 2 : 3));
                if (aCat !== bCat) return aCat - bCat;
                if (aCat === 3 && aElimEp !== bElimEp) return bElimEp - aElimEp;
                return b.ppe - a.ppe;
            }

            const aRank = getPlacementRankInEpisode(refEp, aName);
            const bRank = getPlacementRankInEpisode(refEp, bName);
            if (aRank !== bRank) return aRank - bRank;
            if (aRank === 99 && bRank === 99) return bElimEp - aElimEp; 
            return b.ppe - a.ppe;
        });

        return tableData;
    }

    function calculateQueenStats(currentSeasonData, maxEpisode) {
        const visibleEpisodes = currentSeasonData.episodes.filter(e => e.episode <= maxEpisode);
        
        const tableData = currentSeasonData.castQueens.map(q => {
            let currentPoints = 0;
            let episodesParticipated = 0;
            let isEliminatedAlready = false;
            let elimEpisode = null;

            visibleEpisodes.forEach(ep => {
                if (ep.isFinale) return;

                if (ep.returnedQueen === q) {
                    isEliminatedAlready = false;
                    elimEpisode = null;
                }

                const isBracketElim = Array.isArray(ep.bracketEliminated) && ep.bracketEliminated.includes(q);
                if (isBracketElim) {
                    const isWin = (ep.isAllStars && ep.isDoubleWin && ep.top2 && ep.top2.find(t => t.name === q))
                        || (ep.isAllStars && ep.lipSyncWinner === q);
                    const isTop2 = (ep.isAllStars && ep.lipSyncLoser === q);
                    if (isWin) currentPoints += 2.5;
                    else if (isTop2) currentPoints += 2.25;
                    else currentPoints += 0;
                    episodesParticipated++;
                    isEliminatedAlready = true;
                    if (elimEpisode === null) elimEpisode = ep.episode;
                    return;
                }

                if (ep.isAllStars && ep.top2 && (ep.lipSyncWinner || ep.isDoubleWin)) {
                    if (ep.isDoubleWin && ep.top2.find(t => t.name === q)) { currentPoints += GAME_CONSTANTS.POINTS.WIN; episodesParticipated++; }
                    else if (ep.lipSyncWinner === q) { currentPoints += GAME_CONSTANTS.POINTS.WIN; episodesParticipated++; }
                    else if (ep.lipSyncLoser === q) { currentPoints += GAME_CONSTANTS.POINTS.TOP2; episodesParticipated++; }
                    else if (ep.high.find(h => h.name === q)) { currentPoints += GAME_CONSTANTS.POINTS.HIGH; episodesParticipated++; }
                    else if (ep.highTeam && ep.highTeam.find(h => h.name === q)) { currentPoints += GAME_CONSTANTS.POINTS.HIGH; episodesParticipated++; }
                    else if (ep.safe.find(s => s.name === q)) { currentPoints += GAME_CONSTANTS.POINTS.SAFE; episodesParticipated++; }
                    else if (ep.low.find(l => l.name === q)) { currentPoints += GAME_CONSTANTS.POINTS.LOW; episodesParticipated++; }
                    else if (ep.bottom.find(b => b.name === q)) {
                        const isElim = Array.isArray(ep.eliminated) ? ep.eliminated.includes(q) : ep.eliminated === q;
                        if (isElim) {
                            currentPoints += GAME_CONSTANTS.POINTS.ELIM;
                            episodesParticipated++;
                            isEliminatedAlready = true;
                            if (elimEpisode === null) elimEpisode = ep.episode;
                        } else {
                            currentPoints += GAME_CONSTANTS.POINTS.BTM;
                            episodesParticipated++;
                        }
                    }
                }
                else if (!ep.isAllStars && ep.isDoublePremiere && ep.top2 && ep.lipSyncWinner) {
                     if (ep.lipSyncWinner === q) { currentPoints += GAME_CONSTANTS.POINTS.WIN; episodesParticipated++; }
                    else if (ep.top2.find(t => t.name === q)) { currentPoints += GAME_CONSTANTS.POINTS.TOP2; episodesParticipated++; }
                    else if (ep.high.find(h => h.name === q)) { currentPoints += GAME_CONSTANTS.POINTS.HIGH; episodesParticipated++; }
                    else if (ep.highTeam && ep.highTeam.find(h => h.name === q)) { currentPoints += GAME_CONSTANTS.POINTS.HIGH; episodesParticipated++; }
                    else if (ep.safe.find(s => s.name === q)) { currentPoints += GAME_CONSTANTS.POINTS.SAFE; episodesParticipated++; }
                    else if (ep.low.find(l => l.name === q)) { currentPoints += GAME_CONSTANTS.POINTS.LOW; episodesParticipated++; }
                    else if (ep.bottom.find(b => b.name === q)) {
                        currentPoints += GAME_CONSTANTS.POINTS.BTM;
                        episodesParticipated++;
                    }
                }
                else if (ep.winners.find(w => w.name === q)) { currentPoints += GAME_CONSTANTS.POINTS.WIN; episodesParticipated++; }
                else if (ep.high.find(h => h.name === q)) { currentPoints += GAME_CONSTANTS.POINTS.HIGH; episodesParticipated++; }
                else if (ep.highTeam && ep.highTeam.find(h => h.name === q)) { currentPoints += GAME_CONSTANTS.POINTS.HIGH; episodesParticipated++; }
                else if (ep.safe.find(s => s.name === q)) { currentPoints += GAME_CONSTANTS.POINTS.SAFE; episodesParticipated++; }
                else if (ep.low.find(l => l.name === q)) { currentPoints += GAME_CONSTANTS.POINTS.LOW; episodesParticipated++; }
                else if (ep.isBeaverFormat && ep.beaverSaved === q) {
                    const isElim = ep.eliminated === q;
                    if (isElim) {
                        currentPoints += GAME_CONSTANTS.POINTS.ELIM;
                        episodesParticipated++;
                        isEliminatedAlready = true;
                        if (elimEpisode === null) elimEpisode = ep.episode;
                    } else {
                        currentPoints += GAME_CONSTANTS.POINTS.LOW;
                        episodesParticipated++;
                    }
                }
                else if (ep.bottom.find(b => b.name === q)) {
                    const isElim = ep.eliminated === q;
                    if (isElim) {
                        currentPoints += GAME_CONSTANTS.POINTS.ELIM;
                        episodesParticipated++;
                        isEliminatedAlready = true;
                        if (elimEpisode === null) elimEpisode = ep.episode;
                    } else {
                        currentPoints += GAME_CONSTANTS.POINTS.BTM;
                        episodesParticipated++;
                    }
                }
            });

            const ppe = episodesParticipated > 0 ? (currentPoints / episodesParticipated) : 0;
            
            return {
                name: q,
                ppe: ppe,
                totalPoints: currentPoints,
                isEliminated: isEliminatedAlready,
                elimEpisode: elimEpisode
            };
        });

        const visibleRegular = visibleEpisodes.filter(e => !e.isFinale);
        const lastVisibleIsFinale = visibleEpisodes.length && visibleEpisodes[visibleEpisodes.length - 1].isFinale;
        const refEp = visibleRegular.length ? visibleRegular[visibleRegular.length - 1] : null;

        function getPlacementRankInEpisode(ep, queenName) {
            if (!ep || ep.isFinale) return 99;
            if (Array.isArray(ep.bracketEliminated) && ep.bracketEliminated.includes(queenName)) return 5;
            if (ep.isAllStars && ep.isDoubleWin && ep.top2.find(t => t.name === queenName)) return 0;
            if (ep.isAllStars && ep.lipSyncWinner === queenName) return 0;
            if (ep.isAllStars && ep.lipSyncLoser === queenName) return 0.5;
            if (ep.winners.find(w => w.name === queenName)) return 0;
            if (!ep.isAllStars && ep.isDoublePremiere && ep.top2 && ep.top2.find(t => t.name === queenName)) return 0.5;
            if (ep.high.find(h => h.name === queenName)) return 1;
            if (ep.highTeam && ep.highTeam.find(h => h.name === queenName)) return 1;
            if (ep.safe.find(s => s.name === queenName)) return 2;
            if (ep.low.find(l => l.name === queenName)) return 3;
            if (ep.bottom.find(b => b.name === queenName)) {
                return ep.eliminated === queenName ? 5 : 4; 
            }
            if (ep.isBeaverFormat && ep.beaverSaved === queenName) return 3;
            return 99; 
        }

        tableData.sort((a, b) => {
            const aName = a.name;
            const bName = b.name;
            const aElimEp = a.elimEpisode === null ? Infinity : a.elimEpisode;
            const bElimEp = b.elimEpisode === null ? Infinity : b.elimEpisode;

            if (lastVisibleIsFinale) {
                const finaleEpisode = currentSeasonData.episodes.find(e => e.isFinale);
                
                if (finaleEpisode && (finaleEpisode.isCrownFinale || (finaleEpisode.isTournamentFinale && (finaleEpisode.lostRound1 || finaleEpisode.lostRound2 || finaleEpisode.lostRound3)))) {
                    const lost1 = new Set(Array.isArray(finaleEpisode.lostRound1) ? finaleEpisode.lostRound1 : []);
                    const lost2 = new Set(Array.isArray(finaleEpisode.lostRound2) ? finaleEpisode.lostRound2 : []);
                    const lost3 = new Set(Array.isArray(finaleEpisode.lostRound3) ? finaleEpisode.lostRound3 : []);
                    
                    const aIsWinner = currentSeasonData.winner === aName;
                    const bIsWinner = currentSeasonData.winner === bName;
                    const aIsLost3 = !aIsWinner && lost3.has(aName);
                    const bIsLost3 = !bIsWinner && lost3.has(bName);
                    const aIsLost2 = !aIsWinner && !aIsLost3 && lost2.has(aName);
                    const bIsLost2 = !bIsWinner && !bIsLost3 && lost2.has(bName);
                    const aIsLost1 = !aIsWinner && !aIsLost3 && !aIsLost2 && lost1.has(aName);
                    const bIsLost1 = !bIsWinner && !bIsLost3 && !bIsLost2 && lost1.has(bName);
                    
                    let aCat = aIsWinner ? 0 : (aIsLost3 ? 1 : (aIsLost2 ? 2 : (aIsLost1 ? 3 : 4)));
                    let bCat = bIsWinner ? 0 : (bIsLost3 ? 1 : (bIsLost2 ? 2 : (bIsLost1 ? 3 : 4)));
                    
                    if (aCat !== bCat) return aCat - bCat;
                    if (aCat === 4 && aElimEp !== bElimEp) return bElimEp - aElimEp;
                    return b.ppe - a.ppe;
                }

                const aIsWinner = currentSeasonData.winner === aName;
                const bIsWinner = currentSeasonData.winner === bName;
                const isAS = currentSeasonData.isAllStars && finaleEpisode && finaleEpisode.finalists;
                const aIsRunnerUp = !aIsWinner && (isAS ? finaleEpisode.finalists.includes(aName) : (finaleEpisode && finaleEpisode.finalLipSyncQueens && finaleEpisode.finalLipSyncQueens.includes(aName))) && aElimEp === Infinity;
                const bIsRunnerUp = !bIsWinner && (isAS ? finaleEpisode.finalists.includes(bName) : (finaleEpisode && finaleEpisode.finalLipSyncQueens && finaleEpisode.finalLipSyncQueens.includes(bName))) && bElimEp === Infinity;
                const aElimInFinale = finaleEpisode && finaleEpisode.eliminatedInFinale && finaleEpisode.eliminatedInFinale.includes(aName);
                const bElimInFinale = finaleEpisode && finaleEpisode.eliminatedInFinale && finaleEpisode.eliminatedInFinale.includes(bName);
                let aCat = aIsWinner ? 0 : (aIsRunnerUp ? 1 : (aElimInFinale ? 2 : 3));
                let bCat = bIsWinner ? 0 : (bIsRunnerUp ? 1 : (bElimInFinale ? 2 : 3));
                if (aCat !== bCat) return aCat - bCat;
                if (aCat === 3 && aElimEp !== bElimEp) return bElimEp - aElimEp;
                return b.ppe - a.ppe;
            }

            const aRank = getPlacementRankInEpisode(refEp, aName);
            const bRank = getPlacementRankInEpisode(refEp, bName);
            if (aRank !== bRank) return aRank - bRank;
            if (aRank === 99 && bRank === 99) return bElimEp - aElimEp; 
            return b.ppe - a.ppe;
        });

        return tableData;
    }

    function renderTrackRecordTable(maxEpisode) {
        const table = document.getElementById('trackRecordTable');
        const showStarsColumn = !!(seasonData && seasonData.isTournament);
        
        const visibleEpisodes = seasonData.episodes.filter(e => e.episode <= maxEpisode);
        const lastVisibleIsFinale = visibleEpisodes.length && visibleEpisodes[visibleEpisodes.length - 1].isFinale;
        let tableData = calculateQueenStats(seasonData, maxEpisode);

        // --- POST-PROCESSING FORCE PPE RECALC ---
        // Double-check elim/btm status one last time for display
        tableData = tableData.map(row => {
            const q = row.name;
            let currentPoints = 0;
            let count = 0;
            let isEliminatedAlready = false;
            let elimEpisode = null;
            
            visibleEpisodes.forEach(ep => {
                if (ep.isFinale) return;
                
                if (ep.returnedQueen === q) {
                    isEliminatedAlready = false;
                    elimEpisode = null;
                }

                // Helpers
                const isNameMatch = (entry, name) => {
                    if (!entry) return false;
                    const entryName = entry.name || entry;
                    return entryName === name;
                };
                const isBottomName = (ep, name) => Array.isArray(ep.bottom) && ep.bottom.some(b => isNameMatch(b, name));
                const isElimName = (ep, name) => {
                    if (!ep) return false;
                    if (Array.isArray(ep.eliminated)) return ep.eliminated.some(e => isNameMatch(e, name));
                    return isNameMatch(ep.eliminated, name);
                };

                if (isBottomName(ep, q)) {
                    const isElim = isElimName(ep, q);
                    if (isElim) {
                        currentPoints += 0;
                        isEliminatedAlready = true;
                        if (elimEpisode === null) elimEpisode = ep.episode;
                    } else {
                        currentPoints += 1;
                    }
                    count++;
                    return;
                }

                // If not bottom, check others
                const isBracketElim = Array.isArray(ep.bracketEliminated) && ep.bracketEliminated.includes(q);
                if (isBracketElim) {
                    const isWin = (ep.isAllStars && ep.isDoubleWin && ep.top2 && ep.top2.find(t => t.name === q))
                        || (ep.isAllStars && ep.lipSyncWinner === q);
                    const isTop2 = (ep.isAllStars && ep.lipSyncLoser === q);
                    if (isWin) currentPoints += 2.5;
                    else if (isTop2) currentPoints += 2.25;
                    else currentPoints += 0;
                    count++;
                    isEliminatedAlready = true;
                    if (elimEpisode === null) elimEpisode = ep.episode;
                    return;
                }

                if (ep.isAllStars && ep.top2 && (ep.lipSyncWinner || ep.isDoubleWin)) {
                    if (ep.isDoubleWin && ep.top2.find(t => t.name === q)) { currentPoints += 5; count++; }
                    else if (ep.lipSyncWinner === q) { currentPoints += 5; count++; }
                    else if (ep.lipSyncLoser === q) { currentPoints += 4.5; count++; }
                    else if (ep.high.find(h => h.name === q)) { currentPoints += 4; count++; }
                    else if (ep.highTeam && ep.highTeam.find(h => h.name === q)) { currentPoints += 4; count++; }
                    else if (ep.safe.find(s => s.name === q)) { currentPoints += 3; count++; }
                    else if (ep.low.find(l => l.name === q)) { currentPoints += 2; count++; }
                }
                else if (!ep.isAllStars && ep.isDoublePremiere && ep.top2 && ep.lipSyncWinner) {
                     if (ep.lipSyncWinner === q) { currentPoints += 5; count++; }
                    else if (ep.top2.find(t => t.name === q)) { currentPoints += 4.5; count++; }
                    else if (ep.high.find(h => h.name === q)) { currentPoints += 4; count++; }
                    else if (ep.highTeam && ep.highTeam.find(h => h.name === q)) { currentPoints += 4; count++; }
                    else if (ep.safe.find(s => s.name === q)) { currentPoints += 3; count++; }
                    else if (ep.low.find(l => l.name === q)) { currentPoints += 2; count++; }
                }
                else if (ep.winners.find(w => w.name === q)) { currentPoints += 5; count++; }
                else if (ep.high.find(h => h.name === q)) { currentPoints += 4; count++; }
                else if (ep.highTeam && ep.highTeam.find(h => h.name === q)) { currentPoints += 4; count++; }
                else if (ep.safe.find(s => s.name === q)) { currentPoints += 3; count++; }
                else if (ep.low.find(l => l.name === q)) { currentPoints += 2; count++; }
                else if (ep.isBeaverFormat && ep.beaverSaved === q) {
                    if (isElimName(ep, q)) {
                        currentPoints += 0;
                        isEliminatedAlready = true;
                        if (elimEpisode === null) elimEpisode = ep.episode;
                    } else {
                        currentPoints += 2;
                    }
                    count++;
                }
            });
            
            row.ppe = count > 0 ? (currentPoints / count) : 0;
            row.isEliminated = isEliminatedAlready;
            row.elimEpisode = elimEpisode;

            return row;
        });
        
        // --- RE-SORT AFTER PPE CHANGE ---
        // Reuse the same sort logic from calculateQueenStats but applied to the updated tableData
        const refEp = visibleEpisodes.length ? visibleEpisodes[visibleEpisodes.length - 1] : null;
        const getRank = (ep, qName) => {
            if (!ep || ep.isFinale) return 99;
            if (Array.isArray(ep.bracketEliminated) && ep.bracketEliminated.includes(qName)) return 5;
            if (ep.isAllStars && ep.isDoubleWin && ep.top2.find(t => t.name === qName)) return 0;
            if (ep.isAllStars && ep.lipSyncWinner === qName) return 0;
            if (ep.isAllStars && ep.lipSyncLoser === qName) return 0.5;
            if (ep.winners.find(w => w.name === qName)) return 0;
            if (!ep.isAllStars && ep.isDoublePremiere && ep.top2 && ep.top2.find(t => t.name === qName)) return 0.5;
            const isNameMatch = (entry, name) => {
                if (!entry) return false;
                const entryName = entry.name || entry;
                return entryName === name;
            };
            const isBottomName = (ep, name) => Array.isArray(ep.bottom) && ep.bottom.some(b => isNameMatch(b, name));
            const isElimName = (ep, name) => {
                if (!ep) return false;
                if (Array.isArray(ep.eliminated)) return ep.eliminated.some(e => isNameMatch(e, name));
                return isNameMatch(ep.eliminated, name);
            };

            if (isBottomName(ep, qName)) {
                return isElimName(ep, qName) ? 5 : 4;
            }
            if (ep.high.find(h => h.name === qName)) return 1;
            if (ep.highTeam && ep.highTeam.find(h => h.name === qName)) return 1;
            if (ep.safe.find(s => s.name === qName)) return 2;
            if (ep.low.find(l => l.name === qName)) return 3;
            if (ep.isBeaverFormat && ep.beaverSaved === qName) return 3;
            return 99; 
        };

        tableData.sort((a, b) => {
            const aName = a.name;
            const bName = b.name;
            const aElimEp = a.elimEpisode === null ? Infinity : a.elimEpisode;
            const bElimEp = b.elimEpisode === null ? Infinity : b.elimEpisode;
            
            if (lastVisibleIsFinale) {
                // Finale sort logic (simplified here as it mostly relies on category)
                 const finaleEpisode = seasonData.episodes.find(e => e.isFinale);

                 if (finaleEpisode && finaleEpisode.isCrownFinale) {
                    const lost1 = new Set(Array.isArray(finaleEpisode.lostRound1) ? finaleEpisode.lostRound1 : []);
                    const lost2 = new Set(Array.isArray(finaleEpisode.lostRound2) ? finaleEpisode.lostRound2 : []);
                    const lost3 = new Set(Array.isArray(finaleEpisode.lostRound3) ? finaleEpisode.lostRound3 : []);
                    const lost34 = new Set([...lost1, ...lost2]);
                    
                    const aIsWinner = seasonData.winner === aName;
                    const bIsWinner = seasonData.winner === bName;
                    
                    if (aIsWinner && !bIsWinner) return -1;
                    if (!aIsWinner && bIsWinner) return 1;
                    
                    const aIsRunnerUp = lost3.has(aName);
                    const bIsRunnerUp = lost3.has(bName);
                    if (aIsRunnerUp && !bIsRunnerUp) return -1;
                    if (!aIsRunnerUp && bIsRunnerUp) return 1;

                    const aIsLost2 = lost2.has(aName);
                    const bIsLost2 = lost2.has(bName);
                    if (aIsLost2 && !bIsLost2) return -1;
                    if (!aIsLost2 && bIsLost2) return 1;

                    const aIsLost1 = lost1.has(aName);
                    const bIsLost1 = lost1.has(bName);
                    if (aIsLost1 && !bIsLost1) return -1;
                    if (!aIsLost1 && bIsLost1) return 1;
                    
                    const aIsLost34 = lost34.has(aName);
                    const bIsLost34 = lost34.has(bName);
                    if (aIsLost34 && !bIsLost34) return -1;
                    if (!aIsLost34 && bIsLost34) return 1;
                 }

                 const aIsWinner = seasonData.winner === aName;
                 const bIsWinner = seasonData.winner === bName;
                 if (aIsWinner && !bIsWinner) return -1;
                 if (!aIsWinner && bIsWinner) return 1;
                 // Fallback for finale
                 if (aElimEp !== bElimEp) return bElimEp - aElimEp;
                 return b.ppe - a.ppe;
            }

            const aRank = getRank(refEp, aName);
            const bRank = getRank(refEp, bName);
            if (aRank !== bRank) return aRank - bRank;
            if (aRank === 99 && bRank === 99) return bElimEp - aElimEp; 
            return b.ppe - a.ppe;
        });
        // --- END POST-PROCESSING ---

        function trCell(status, cls) {
            const trMap = {
                'st-win': 'tr-win', 'st-dbl': 'tr-dbl', 'st-top2': 'tr-top2', 'st-high': 'tr-high', 'st-high-team': 'tr-high-team',
                'st-safe': 'tr-safe', 'st-low': 'tr-low', 'st-btm': 'tr-btm', 'st-shantay': 'tr-shantay',
                'st-elim': 'tr-elim', 'st-elim-finale': 'tr-elim-finale', 'st-runnerup': 'tr-runnerup',
                'st-lost1': 'tr-lost1', 'st-lost2': 'tr-lost2', 'st-lost3': 'tr-lost3',
                'st-winner-of-season': 'tr-winner-of-season', 'st-beaver': 'tr-beaver', 'st-misscon': 'tr-misscon'
            };
            const trCls = trMap[cls] || '';
            return trCls ? `<td class="${trCls}">${status}</td>` : `<td>${status}</td>`;
        }

        const eliminatedSorted = tableData
            .filter(r => r.isEliminated)
            .sort((a, b) => (a.elimEpisode || 0) - (b.elimEpisode || 0));
        const totalCast = seasonData.castQueens.length;
        const eliminatedRankMap = {};
        let i = 0;
        while (i < eliminatedSorted.length) {
            const epNum = eliminatedSorted[i].elimEpisode || 0;
            let j = i;
            while (j < eliminatedSorted.length && ((eliminatedSorted[j].elimEpisode || 0) === epNum)) j++;
            const group = eliminatedSorted.slice(i, j);
            const n = group.length;
            for (let k = 0; k < n; k++) {
                eliminatedRankMap[group[k].name] = totalCast - (i + (n - 1 - k));
            }
            i = j;
        }

        const isEliminatedInEpisode = (ep, name) => {
            if (!ep || ep.isFinale) return false;
            const isNameMatch = (entry, name) => {
                if (!entry) return false;
                const entryName = entry.name || entry;
                return entryName === name;
            };
            if (Array.isArray(ep.bracketEliminated) && ep.bracketEliminated.includes(name)) return true;
            if (Array.isArray(ep.eliminated)) return ep.eliminated.some(e => isNameMatch(e, name));
            return isNameMatch(ep.eliminated, name);
        };
        const returnEpisodeMap = {};
        visibleEpisodes.forEach(e => {
            if (!e || e.isFinale || !e.returnedQueen) return;
            const prev = returnEpisodeMap[e.returnedQueen];
            returnEpisodeMap[e.returnedQueen] = typeof prev === 'number' ? Math.max(prev, e.episode) : e.episode;
        });

        const bracketOutSet = new Set();
        visibleEpisodes.forEach(e => {
            if (e && Array.isArray(e.bracketEliminated)) e.bracketEliminated.forEach(q => bracketOutSet.add(q));
        });
        visibleEpisodes.forEach(e => {
            if (e && e.returnedQueen) bracketOutSet.delete(e.returnedQueen);
        });
        const bracketOutCount = tableData.filter(r => bracketOutSet.has(r.name)).length;

        const rankInfo = [];
        if (lastVisibleIsFinale) {
            const finaleEpisode = seasonData.episodes.find(e => e.isFinale);
            const isCrownLsftc = !!(finaleEpisode && finaleEpisode.isCrownFinale && (finaleEpisode.lostRound1 || finaleEpisode.lostRound2 || finaleEpisode.lostRound3));
            const isTournamentLalaparuza = !!(finaleEpisode && finaleEpisode.isTournamentFinale && (finaleEpisode.lostRound1 || finaleEpisode.lostRound2 || finaleEpisode.lostRound3));
            const runnerUps = isTournamentLalaparuza
                ? []
                : (finaleEpisode ? (finaleEpisode.runnerUps || (finaleEpisode.finalists || finaleEpisode.finalLipSyncQueens || []).filter(n => n !== seasonData.winner)) : []);
            const eliminatedInFinale = isTournamentLalaparuza
                ? []
                : ((finaleEpisode && finaleEpisode.eliminatedInFinale) ? finaleEpisode.eliminatedInFinale : []);
            const lost3 = isTournamentLalaparuza ? (Array.isArray(finaleEpisode.lostRound3) ? finaleEpisode.lostRound3 : []) : [];
            const lost2 = isTournamentLalaparuza ? (Array.isArray(finaleEpisode.lostRound2) ? finaleEpisode.lostRound2 : []) : [];
            const lost1 = isTournamentLalaparuza ? (Array.isArray(finaleEpisode.lostRound1) ? finaleEpisode.lostRound1 : []) : [];
            const firstLost3Idx = isTournamentLalaparuza ? tableData.findIndex(r => lost3.includes(r.name)) : -1;
            const firstLost2Idx = isTournamentLalaparuza ? tableData.findIndex(r => lost2.includes(r.name)) : -1;
            const firstLost1Idx = isTournamentLalaparuza ? tableData.findIndex(r => lost1.includes(r.name)) : -1;
            const firstRunnerUpIdx = tableData.findIndex(r => runnerUps.includes(r.name));
            const firstElimInFinaleIdx = tableData.findIndex(r => eliminatedInFinale.includes(r.name));
            const firstBracketOutIdx = bracketOutCount ? tableData.findIndex(r => bracketOutSet.has(r.name)) : -1;
            if (isCrownLsftc) {
                const lost3Crown = Array.isArray(finaleEpisode.lostRound3) ? finaleEpisode.lostRound3 : [];
                const lost2Crown = Array.isArray(finaleEpisode.lostRound2) ? finaleEpisode.lostRound2 : [];
                const lost1Crown = Array.isArray(finaleEpisode.lostRound1) ? finaleEpisode.lostRound1 : [];
                const lost34Crown = [...lost2Crown, ...lost1Crown];
                const firstLost34Idx = lost34Crown.length ? tableData.findIndex(r => lost34Crown.includes(r.name)) : -1;
                tableData.forEach((row, idx) => {
                    const q = row.name;
                    if (q === seasonData.winner) {
                        rankInfo.push({ label: '1', rowspan: 1 });
                    } else if (lost3Crown.includes(q)) {
                        rankInfo.push({ label: '2', rowspan: 1 });
                    } else if (lost34Crown.includes(q)) {
                        if (idx === firstLost34Idx) rankInfo.push({ label: '3/4', rowspan: lost34Crown.length || 1 });
                        else rankInfo.push({ label: '', rowspan: 0 });
                    } else if (bracketOutCount && bracketOutSet.has(q)) {
                        if (idx === firstBracketOutIdx) rankInfo.push({ label: '11-18', rowspan: bracketOutCount });
                        else rankInfo.push({ label: '', rowspan: 0 });
                    } else {
                        rankInfo.push({ label: String(eliminatedRankMap[q] ?? (idx + 1)), rowspan: 1 });
                    }
                });
            } else {
                tableData.forEach((row, idx) => {
                    const q = row.name;
                    if (q === seasonData.winner) {
                        rankInfo.push({ label: '1', rowspan: 1 });
                    } else if (isTournamentLalaparuza && lost3.includes(q)) {
                        rankInfo.push({ label: '2', rowspan: 1 });
                    } else if (isTournamentLalaparuza && lost2.includes(q)) {
                        if (idx === firstLost2Idx) rankInfo.push({ label: '3/4', rowspan: lost2.length || 1 });
                        else rankInfo.push({ label: '', rowspan: 0 });
                    } else if (isTournamentLalaparuza && lost1.includes(q)) {
                        if (idx === firstLost1Idx) rankInfo.push({ label: '5-8', rowspan: lost1.length || 1 });
                        else rankInfo.push({ label: '', rowspan: 0 });
                    } else if (runnerUps.includes(q)) {
                        if (idx === firstRunnerUpIdx) {
                            const N = runnerUps.length;
                            const label = N === 1 ? '2' : (N === 2 ? '2/3' : '2/3/4');
                            rankInfo.push({ label, rowspan: N });
                        } else {
                            rankInfo.push({ label: '', rowspan: 0 });
                        }
                    } else if (eliminatedInFinale.includes(q)) {
                        if (idx === firstElimInFinaleIdx) {
                            const M = eliminatedInFinale.length;
                            const placeStart = 2 + runnerUps.length;
                            const label = M === 1 ? String(placeStart) : Array.from({ length: M }, (_, i) => placeStart + i).join('/');
                            rankInfo.push({ label, rowspan: M });
                        } else {
                            rankInfo.push({ label: '', rowspan: 0 });
                        }
                    } else if (bracketOutCount && bracketOutSet.has(q)) {
                        if (idx === firstBracketOutIdx) rankInfo.push({ label: '11-18', rowspan: bracketOutCount });
                        else rankInfo.push({ label: '', rowspan: 0 });
                    } else {
                        rankInfo.push({ label: String(eliminatedRankMap[q] ?? (idx + 1)), rowspan: 1 });
                    }
                });
            }
        } else {
            tableData.forEach((row, idx) => {
                const q = row.name;
                const returnEp = returnEpisodeMap[q];
                const hasReturn = Number.isFinite(returnEp);
                const eliminatedAfterReturn = hasReturn
                    ? visibleEpisodes.some(e => isEliminatedInEpisode(e, q) && e.episode >= returnEp)
                    : false;
                const label = row.isEliminated ? (eliminatedRankMap[q] ?? (idx + 1)) : 'TBA';
                rankInfo.push({ label: String(label), rowspan: 1 });
            });
        }

        // --- CLEANUP DUPLICATE calculateQueenStats ---
        // This is a safety measure to remove the extra definitions found by grep
        // (Actually, since SearchReplace only replaces the FIRST occurrence, 
        // and we have multiple, it's better to just fix the logic in the active one first.)

        const starsByQueen = {};
        visibleEpisodes.forEach(e => {
            if (!e || e.isFinale) return;
            const isGroupStage = !!(e.isTournament && typeof e.tournamentStage === 'string' && e.tournamentStage.startsWith('Bracket'));
            if (!isGroupStage) return;

            const top2 = Array.isArray(e.top2) ? e.top2 : [];
            const top2Names = top2.map(t => t && t.name ? t.name : null).filter(Boolean);
            top2Names.forEach(name => {
                starsByQueen[name] = (starsByQueen[name] || 0) + 2;
            });
            if (e.lipSyncWinner) {
                starsByQueen[e.lipSyncWinner] = (starsByQueen[e.lipSyncWinner] || 0) + 1;
            }
            const gifts = Array.isArray(e.pointGifts) ? e.pointGifts : [];
            gifts.forEach(g => {
                if (!g || !g.to) return;
                starsByQueen[g.to] = (starsByQueen[g.to] || 0) + 1;
            });
        });

        const colWidths = { rank: 44, contestant: 130, photo: 52, ep: 72, finale: 82, ppe: 60, stars: 52 };
        const epCols = visibleEpisodes
            .map(e => `<col style="width:${(e && e.isFinale) ? colWidths.finale : colWidths.ep}px">`)
            .join('');
        const hasFinale = visibleEpisodes.some(e => e.isFinale);
        const episodeHeadersRow1 = visibleEpisodes.map(e => e.isFinale ? `<th rowspan="2">Finale</th>` : `<th>Ep. ${e.episode}</th>`).join('');
        const episodeHeadersRow2 = visibleEpisodes.filter(e => !e.isFinale).map(e => `<th class="tr-sub">${e.displayChallenge || e.challenge || ''}</th>`).join('');
        let html = `
            <colgroup>
                <col style="width:${colWidths.rank}px">
                <col style="width:${colWidths.contestant}px">
                <col style="width:${colWidths.photo}px">
                ${epCols}
                <col style="width:${colWidths.ppe}px">
                ${showStarsColumn ? `<col style="width:${colWidths.stars}px">` : ''}
            </colgroup>
            <thead>
                <tr>
                    <th rowspan="2">Rank</th>
                    <th rowspan="2" class="text-left">Contestant</th>
                    <th rowspan="2">Photo</th>
                    ${episodeHeadersRow1}
                    <th rowspan="2">PPE Score</th>
                    ${showStarsColumn ? `<th rowspan="2">Stars</th>` : ''}
                </tr>
                <tr>
                    ${episodeHeadersRow2}
                </tr>
            </thead>
            <tbody>`;

        tableData.forEach((row, idx) => {
            const q = row.name;
            const ri = rankInfo[idx];
            const rankTd = ri.rowspan > 0
                ? (ri.rowspan === 1
                    ? `<td class="tr-rank">${ri.label}</td>`
                    : `<td class="tr-rank" rowspan="${ri.rowspan}">${ri.label}</td>`)
                : '';

            html += `
                <tr>
                    ${rankTd}
                    <td class="tr-contestant">${q}</td>
                    <td class="tr-photo"><img src="${queensDb[q] ? queensDb[q].photo : ''}" alt=""></td>
                    ${visibleEpisodes.map(e => {
                        if (e.isFinale) {
                            if (e.winners && e.winners.find(w => w.name === q)) return trCell('WINNER', 'st-winner-of-season');
                            if (!seasonData.isTournament && seasonData.missCongeniality === q) return trCell('MISS<br>CON', 'st-misscon');
                            if (e.lostRound3 && e.lostRound3.includes(q)) return trCell('LOST 3RD<br>ROUND', 'st-lost3');
                            if (e.lostRound2 && e.lostRound2.includes(q)) return trCell('LOST 2ND<br>ROUND', 'st-lost2');
                            if (e.lostRound1 && e.lostRound1.includes(q)) return trCell('LOST 1ST<br>ROUND', 'st-lost1');
                            if (seasonData.isAllStars && e.finalists && e.finalists.includes(q) && q !== seasonData.winner)
                                return trCell('RUNNER<br>UP', 'st-runnerup');
                            if (e.finalLipSyncQueens && e.finalLipSyncQueens.includes(q) && !(e.winners && e.winners.find(w => w.name === q)))
                                return trCell('RUNNER<br>UP', 'st-runnerup');
                            if (e.eliminatedInFinale && e.eliminatedInFinale.includes(q))
                                return trCell('ELIM', 'st-elim-finale');
                            return `<td class="tr-empty"></td>`;
                        }

                        let status = "";
                        let cls = "";
                        const inBottomDP = e.bottom && e.bottom.find(b => b.name === q);
                        if (inBottomDP) {
                            const isElim = Array.isArray(e.eliminated) ? e.eliminated.includes(q) : e.eliminated === q;
                            if (isElim) { status = "ELIM"; cls = "st-elim"; }
                            else {
                                const isBottom3 = e.isAllStars && e.bottom.length === 3;
                                status = isBottom3 ? "BTM3" : "BTM2";
                                cls = e.isDoubleShantay ? "st-shantay" : "st-btm";
                            }
                        }
                        else if (e.isAllStars && e.isDoubleWin && e.top2.find(t => t.name === q)) { status = "WIN"; cls = "st-dbl"; }
                        else if (e.isAllStars && e.lipSyncWinner === q) { status = "WIN"; cls = "st-win"; }
                        else if (e.isAllStars && e.lipSyncLoser === q) { status = "WIN"; cls = "st-top2"; }
                        else if (e.isTournament && e.top2 && e.lipSyncWinner) {
                            if (e.lipSyncWinner === q) { status = "WIN"; cls = "st-win"; }
                            else if (e.top2.find(t => t.name === q)) { status = "WIN"; cls = "st-top2"; }
                        }
                        else if (!e.isAllStars && e.isDoublePremiere && e.top2 && e.lipSyncWinner) {
                            if (e.lipSyncWinner === q) { status = "WIN"; cls = "st-win"; }
                            else if (e.top2.find(t => t.name === q)) { status = "TOP2"; cls = "st-top2"; }
                            else if (e.high.find(h => h.name === q)) { status = "HIGH"; cls = "st-high"; }
                            else if (e.safe.find(s => s.name === q)) { status = "SAFE"; cls = "st-safe"; }
                            else if (e.low.find(l => l.name === q)) { status = "LOW"; cls = "st-low"; }
                        }

                        if (!status && e.winners.find(w => w.name === q)) {
                            status = "WIN";
                            const isTeamWin = e.challenge === 'Girl Groups' && Array.isArray(e.groups) && e.groups.length > 0;
                            cls = (e.isDouble && !isTeamWin) ? "st-dbl" : "st-win";
                        }
                        else {
                            const inBottom = e.bottom && e.bottom.find(b => b.name === q);
                            if (inBottom) {
                                const isElim = Array.isArray(e.eliminated) ? e.eliminated.includes(q) : e.eliminated === q;
                                if (isElim) { status = "ELIM"; cls = "st-elim"; }
                                else {
                                    const isBottom3 = e.isAllStars && e.bottom.length === 3;
                                    status = isBottom3 ? "BTM3" : "BTM2";
                                    cls = e.isDoubleShantay ? "st-shantay" : "st-btm";
                                }
                            }
                        }
                        if (!status && e.high.find(h => h.name === q)) { status = "HIGH"; cls = "st-high"; }
                        else if (!status && e.highTeam && e.highTeam.find(h => h.name === q)) { status = "HIGH TEAM"; cls = "st-high-team"; }
                        else if (!status && e.safe.find(s => s.name === q)) { status = "SAFE"; cls = "st-safe"; }
                        else if (!status && e.low.find(l => l.name === q)) { 
                            status = "LOW"; 
                            cls = "st-low";
                            if (e.luckyQueenTwistData && e.luckyQueenTwistData.savedQueen === q) {
                                return `<td class="tr-low" style="border: 3px solid #ffed00 !important;">LOW</td>`;
                            }
                        }
                        else if (!status && e.isBeaverFormat && e.beaverSaved === q) { status = "BVR"; cls = "st-beaver"; }
                        else if (!status && e.bottom && e.bottom.find(b => b.name === q)) {
                            const isElim2 = Array.isArray(e.eliminated) ? e.eliminated.includes(q) : e.eliminated === q;
                            if (isElim2) { status = "ELIM"; cls = "st-elim"; }
                            else {
                                const isBottom3b = e.isAllStars && e.bottom.length === 3;
                                status = isBottom3b ? "BTM3" : "BTM2";
                                cls = e.isDoubleShantay ? "st-shantay" : "st-btm";
                            }
                        }

                        const isBracketElim = Array.isArray(e.bracketEliminated) && e.bracketEliminated.includes(q);
                        if (isBracketElim) {
                            if (status === "WIN") status = "WIN<br>+ELIM";
                            else if (status === "TOP2") status = "TOP2<br>+ELIM";
                            else status = "ELIM";
                            cls = "st-elim";
                        }

                        if (!status) {
                            if (isBracketElim) return trCell("ELIM", "st-elim");
                            return `<td class="tr-empty"></td>`;
                        }
                        return trCell(status, cls);
                    }).join('')}
                    <td class="tr-ppe">${row.ppe.toFixed(2)}</td>
                    ${showStarsColumn ? `<td class="tr-stars">${starsByQueen[q] || 0}</td>` : ''}
                </tr>`;
        });

        html += `</tbody>`;
        table.innerHTML = html;
        const totalWidth = colWidths.rank + colWidths.contestant + colWidths.photo + visibleEpisodes.length * colWidths.ep + colWidths.ppe + (showStarsColumn ? colWidths.stars : 0);
        table.style.width = totalWidth + 'px';
        table.style.minWidth = totalWidth + 'px';

        const lipstickContainer = document.getElementById('lipstickTableContainer');
        if (lipstickContainer) {
            const isBeaver = seasonData.episodes && seasonData.episodes.some(e => e.isBeaverFormat);
            if (seasonData.isAllStars || seasonData.isTournament) {
                renderLipstickTable(maxEpisode);
            } else if (isBeaver) {
                renderBeaverTable(maxEpisode);
            } else {
                lipstickContainer.classList.add('hidden');
            }
        }
    }

    function renderBeaverTable(maxEpisode) {
        const container = document.getElementById('lipstickTableContainer');
        const table = document.getElementById('lipstickTable');
        if (!container || !table) return;

        const episodes = seasonData.episodes.filter(e => !e.isFinale && e.episode <= maxEpisode && e.isBeaverFormat && e.beaverSaved);
        if (!episodes.length) { container.classList.add('hidden'); return; }
        
        container.classList.remove('hidden');
        const titleEl = container.querySelector('h3');
        if (titleEl) titleEl.innerText = 'Beaver History';

        let html = `
            <thead>
                <tr>
                    <th class="text-left">Ep</th>
                    <th>Winner</th>
                    <th>Saved</th>
                    <th>Up for Elimination</th>
                </tr>
            </thead>
            <tbody>`;
            
        episodes.forEach(ep => {
            const winnerName = (ep.winners && ep.winners[0]) ? (ep.winners[0].name || ep.winners[0]) : 'Unknown';
            const savedName = ep.beaverSaved || '-';
            const bottom3 = ep.beaverBottom3 || [];
            const upForElim = bottom3.filter(q => (q.name || q) !== savedName).map(q => q.name || q);
            
            html += `
                <tr>
                    <td class="font-bold text-gray-500">${ep.episode}</td>
                    <td>
                        <div class="flex items-center justify-center gap-2">
                            <img src="${queensDb[winnerName] ? queensDb[winnerName].photo : ''}" class="queen-img-sm" style="box-shadow: none;">
                            <span class="font-bold">${winnerName}</span>
                        </div>
                    </td>
                    <td>
                        <span class="font-bold text-amber-500">
                            ${savedName}
                        </span>
                    </td>
                    <td>
                        <div class="flex flex-col gap-1 items-center justify-center">
                            ${upForElim.map(name => `<span class="font-bold text-gray-600 text-xs">${name}</span>`).join('')}
                        </div>
                    </td>
                </tr>`;
        });
        html += `</tbody>`;
        table.innerHTML = html;
    }

    function renderLipstickTable(maxEpisode) {
        const container = document.getElementById('lipstickTableContainer');
        const table = document.getElementById('lipstickTable');
        if (!container || !table || !seasonData.isAllStars) return;

        if (seasonData.isTournament) {
            const titleEl = container.querySelector('h3');
            if (titleEl) titleEl.innerText = 'Bracket Points';
            const bracketEpisodes = seasonData.episodes
                .filter(e => e && !e.isFinale && e.episode <= maxEpisode && e.isTournament && typeof e.tournamentStage === 'string' && e.tournamentStage.startsWith('Bracket'));
            if (!bracketEpisodes.length) { container.classList.add('hidden'); return; }
            container.classList.remove('hidden');

            const byBracket = {};
            bracketEpisodes.forEach(e => {
                const key = e.tournamentStage;
                if (!byBracket[key]) byBracket[key] = [];
                byBracket[key].push(e);
            });
            Object.values(byBracket).forEach(arr => arr.sort((a, b) => a.episode - b.episode));
            const bracketKeys = Object.keys(byBracket).sort((a, b) => {
                const na = parseInt(String(a).replace(/\D+/g, ''), 10);
                const nb = parseInt(String(b).replace(/\D+/g, ''), 10);
                return (isNaN(na) ? 99 : na) - (isNaN(nb) ? 99 : nb);
            });

            const getTop2Names = (ep) => {
                const top2 = Array.isArray(ep.top2) ? ep.top2 : [];
                return top2.map(t => (t && t.name) ? t.name : t).filter(Boolean);
            };
            const earnedPointsFor = (ep, name) => {
                const top2Names = getTop2Names(ep);
                let pts = 0;
                if (top2Names.includes(name)) pts += 2;
                if (ep.isDoubleWin) {
                    if (top2Names.includes(name)) pts += 1;
                } else if (ep.lipSyncWinner === name) {
                    pts += 1;
                }
                return pts;
            };
            const giftPointsFor = (ep, name) => {
                const gifts = Array.isArray(ep.pointGifts) ? ep.pointGifts : [];
                return gifts.filter(g => g && g.to === name).length;
            };

            const colCount = 1 + (3 * 2) + 1;
            let html = '';
            bracketKeys.forEach(brKey => {
                const eps = (byBracket[brKey] || []).slice(0, 3);
                if (eps.length === 0) return;
                const castSet = new Set();
                eps.forEach(ep => (ep.scores || []).forEach(s => { if (s && s.name) castSet.add(s.name); }));
                const cast = [...castSet].map(name => {
                    let total = 0;
                    for (let i = 0; i < 3; i++) {
                        const ep = eps[i];
                        const earned = ep ? earnedPointsFor(ep, name) : 0;
                        const gift = ep ? giftPointsFor(ep, name) : 0;
                        total += earned + gift;
                    }
                    return { name, total };
                }).sort((a, b) => b.total - a.total);

                let bg = '#6b7280';
                if (typeof ensureTournamentBracketState === 'function') {
                    const st = ensureTournamentBracketState();
                    if (st.colors) {
                        if (brKey.includes('1')) bg = st.colors.A || bg;
                        else if (brKey.includes('2')) bg = st.colors.B || bg;
                        else if (brKey.includes('3')) bg = st.colors.C || bg;
                    }
                }

                html += `
                    <tbody>
                        <tr><td class="bracket-title" style="background-color: ${bg} !important;" colspan="${colCount}">${brKey}</td></tr>
                        <tr class="bp-head">
                            <td class="text-left">Contestant</td>
                            ${eps.map(ep => `<td colspan="2">Ep. ${ep.episode}</td>`).join('')}
                            ${eps.length < 3 ? Array.from({ length: (3 - eps.length) }, () => `<td colspan="2">—</td>`).join('') : ''}
                            <td>Total Points</td>
                        </tr>
                        <tr class="bp-sub">
                            <td></td>
                            ${Array.from({ length: 3 }, () => `<td>Pts</td><td>Gift</td>`).join('')}
                            <td></td>
                        </tr>
                        ${cast.map(obj => {
                            const name = obj.name;
                            const total = obj.total;
                            const cells = [];
                            for (let i = 0; i < 3; i++) {
                                const ep = eps[i];
                                const earned = ep ? earnedPointsFor(ep, name) : 0;
                                const gift = ep ? giftPointsFor(ep, name) : 0;
                                const earnedText = earned ? `+${earned}` : '—';
                                const giftText = gift ? `+${gift}` : '—';
                                cells.push(`<td class="bp-earned${earned ? ' pos pos-' + earned : ''}">${earnedText}</td>`);
                                cells.push(`<td class="bp-gift${gift ? ' pos pos-gift' : ''}">${giftText}</td>`);
                            }
                            return `
                                <tr>
                                    <td class="text-left font-bold">${name}</td>
                                    ${cells.join('')}
                                    <td class="bp-total">${total}</td>
                                </tr>
                            `;
                        }).join('')}
                    </tbody>
                `;
            });
            table.innerHTML = html;
            return;
        }

        const episodes = seasonData.episodes.filter(e => !e.isFinale && e.episode <= maxEpisode && e.lipstickChoices);
        if (!episodes.length) { container.classList.add('hidden'); return; }
        container.classList.remove('hidden');
        let html = `
            <thead>
                <tr>
                    <th class="text-left">Ep</th>
                    <th>Winner</th>
                    <th>Pick</th>
                    <th>Top 2</th>
                    <th>Pick</th>
                </tr>
            </thead>
            <tbody>`;
        episodes.forEach(ep => {
            if (ep.isDoubleWin) {
                const win1 = ep.top2[0].name;
                const win2 = ep.top2[1].name;
                const pick1 = ep.lipstickChoices[win1];
                const pick2 = ep.lipstickChoices[win2];
                html += `
                    <tr>
                        <td class="font-bold text-gray-500">${ep.episode}</td>
                        <td><div class="flex items-center justify-center gap-2"><img src="${queensDb[win1] ? queensDb[win1].photo : ''}" class="queen-img-sm" style="box-shadow: none;"><span class="font-bold">${win1}</span></div></td>
                        <td><span class="font-bold text-red-600">${pick1 || '-'}</span></td>
                        <td><span class="font-bold text-gray-600">-</span></td>
                        <td><span class="font-bold text-gray-600">-</span></td>
                    </tr>
                    <tr>
                        <td class="font-bold text-gray-500">${ep.episode}</td>
                        <td><div class="flex items-center justify-center gap-2"><img src="${queensDb[win2] ? queensDb[win2].photo : ''}" class="queen-img-sm" style="box-shadow: none;"><span class="font-bold">${win2}</span></div></td>
                        <td><span class="font-bold text-red-600">${pick2 || '-'}</span></td>
                        <td><span class="font-bold text-gray-600">-</span></td>
                        <td><span class="font-bold text-gray-600">-</span></td>
                    </tr>`;
            } else {
                const winName = ep.lipSyncWinner;
                const loserName = ep.lipSyncLoser;
                const winPick = ep.lipstickChoices[winName];
                const loserPick = ep.lipstickChoices[loserName];
                html += `
                    <tr>
                        <td class="font-bold text-gray-500">${ep.episode}</td>
                        <td><div class="flex items-center justify-center gap-2"><img src="${queensDb[winName] ? queensDb[winName].photo : ''}" class="queen-img-sm"><span class="font-bold">${winName}</span></div></td>
                        <td><span class="font-bold text-red-600">${winPick || '-'}</span></td>
                        <td><div class="flex items-center justify-center gap-2"><img src="${queensDb[loserName] ? queensDb[loserName].photo : ''}" class="queen-img-sm"><span class="font-bold text-gray-600">${loserName}</span></div></td>
                        <td><span class="font-bold text-gray-600">${loserPick || '-'}</span></td>
                    </tr>`;
            }
        });
        html += `</tbody>`;
        table.innerHTML = html;
    }

    async function downloadTrackRecordAsImage() {
        const table = document.getElementById('trackRecordTable');
        if (!table || typeof htmlToImage === 'undefined') return;
        
        // Show loading indicator or toast if needed
        const btn = document.getElementById('downloadTrackRecordBtn');
        const originalText = btn ? btn.textContent : '';
        if (btn) btn.textContent = 'Generating...';

        htmlToImage.toPng(table, {
            pixelRatio: 2,
            backgroundColor: '#ffffff',
            // Disable cacheBust to speed up image loading and avoid CORS issues with some CDNs
            cacheBust: false,
            // Filter out external stylesheets to prevent SecurityError with cross-origin CSS rules
            filter: (node) => {
                // Filter out link tags that point to external stylesheets (like Google Fonts)
                if (node.tagName === 'LINK' && node.rel === 'stylesheet') {
                    return false;
                }
                return true;
            },
            // Skip cloning external stylesheets
            skipAutoScale: true,
            fontEmbedCSS: '' // Prevent embedding fonts which might cause CORS issues
        }).then(function(dataUrl) {
            const link = document.createElement('a');
            link.download = 'track-record.png';
            link.href = dataUrl;
            link.click();
            if (btn) btn.textContent = originalText;
        }).catch(function(err) { 
            console.warn('Download failed:', err); 
            if (btn) btn.textContent = originalText;
            showToast('Failed to generate image. Please try again.', 'error');
        });
    }

    const downloadBtn = document.getElementById('downloadTrackRecordBtn');
    if (downloadBtn) downloadBtn.addEventListener('click', downloadTrackRecordAsImage);

    updatePreSimStepIndicators();
    renderQueensGrid();
    </script>
    <div id="queenStatsModal" class="hidden fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center p-4">
        <div class="bg-white w-full max-w-4xl max-h-[90vh] rounded-2xl shadow-2xl flex flex-col overflow-hidden">
            <div class="flex items-center justify-between p-6 border-b border-gray-100">
                <h3 class="text-xl font-black text-gray-900">Queen Stats</h3>
                <button onclick="closeQueenStats()" class="p-2 rounded-full hover:bg-gray-100 text-gray-400 hover:text-gray-600 transition">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
            <div class="flex-1 overflow-auto p-6">
                <table class="w-full text-sm text-left">
                    <thead class="text-xs text-gray-500 uppercase bg-gray-50 sticky top-0 z-10">
                        <tr>
                            <th class="px-4 py-3 rounded-tl-lg bg-gray-50">Queen</th>
                            <th class="px-4 py-3 text-center bg-gray-50" title="Fashion">FAS</th>
                            <th class="px-4 py-3 text-center bg-gray-50" title="Design">DES</th>
                            <th class="px-4 py-3 text-center bg-gray-50" title="Performance">PER</th>
                            <th class="px-4 py-3 text-center bg-gray-50" title="Comedy">COM</th>
                            <th class="px-4 py-3 text-center bg-gray-50" title="Acting">ACT</th>
                            <th class="px-4 py-3 text-center bg-gray-50" title="Improv">IMP</th>
                            <th class="px-4 py-3 text-center bg-gray-50" title="Lipsync">LIP</th>
                            <th class="px-4 py-3 text-center font-black rounded-tr-lg bg-gray-50" title="Total Score">TOTAL</th>
                        </tr>
                    </thead>
                    <tbody id="queenStatsTableBody" class="divide-y divide-gray-100">
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
    function showQueenStats() {
        const modal = document.getElementById('queenStatsModal');
        const tbody = document.getElementById('queenStatsTableBody');
        tbody.innerHTML = '';

        const allQueens = Object.keys(window.queensDb).map(name => {
            const q = window.queensDb[name];
            const total = (q.fashion || 0) + (q.design || 0) + (q.performance || 0) + (q.comedy || 0) + (q.acting || 0) + (q.improv || 0) + (q.lipsync || 0);
            return { name, q, total };
        }).sort((a, b) => b.total - a.total);

        allQueens.forEach(({ name, q, total }) => {
            
            const tr = document.createElement('tr');
            tr.className = 'hover:bg-gray-50 transition';
            tr.innerHTML = `
                <td class="px-4 py-3 font-bold text-gray-900 flex items-center gap-3">
                    <img src="${q.photo}" class="w-8 h-8 rounded-full object-cover border border-gray-200">
                    ${name}
                </td>
                <td class="px-4 py-3 text-center text-gray-600">${q.fashion}</td>
                <td class="px-4 py-3 text-center text-gray-600">${q.design}</td>
                <td class="px-4 py-3 text-center text-gray-600">${q.performance}</td>
                <td class="px-4 py-3 text-center text-gray-600">${q.comedy}</td>
                <td class="px-4 py-3 text-center text-gray-600">${q.acting}</td>
                <td class="px-4 py-3 text-center text-gray-600">${q.improv}</td>
                <td class="px-4 py-3 text-center text-gray-600">${q.lipsync}</td>
                <td class="px-4 py-3 text-center font-black text-pink-600">${total}</td>
            `;
            tbody.appendChild(tr);
        });

        modal.classList.remove('hidden');
    }

    function closeQueenStats() {
        document.getElementById('queenStatsModal').classList.add('hidden');
    }
    </script>
    <script src="untucked.js"></script>
</body>
</html>
